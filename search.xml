<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MAC常用指令汇总</title>
      <link href="/2024/01/17/mac-chang-yong-zhi-ling-hui-zong/"/>
      <url>/2024/01/17/mac-chang-yong-zhi-ling-hui-zong/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便分身乏术发写写……  </p><h1 id="通过-n-模块管理-node-版本"><a href="#通过-n-模块管理-node-版本" class="headerlink" title="通过 n 模块管理 node 版本"></a>通过 n 模块管理 node 版本</h1><hr><ul><li>在开发的工程中，我们可能需要切换 node 版本来应对不同的开发环境，所以需要经常使用不同版本的node；</li></ul><p>** Node 版本的管理</p><h2 id="安装-npm-插件-n，通过-n-模块来管理-node-版本；"><a href="#安装-npm-插件-n，通过-n-模块来管理-node-版本；" class="headerlink" title="安装 npm 插件 n，通过 n 模块来管理 node 版本；"></a>安装 npm 插件 n，通过 n 模块来管理 node 版本；</h2><ul><li><p>1.全局安装 n 模块</p><pre class="line-numbers language-js"><code class="language-js">npm install <span class="token operator">-</span>g ncnpm install <span class="token operator">-</span>g n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>1.全局安装 n 模块</p><pre class="line-numbers language-js"><code class="language-js">npm install <span class="token operator">-</span>g ncnpm install <span class="token operator">-</span>g n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>2.安装指定版本的 node</p><pre class="line-numbers language-js"><code class="language-js">n v18<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>3.卸载指定版本的 node</p><pre class="line-numbers language-js"><code class="language-js">n rm v18<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>4.切换版本</p><pre class="line-numbers language-js"><code class="language-js">n <span class="token comment" spellcheck="true">// sudo n </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入 n 可以查看你所有的版本，通过箭头和回车可以选择你想要切换的版本，通过 q (英文的情况下)结束;</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一键生成项目模板</title>
      <link href="/2023/06/22/yi-jian-sheng-cheng-xiang-mu-mo-ban/"/>
      <url>/2023/06/22/yi-jian-sheng-cheng-xiang-mu-mo-ban/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><h2 id="1-在根目录下创建空模板template-js"><a href="#1-在根目录下创建空模板template-js" class="headerlink" title="1. 在根目录下创建空模板template.js"></a>1. 在根目录下创建空模板template.js</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// pages模板快速生成脚本</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> prettier <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'prettier'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> camelCase <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>camelCase<span class="token punctuation">;</span><span class="token keyword">const</span> upperFirst <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upperFirst<span class="token punctuation">;</span><span class="token keyword">const</span> prettierConfig <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`./.prettierrc`</span></span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  parser<span class="token punctuation">:</span> <span class="token string">'babel'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> dirName <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dirName<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件夹名称不能为空！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'示例：npm run tpl test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 页面模版</span><span class="token keyword">const</span> indexTpl <span class="token operator">=</span> <span class="token template-string"><span class="token string">`import Taro from "@tarojs/taro";import React, { FC, useState, useEffect } from "react";import { Dispatch } from "redux";import { useSelector, useDispatch } from "react-redux";export default </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">titleCase</span><span class="token punctuation">(</span>dirName<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;`</span></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// scss文件模版</span><span class="token keyword">const</span> scssTpl <span class="token operator">=</span> <span class="token template-string"><span class="token string">`// 样式// @import "xxx.scss";.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-page {}`</span></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 页面配置文件模板</span><span class="token keyword">const</span> indexConfigTpl <span class="token operator">=</span> <span class="token template-string"><span class="token string">`export default {  navigationBarTitleText: "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">",};`</span></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// model文件模版</span><span class="token keyword">const</span> modelTpl <span class="token operator">=</span> <span class="token template-string"><span class="token string">`import Taro from "@tarojs/taro";import { ready, oauth } from "fastman3-dfyjapp-jsbridge";import { modelExtend } from "@/models/common";import { Action, EffectCommand } from "fastman3-framework-core";/** * 声明业务 model 需通过 modelExtend&lt;typeof ModelState> 来创建 */export default modelExtend&lt;ModelState>({  namespace: "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">",  // 在这里对 ModelState 进行数据初始化操作  state: {    // count: 0,  },  effects: {    *load({ payload }: Action, { call, put, select }: EffectCommand) {      // 调用 service 的代码示例，假设 getData 由 services 层 export      // const res = yield call(getData, { payload });      // 调用 reducers 的代码示例      // yield put({      //   type: INCREMENT,      //   payload: {      //     // param1: res.data // 模拟传参      //   },      // });    },  },  reducers: {    // INCREMENT(state: ModelState, { payload }) {    //   return { ...state, ...payload };    // },  },});`</span></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 写入对应目录</span><span class="token keyword">try</span> <span class="token punctuation">{</span>  fs<span class="token punctuation">.</span><span class="token function">mkdirSync</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`./src/pages/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mkdir $1</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">目录已存在，生成失败`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>fs<span class="token punctuation">.</span><span class="token function">writeFileSync</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`./src/pages/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/index.tsx`</span></span><span class="token punctuation">,</span> indexTpl<span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">writeFileSync</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`./src/pages/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/index.scss`</span></span><span class="token punctuation">,</span> scssTpl<span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">writeFileSync</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`./src/pages/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/index.config.ts`</span></span><span class="token punctuation">,</span> indexConfigTpl<span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">writeFileSync</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`./src/pages/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/model.ts`</span></span><span class="token punctuation">,</span> modelTpl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最后将自动创建的 model 导出到全局 model 文件内</span><span class="token keyword">const</span> modelsIndex <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`./src/models/index.ts`</span></span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> modelsIndexTep1 <span class="token operator">=</span> <span class="token template-string"><span class="token string">`model";import </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> from "@/pages/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/model";`</span></span><span class="token punctuation">;</span><span class="token keyword">const</span> modelsIndexTep2 <span class="token operator">=</span> <span class="token template-string"><span class="token string">`, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">];`</span></span><span class="token punctuation">;</span><span class="token keyword">const</span> modelsIndexTep3 <span class="token operator">=</span> <span class="token template-string"><span class="token string">`>, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: ReturnDvaState&lt;typeof </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">>,`</span></span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>modelsIndex<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`pages/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/model`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 由 prettier 控制代码规范化，以致于模板处理可以更标准化</span>  <span class="token keyword">const</span> __newModelsIndex <span class="token operator">=</span> modelsIndex<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'model";'</span><span class="token punctuation">,</span> modelsIndexTep1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> _newModelsIndex <span class="token operator">=</span> __newModelsIndex<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'];'</span><span class="token punctuation">,</span> modelsIndexTep2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> newModelsIndex <span class="token operator">=</span> _newModelsIndex<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'>,'</span><span class="token punctuation">,</span> modelsIndexTep3<span class="token punctuation">)</span><span class="token punctuation">;</span>  fs<span class="token punctuation">.</span><span class="token function">writeFileSync</span><span class="token punctuation">(</span><span class="token string">'./src/models/index.ts'</span><span class="token punctuation">,</span> prettier<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>newModelsIndex<span class="token punctuation">,</span> prettierConfig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`模版</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dirName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">已创建！`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">titleCase</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">upperFirst</span><span class="token punctuation">(</span><span class="token function">camelCase</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-配置-package-json"><a href="#2-配置-package-json" class="headerlink" title="2. 配置 package.json"></a>2. 配置 package.json</h2><ul><li>配置指令</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"tpl"</span><span class="token punctuation">:</span> <span class="token string">"node template.js"</span><span class="token punctuation">,</span>    <span class="token operator">...</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><pre class="line-numbers language-js"><code class="language-js"> npm run tpl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义脚手架-cli</title>
      <link href="/2023/05/22/zi-ding-yi-jiao-shou-jia/"/>
      <url>/2023/05/22/zi-ding-yi-jiao-shou-jia/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>写在前面：2021年已经过去一半了，时间真的过的稍微有点快呀～ ……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><blockquote><p>搭建自己的一个cli，首先是要知道自己想要实现什么功能，然后在确定交互形式，简言之就是先实现思路，再进行搭建</p></blockquote><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// commander:解析用户输入的命令</span><span class="token keyword">const</span> program <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'commander'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 提供给我们单选/多选项目</span><span class="token keyword">const</span> inquirer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'inquirer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 函数的跨平台写法</span><span class="token keyword">const</span> spwn <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"cross-spawn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-配置package-json"><a href="#2-配置package-json" class="headerlink" title="2. 配置package.json"></a>2. 配置package.json</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"cli"</span><span class="token punctuation">:</span><span class="token string">"node cli.js"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 启动指令</span>    <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-创建文件cli-js"><a href="#3-创建文件cli-js" class="headerlink" title="3. 创建文件cli.js"></a>3. 创建文件cli.js</h2><p>们的可执行文件放置在bin的目录的cli文件中，<br>此时我们要配置当前脚手架的执行环境，因此需要在cli文件的头部添加上</p><pre class="line-numbers language-js"><code class="language-js">#<span class="token operator">!</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>env node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>该信息必须在头部，不能在其顶部添加任何其他的信息，否则会导致报错，</p></blockquote><pre class="line-numbers language-js"><code class="language-js">#<span class="token operator">!</span> <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>env node<span class="token keyword">const</span> program <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'commander'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> spwn <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"cross-spawn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> inquirer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'inquirer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去除环境,启动端描述和空格</span><span class="token keyword">const</span> toFilter<span class="token operator">=</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   <span class="token keyword">let</span> valStr<span class="token operator">=</span>val<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">let</span> RemoveSpace<span class="token operator">=</span>valStr<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/(\s*$)/g</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> RemoveSpace<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 业务开发目录</span><span class="token keyword">const</span> businessFilesPath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">"/src/pages"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取业务文件名</span><span class="token keyword">const</span> businessFilesNames <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readdirSync</span><span class="token punctuation">(</span>businessFilesPath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> Run<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">const</span> promptList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span> <span class="token string">'list'</span><span class="token punctuation">,</span>        message<span class="token punctuation">:</span> <span class="token string">'请选择运行环境:'</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span> <span class="token string">'env'</span><span class="token punctuation">,</span>        choices<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token string">"mock - 本地开发环境"</span><span class="token punctuation">,</span>          <span class="token string">"dev - 联调环境"</span><span class="token punctuation">,</span>          <span class="token string">"sit - 测试环境"</span><span class="token punctuation">,</span>          <span class="token string">"uat - 仿真环境"</span><span class="token punctuation">,</span>          <span class="token string">"build - 生产环境"</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        filter<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 去除文字描述</span>          <span class="token keyword">return</span> <span class="token function">toFilter</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span> <span class="token string">'list'</span><span class="token punctuation">,</span>        message<span class="token punctuation">:</span> <span class="token string">'请选择启动端:'</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span> <span class="token string">'tool'</span><span class="token punctuation">,</span>        choices<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token string">"h5 - webapp"</span><span class="token punctuation">,</span>          <span class="token string">"weapp - 微信小程序"</span><span class="token punctuation">,</span>          <span class="token string">"alipay - 支付宝小程序"</span><span class="token punctuation">,</span>          <span class="token string">"swan - 百度小程序"</span><span class="token punctuation">,</span>          <span class="token string">"tt - 字节跳动小程序"</span><span class="token punctuation">,</span>          <span class="token string">"qq - QQ小程序"</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        filter<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 去除文字描述</span>          <span class="token keyword">return</span> <span class="token function">toFilter</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span> <span class="token string">'list'</span><span class="token punctuation">,</span>        message<span class="token punctuation">:</span> <span class="token string">'是否打包:'</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span> <span class="token string">'IsDist'</span><span class="token punctuation">,</span>        choices<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token string">"Yes"</span><span class="token punctuation">,</span>          <span class="token string">"No"</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        when<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>answers<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">const</span> <span class="token punctuation">{</span>env<span class="token punctuation">,</span>tool<span class="token punctuation">}</span><span class="token operator">=</span>answers<span class="token punctuation">;</span>            <span class="token keyword">let</span> envList<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'sit'</span><span class="token punctuation">,</span><span class="token string">'uat'</span><span class="token punctuation">,</span><span class="token string">'build'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>envList<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        type<span class="token punctuation">:</span> <span class="token string">'list'</span><span class="token punctuation">,</span>        message<span class="token punctuation">:</span> <span class="token string">'请选择模块:'</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span> <span class="token string">'module'</span><span class="token punctuation">,</span>        choices<span class="token punctuation">:</span>businessFilesNames<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> <span class="token string">'list'</span><span class="token punctuation">,</span>          message<span class="token punctuation">:</span> <span class="token string">'PWA是否启用:'</span><span class="token punctuation">,</span>          name<span class="token punctuation">:</span> <span class="token string">'PWA'</span><span class="token punctuation">,</span>          choices<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token string">"true"</span><span class="token punctuation">,</span>            <span class="token string">"false"</span>          <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">]</span><span class="token punctuation">;</span>      inquirer<span class="token punctuation">.</span><span class="token function">prompt</span><span class="token punctuation">(</span>promptList<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>answers <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">const</span><span class="token punctuation">{</span> env<span class="token punctuation">,</span> tool<span class="token punctuation">,</span> module<span class="token punctuation">,</span> PWA<span class="token punctuation">,</span>IsDist <span class="token punctuation">}</span> <span class="token operator">=</span> answers<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// console.log(IsDist);</span>        <span class="token keyword">let</span> envList<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'sit'</span><span class="token punctuation">,</span><span class="token string">'uat'</span><span class="token punctuation">,</span><span class="token string">'build'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> watch<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>envList<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> tool <span class="token operator">===</span> <span class="token string">'h5'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>IsDist <span class="token operator">&amp;&amp;</span> IsDist<span class="token operator">===</span><span class="token string">"Yes"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                watch<span class="token operator">=</span><span class="token string">""</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                watch<span class="token operator">=</span><span class="token string">":watch"</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// const watch = (envList.indexOf(env) != -1 &amp;&amp; tool === 'h5') || IsDist==='N' ? ':watch' : '';</span>        <span class="token keyword">let</span>  order<span class="token operator">=</span> <span class="token template-string"><span class="token string">`npm run </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>env<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tool<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>watch<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> APP_CONFIG=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>module<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">H5 PWA_ENABLE=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>PWA<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回的结果</span>        <span class="token function">spwn</span><span class="token punctuation">(</span><span class="token string">"npm"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>          <span class="token string">"run"</span><span class="token punctuation">,</span>          <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>env<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tool<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>watch<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span>          <span class="token template-string"><span class="token string">`APP_CONFIG=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>module<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">H5`</span></span><span class="token punctuation">,</span>          <span class="token template-string"><span class="token string">`PWA_ENABLE=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>PWA<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">{</span>stdio<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"pipe"</span><span class="token punctuation">,</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">,</span>process<span class="token punctuation">.</span>stderr<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>program  <span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 用来解析终端输入的 options</span>program<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><pre class="line-numbers language-js"><code class="language-js"> npm run cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC 真机调试</title>
      <link href="/2023/01/23/mac-zhen-ji-diao-shi/"/>
      <url>/2023/01/23/mac-zhen-ji-diao-shi/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便分身乏术发写写……  </p><h1 id="通过-n-模块管理-node-版本"><a href="#通过-n-模块管理-node-版本" class="headerlink" title="通过 n 模块管理 node 版本"></a>通过 n 模块管理 node 版本</h1><hr><ul><li>在开发的工程中，我们可能需要切换 node 版本来应对不同的开发环境，所以需要经常使用不同版本的node；</li></ul><h2 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h2><h3 id="1-调出开发者选项"><a href="#1-调出开发者选项" class="headerlink" title="1.调出开发者选项"></a>1.调出开发者选项</h3><blockquote><p>在安卓4.2及更新的版本中，默认情况下，【开发者选项】是隐藏的。要启用【开发者选项】，设置 -&gt; 关于手机 -&gt; 版本号，对着版本号点击7次。<br>设置 -&gt; 开发者选项 -&gt; USB调试</p></blockquote><h3 id="2-连接手机和电脑"><a href="#2-连接手机和电脑" class="headerlink" title="2.连接手机和电脑"></a>2.连接手机和电脑</h3><ol><li><p>用数据线，mac转接头把android和mac连接起来；</p></li><li><p>打开android的chrome浏览器中需要调试的网页；</p></li><li><p>打开mac的chrome浏览器，在地址栏输入chrome://inspect。进入后，确认Discover USB devices已经勾选了，允许在电脑端进行USB调试；</p></li><li><p>在remote target上方，就可以看到连进来的手机型号；</p></li><li><p>选择元素，用电脑调试手机真机页面。</p></li></ol><h2 id="苹果"><a href="#苹果" class="headerlink" title="苹果"></a>苹果</h2><h3 id="1-首先将iOS设备通过USB线连接到Mac电脑。"><a href="#1-首先将iOS设备通过USB线连接到Mac电脑。" class="headerlink" title="1.首先将iOS设备通过USB线连接到Mac电脑。"></a>1.首先将iOS设备通过USB线连接到Mac电脑。</h3><p>打开Xcode，选择连接的iOS设备作为调试目标。</p><h3 id="2-在Xcode中选择设备"><a href="#2-在Xcode中选择设备" class="headerlink" title="2.在Xcode中选择设备"></a>2.在Xcode中选择设备</h3><p>打开Xcode，选择连接的iOS设备作为调试目标。</p><h3 id="3-设置开发者模式"><a href="#3-设置开发者模式" class="headerlink" title="3.设置开发者模式"></a>3.设置开发者模式</h3><p>在Xcode中，选择项目并点击”General”选项卡。在”Signing”部分，选择Team，并勾选”Automatically manage signing”。</p><h3 id="4-运行调试程序"><a href="#4-运行调试程序" class="headerlink" title="4.运行调试程序"></a>4.运行调试程序</h3><p>编译并运行项目，程序将在连接的iOS设备上调试运行。<br> <img src="mac.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端常见问题汇总</title>
      <link href="/2021/11/22/yi-dong-duan-chang-jian-wen-ti-hui-zong/"/>
      <url>/2021/11/22/yi-dong-duan-chang-jian-wen-ti-hui-zong/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1313052971&auto=1&height=66"></iframe><p>闲来无事，随便写写……</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>本文是摘录整理了移动端常见的一些bug以及解决方案，第一篇，后面还会有持续的文章更新整理。</p><h1 id="1-禁止用户选择页面中的文字或者图片"><a href="#1-禁止用户选择页面中的文字或者图片" class="headerlink" title="1. 禁止用户选择页面中的文字或者图片"></a>1. 禁止用户选择页面中的文字或者图片</h1><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">-</span>webkit<span class="token operator">-</span>touch<span class="token operator">-</span>callout<span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token operator">-</span>webkit<span class="token operator">-</span>user<span class="token operator">-</span>select<span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token operator">-</span>khtml<span class="token operator">-</span>user<span class="token operator">-</span>select<span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token operator">-</span>moz<span class="token operator">-</span>user<span class="token operator">-</span>select<span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token operator">-</span>ms<span class="token operator">-</span>user<span class="token operator">-</span>select<span class="token punctuation">:</span> none<span class="token punctuation">;</span>user<span class="token operator">-</span>select<span class="token punctuation">:</span> none<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-移动端如何清除输入框内阴影"><a href="#2-移动端如何清除输入框内阴影" class="headerlink" title="2. 移动端如何清除输入框内阴影"></a>2. 移动端如何清除输入框内阴影</h1><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">-</span>webkit<span class="token operator">-</span>text<span class="token operator">-</span>size<span class="token operator">-</span>adjust<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-IOS的input不能自动获得焦点"><a href="#3-IOS的input不能自动获得焦点" class="headerlink" title="3. IOS的input不能自动获得焦点"></a>3. IOS的input不能自动获得焦点</h1><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//不能把focus封装起来起来触发，那样也无效</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'touchstart'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-动画定义3D启用硬件加速"><a href="#4-动画定义3D启用硬件加速" class="headerlink" title="4. 动画定义3D启用硬件加速"></a>4. 动画定义3D启用硬件加速</h1><pre class="line-numbers language-js"><code class="language-js">Element <span class="token punctuation">{</span>  <span class="token operator">-</span>webkit<span class="token operator">-</span>transform<span class="token punctuation">:</span><span class="token function">translate3d</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  transform<span class="token punctuation">:</span> <span class="token function">translate3d</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-移动端点击300ms延迟"><a href="#5-移动端点击300ms延迟" class="headerlink" title="5. 移动端点击300ms延迟"></a>5. 移动端点击300ms延迟</h1><pre class="line-numbers language-js"><code class="language-js">300ms尚可接受，不过因为300ms产生的问题，我们必须要解决。300ms导致用户体验并不是很好，解决这个问题，我们一般在移动端用tap事件来取代click事件。推荐两个js，一个是fastclick，一个是tap<span class="token punctuation">.</span>js关于300ms延迟，具体请看：http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>thx<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token operator">/</span>mobile<span class="token regex">/300ms-click-delay/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="6-移动端点透问题"><a href="#6-移动端点透问题" class="headerlink" title="6.移动端点透问题"></a>6.移动端点透问题</h1><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//案例如下：</span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"haorooms"</span><span class="token operator">></span>点头事件测试<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"www.jb51.net"</span><span class="token operator">></span>www<span class="token punctuation">.</span>jb51<span class="token punctuation">.</span>net<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token comment" spellcheck="true">//div是绝对定位的蒙层,并且z-index高于a。而a标签是页面中的一个链接，我们给div绑定tap事件：</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#haorooms'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'tap'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#haorooms'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//我们点击蒙层时 div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。</span><span class="token comment" spellcheck="true">// 原因：touchstart 早于 touchend 早于click。 亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。</span><span class="token comment" spellcheck="true">//解决：</span><span class="token function">（1）尽量都使用touch事件来替换click事件。例如用touchend事件</span><span class="token punctuation">(</span>推荐<span class="token punctuation">)</span>。（<span class="token number">2</span>）用fastclick，https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>ftlabs<span class="token operator">/</span>fastclick（<span class="token number">3</span>）用preventDefault阻止a标签的click<span class="token function">（4）延迟一定的时间</span><span class="token punctuation">(</span>300ms<span class="token operator">+</span><span class="token punctuation">)</span>来处理事件 （不推荐）（<span class="token number">5</span>）以上一般都能解决，实在不行就换成click事件。下面介绍一下touchend事件，如下：<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#haorooms"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"touchend"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>  event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-h5屏幕适配"><a href="#7-h5屏幕适配" class="headerlink" title="7. h5屏幕适配"></a>7. h5屏幕适配</h1><ul><li>使用rem进行等比缩放<blockquote><p>rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小,比如根元素（html）设置font-size=12px; 非根元素设置width:2rem;则换成px表示就是24px,如果根元素设置成font-size=1rem;则根元素换成px就是相对于初始字体大小，一般是12px；<br>原理分析：rem屏幕适配就是一种等比缩放效果<br>一般来说设计稿是基于p6（750），或者是p5（640）的尺寸，以p6为例子：</p></blockquote></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 设置</span><span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width,initial-scale=1.0,maximum-scale=1,user-scale=no"</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>doc<span class="token punctuation">,</span> win<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> docEl <span class="token operator">=</span> doc<span class="token punctuation">.</span>documentElement  <span class="token keyword">var</span> resizeEvt <span class="token operator">=</span> <span class="token string">'orientationchange'</span> <span class="token keyword">in</span> window <span class="token operator">?</span> <span class="token string">'orientationchange'</span> <span class="token punctuation">:</span> <span class="token string">'resize'</span>  <span class="token keyword">var</span> recalc <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> clientWidth <span class="token operator">=</span> docEl<span class="token punctuation">.</span>clientWidth    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>clientWidth<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>clientWidth <span class="token operator">>=</span> <span class="token number">750</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 避免无无限放大</span>      docEl<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token string">'100px'</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      docEl<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token number">100</span><span class="token operator">*</span><span class="token punctuation">(</span>clientWidth <span class="token operator">/</span> <span class="token number">750</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span> <span class="token comment" spellcheck="true">// 设置根元素的font-size</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>doc<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span>  <span class="token punctuation">}</span>  win<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>resizeEvt<span class="token punctuation">,</span> recalc<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>  doc<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> recalc<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>document<span class="token punctuation">,</span> window<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>使用vw进行适配布局<br>相对于视口的宽度。视口被均分为100单位的vw<br>如果屏幕宽度为200px，那么1vw=2px</p></li><li><p>dpr </p><blockquote><p>默认单位 dp</p></blockquote></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>Dimensions<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-native'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 58 app 只有竖屏模式，所以可以只获取一次 width</span><span class="token keyword">const</span> deviceWidthDp <span class="token operator">=</span> Dimensions<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'window'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>width<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// UI 默认给图是 640</span><span class="token keyword">const</span> uiWidthPx <span class="token operator">=</span> <span class="token number">640</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">pxToDp</span><span class="token punctuation">(</span>uiElementPx<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> uiElementPx <span class="token operator">*</span>  deviceWidthDp <span class="token operator">/</span> uiWidthPx<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="8-ios-使用-position-sticky-实现粘性布局"><a href="#8-ios-使用-position-sticky-实现粘性布局" class="headerlink" title="8. ios 使用 position:sticky 实现粘性布局"></a>8. ios 使用 position:sticky 实现粘性布局</h1><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 失效原因:</span><span class="token comment" spellcheck="true">//1.父元素高度没子元素高，通常为父元素设置height:100%;</span><span class="token comment" spellcheck="true">//2:父元素设置了overflow:hidden,overflow-x:hidden,overflow-y:hidden,或者overflow:auto属性都能影响到</span><span class="token punctuation">{</span>    position<span class="token punctuation">:</span> sticky<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9-js获取手机屏幕宽度、高度"><a href="#9-js获取手机屏幕宽度、高度" class="headerlink" title="9. js获取手机屏幕宽度、高度"></a>9. js获取手机屏幕宽度、高度</h1><p>网页可见区域宽：document.body.clientWidth<br>网页可见区域高：document.body.clientHeight<br>网页可见区域宽：document.body.offsetWidth (包括边线的宽)<br>网页可见区域高：document.body.offsetHeight (包括边线的宽)<br>网页正文全文宽：document.body.scrollWidth<br>网页正文全文高：document.body.scrollHeight<br>网页被卷去的高：document.body.scrollTop<br>网页被卷去的左：document.body.scrollLeft<br>网页正文部分上：window.screenTop<br>网页正文部分左：window.screenLeft<br>屏幕分辨率的高：window.screen.height<br>屏幕分辨率的宽：window.screen.width<br>屏幕可用工作区高度：window.screen.availHeight<br>屏幕可用工作区宽度：window.screen.availWidth </p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//判断手机类型 例iphone X</span><span class="token keyword">function</span> <span class="token function">isIphoneX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token regex">/iphone/gi</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>navigator<span class="token punctuation">.</span>userAgent<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>screen<span class="token punctuation">.</span>height <span class="token operator">==</span> <span class="token number">812</span> <span class="token operator">&amp;&amp;</span> screen<span class="token punctuation">.</span>width <span class="token operator">==</span> <span class="token number">375</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="10-ios-input框输入存在小数点光标跑到最后"><a href="#10-ios-input框输入存在小数点光标跑到最后" class="headerlink" title="10. ios input框输入存在小数点光标跑到最后"></a>10. ios input框输入存在小数点光标跑到最后</h1><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">;</span><span class="token keyword">const</span> matchResult <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/^(?!0\d)\d{1,12}((\.\d{1,2})|\.)?/</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> available <span class="token operator">=</span> matchResult <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token punctuation">:</span> matchResult<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>available <span class="token operator">!==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token operator">=</span> available<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="11-ios：iphoneX及以上底部安全区适配"><a href="#11-ios：iphoneX及以上底部安全区适配" class="headerlink" title="11. ios：iphoneX及以上底部安全区适配"></a>11. ios：iphoneX及以上底部安全区适配</h1><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 1. html添加meta标签：viewport-fit=cover 重要</span><span class="token operator">&lt;</span>meta content<span class="token operator">=</span><span class="token string">"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0,viewport-fit=cover"</span> name<span class="token operator">=</span><span class="token string">"viewport"</span><span class="token operator">/</span><span class="token operator">></span><span class="token comment" spellcheck="true">// 2. 最外层容器样式</span><span class="token comment" spellcheck="true">// 适配不同屏幕</span>@media <span class="token punctuation">(</span><span class="token operator">-</span>webkit<span class="token operator">-</span>min<span class="token operator">-</span>device<span class="token operator">-</span>pixel<span class="token operator">-</span>ratio<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>#container <span class="token punctuation">{</span>      padding<span class="token operator">-</span>bottom<span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token function">constant</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>bottom<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      padding<span class="token operator">-</span>bottom<span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token function">env</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>bottom<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>@media <span class="token punctuation">(</span><span class="token operator">-</span>webkit<span class="token operator">-</span>min<span class="token operator">-</span>device<span class="token operator">-</span>pixel<span class="token operator">-</span>ratio<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>#container <span class="token punctuation">{</span>      padding<span class="token operator">-</span>bottom<span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token function">constant</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>bottom<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      padding<span class="token operator">-</span>bottom<span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token function">env</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>bottom<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 3.部分页面position：fixed底部对齐会有影响，需设置该元素：</span>@supports <span class="token punctuation">(</span>bottom<span class="token punctuation">:</span> <span class="token function">env</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>bottom<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    #store<span class="token operator">-</span>cart<span class="token operator">-</span>fiexd <span class="token punctuation">.</span>cart<span class="token operator">-</span>bar <span class="token punctuation">{</span>         padding<span class="token operator">-</span>bottom<span class="token punctuation">:</span> <span class="token function">constant</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>        padding<span class="token operator">-</span>bottom<span class="token punctuation">:</span> <span class="token function">env</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="12-安卓-ios-通用-时间转时间戳"><a href="#12-安卓-ios-通用-时间转时间戳" class="headerlink" title="12. 安卓 ios (通用)时间转时间戳"></a>12. 安卓 ios (通用)时间转时间戳</h1><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 格式化时间成时间戳 * @param {*} data - 2021-01-14 => 1610613229 */</span><span class="token keyword">const</span> changeTimeMS<span class="token operator">=</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">let</span> splitTime<span class="token operator">=</span>data<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token regex">/[- : \/]/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> time <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>splitTime<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> splitTime<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> splitTime<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">+</span>time<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考地址:<a href="https://blog.csdn.net/sinat_24946363/article/details/105181622?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control" target="_blank" rel="noopener">iPhone安全区域</a></p><h1 id="持续更新……"><a href="#持续更新……" class="headerlink" title="持续更新……"></a>持续更新……</h1>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>highCharts图表使用总结</title>
      <link href="/2021/09/17/highcharts-tu-biao-shi-yong-zong-jie/"/>
      <url>/2021/09/17/highcharts-tu-biao-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="Highcharts-基本组成"><a href="#Highcharts-基本组成" class="headerlink" title="Highcharts 基本组成"></a>Highcharts 基本组成</h1><hr><p><img src="2.jpg" alt></p><p><a href="https://api.highcharts.com.cn/highcharts" target="_blank" rel="noopener">名词解释</a></p><h1 id="1-坐标轴（Axis）"><a href="#1-坐标轴（Axis）" class="headerlink" title="1.坐标轴（Axis）"></a>1.坐标轴（Axis）</h1><ul><li><p>设置</p><pre><code> crosshair: false, // 是否显示十字 opposite: false,  //对面显示 showEmpty: ,//是否显示空轴 showFirstLabel:, //是否显示第一个轴标签 showLastLabel:, //是否显示最后一个轴标签 height: &#39;100%&#39;, lineWidth: 0, // 刻度线宽度 tickAmount:4, // 刻度总数 tickWidth: 0, tickPosition: &#39;inside&#39;,//刻度位置 gridLineWidth: 1, // 网格宽度 gridLineColor: &#39;#E5E5E5&#39;,//网格颜色 labels: {   enabled:是否显示,   style: {     color: &#39;#A1A1A1&#39;,     fontSize: &#39;0.49rem&#39;,   },   align:&quot;right&quot;, // 文字位置   x:60, // x轴偏移   y:-10,// y轴偏移   format:&#39;{value:.,0f}&#39;,   formatter:function(){     return (parseFloat(this.value)).toFixed(1) +&#39;%&#39;;// 格式化保留一位小数   } }</code></pre></li></ul><ul><li><p>函数及属性</p><pre><code>addPlotBand(): 增加标识区addPlotLine(): 新增标示线getExtremes(): 获取极值remove(): 删除removePlotBand(): 删除标识区removePlotLine(): 删除标示线setCategories(): 设置分类setExtremes(): 设置极值 --可定制x轴y轴值 setTitle(): 更新标题toPixels(): 转换成像素值toValue(): 转换成值update(): 更新</code></pre></li></ul><h1 id="2-调整曲线图的粗细、点大小、点形状、空心点"><a href="#2-调整曲线图的粗细、点大小、点形状、空心点" class="headerlink" title="2.调整曲线图的粗细、点大小、点形状、空心点"></a>2.调整曲线图的粗细、点大小、点形状、空心点</h1><ul><li><p>实心圆点</p><pre><code>粗细：lineWidth 默认值为2plotOptions: {  series: {    marker: {        enabled: true, /*数据点是否显示*/        radius: 3, //曲线点半径，默认是4        symbol: &#39;diamond&#39; //曲线点类型：&#39;circle&#39;, &#39;square&#39;, &#39;diamond&#39;, &#39;triangle&#39;,&#39;triangle-down&#39;，默认是&#39;circle&#39;,也可自定义    }  }},</code></pre></li><li><p>空心圆点</p><pre><code>var plotOptions = {      series: {          marker: {              enabled: true, /*数据点是否显示*/              radius: 5,  /*数据点大小px*/                      // 空心数据点             fillColor: &#39;#FFFFFF&#39;,/*数据点颜色*/              lineWidth: 2,              lineColor: null, // 边框颜色 为null 时时当前线颜色                    states:{                hover:{                  enabled:false,                }              }          }          }}</code></pre></li></ul><h1 id="3-多色带折线图"><a href="#3-多色带折线图" class="headerlink" title="3.多色带折线图"></a>3.多色带折线图</h1><pre><code>{      name: &#39;策略评分&#39;,      data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2,          26.5, 23.3, 18.3, 13.9, 9.6],          // 一 negativeColor: 负值颜色          // 二          zones: [{                  value: 10, // 范围                  color: &#39;#f7a35c&#39;, // 颜色                  //dashStyle: &#39;dot&#39; // 线类型              },{                  color: &#39;#90ed7d&#39;              }]    }</code></pre><p>效果图<br><img src="1.jpg" alt></p><h1 id="4-标示区（plotBands）"><a href="#4-标示区（plotBands）" class="headerlink" title="4.标示区（plotBands）"></a>4.标示区（plotBands）</h1><ul><li><p>标示区的基本配置</p><pre><code>xAxis: {    // ... 省略代码    plotBands: [{        from: ,               // 标示区开始值        to: ,                 // 标示区结束值        label: {              // 标示区文字标签配置，详见API         text: 内容,          y:315, // 图表高度          align:&quot;right&quot;, // 位置          style: {            color: &#39;#FFA02C &#39;,            fontSize:&#39;0.45rem&#39;,          }        },        color: &#39;&#39;,            // 标示区背景颜色        borderWidth: ,        // 标示区边框宽度        borderColor: ,        // 标示区边框颜色        id: ,                 // 标示区 id，用于删除等操作        zIndex:,              // 标示区层叠，用于调整显示层次        events: {             // 事件，支持 click、mouseover、mouseout、mousemove等事件            click: function(e) {              // this 获取当前表示区配置            },            mouseover: function(e) {            },            mouseout: function(e) {            },            mousemove: function(e) {            }        }    }]},yAxis: {    // ... 省略代码    plotBands: [{        // 标示区配置，同上    }]}`</code></pre></li><li><p>动态增加或删除标示区</p><pre><code>// 实例化图表并保存图表对象var chart = new Highcharts.Chart();var axis = chart.xAxis[0];axis.addPlotBand({  id: &#39;myXAxisPlotBand&#39;,     // id 用于后续删除用  from: 20,  to: 40,  // ...});// 删除var chart = new Highcharts.Chart();var axis = chart.xAxis[0];axis.removePlotBand(&#39;myXAxisPlotBand&#39;)</code></pre></li></ul><h1 id="5-标示线（plotLines）"><a href="#5-标示线（plotLines）" class="headerlink" title="5.标示线（plotLines）"></a>5.标示线（plotLines）</h1><ul><li><p>在x轴上值为3的地方画一条红色的宽度为2px的线</p><p>xAxis: {</p><pre><code>// ... 省略代码plotLines:[{    color:&#39;red&#39;,            //线的颜色，定义为红色    dashStyle:&#39;longdashdot&#39;,//标示线的样式，默认是solid（实线），这里定义为长虚线    value:3,                //定义在哪个值上显示标示线，这里是在x轴上刻度为3的值处垂直化一条线    width:2                 //标示线的宽度，2px}]</code></pre><p>}</p><h1 id="6-数据提示框（Tooltip）"><a href="#6-数据提示框（Tooltip）" class="headerlink" title="6. 数据提示框（Tooltip）"></a>6. 数据提示框（Tooltip）</h1><p>  tooltip: {</p><pre><code>  backgroundColor: &#39;#FCFFC5&#39;,   // 背景颜色  borderColor: &#39;black&#39;,         // 边框颜色  borderRadius: 10,             // 边框圆角  borderWidth: 3,               // 边框宽度  shadow: ture,                 // 是否显示阴影  animation: true               // 是否启用动画效果  style: {                      // 文字内容相关样式      color: &quot;#ff0000&quot;,      fontSize: &quot;12px&quot;,      fontWeight: &quot;blod&quot;,      fontFamily: &quot;Courir new&quot;  },  formatter:function() { // 格式化函数      return &#39;&lt;span style=&quot;color:{&#39;+this.series.color+&#39;}&quot;&gt;u25CF&lt;/span&gt; {&#39;+            this.series.name+&#39;}: &lt;b&gt;{&#39;+this.y+&#39;}&lt;/b&gt;&lt;br/&gt;.&#39;  }</code></pre><p>  }<br><a href="https://wizardforcel.gitbooks.io/highcharts-tutorial/content/16.html" target="_blank" rel="noopener">详见API</a></p></li></ul><h1 id="7-环图占比"><a href="#7-环图占比" class="headerlink" title="7.环图占比"></a>7.环图占比</h1><pre><code>  series: [{          innerSize: &#39;65%&#39;,  // 占比          data: this.y_data // 数据  }]</code></pre><h1 id="8-待添加"><a href="#8-待添加" class="headerlink" title="8.待添加"></a>8.待添加</h1><h1 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h1><ul><li>highCharts-中文:<a href="https://wizardforcel.gitbooks.io/highcharts-tutorial/content/5.html" target="_blank" rel="noopener">(https://wizardforcel.gitbooks.io/highcharts-tutorial/content/5.html</a></li><li>highCharts-官网:<a href="https://www.highcharts.com.cn/" target="_blank" rel="noopener">https://www.highcharts.com.cn/</a></li><li>highCharts-API:<a href="https://api.highcharts.com.cn/highcharts" target="_blank" rel="noopener">https://api.highcharts.com.cn/highcharts</a></li><li>highCharts-图集:<a href="https://www.highcharts.com.cn/demo/gallery" target="_blank" rel="noopener">https://www.highcharts.com.cn/demo/gallery</a></li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>持续更新中……</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echars中常用方法</title>
      <link href="/2021/07/22/echars-zhong-chang-yong-fang-fa/"/>
      <url>/2021/07/22/echars-zhong-chang-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="Echars中常用方法"><a href="#Echars中常用方法" class="headerlink" title="Echars中常用方法"></a>Echars中常用方法</h1><hr><p><strong>1.什么是Echars?</strong></p><blockquote><p>一个纯JavaScript图表库。<a href="https://www.echartsjs.com/zh/index.html" target="_blank" rel="noopener">ECharts官网</a>，缩写来自Enterprise Charts，商业级数据图表，一个纯Javascript的图表库，可以流畅的运行在PC和移动设备上，兼容当前绝大部分浏览器（IE6/7/8/9/10/11，chrome，firefox，Safari等），底层依赖轻量级的Canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。</p></blockquote><h2 id="1-Echars术语速查手册-gt"><a href="#1-Echars术语速查手册-gt" class="headerlink" title="1. Echars术语速查手册 -&gt;"></a>1. Echars术语速查手册 -&gt;</h2><ul><li><a href="https://www.echartsjs.com/zh/cheat-sheet.html" target="_blank" rel="noopener">Echars术语速查手册</a></li></ul><h2 id="2-echarts属性的设置（完整大全）"><a href="#2-echarts属性的设置（完整大全）" class="headerlink" title="2. echarts属性的设置（完整大全）"></a>2. echarts属性的设置（完整大全）</h2><h3 id="全图默认背景"><a href="#全图默认背景" class="headerlink" title="全图默认背景"></a>全图默认背景</h3><pre><code>  // backgroundColor: ‘rgba(0,0,0,0)’,  // 默认色板  color: [&#39;#ff7f50&#39;,&#39;#87cefa&#39;,&#39;#da70d6&#39;,&#39;#32cd32&#39;,&#39;#6495ed&#39;,      &#39;#ff69b4&#39;,&#39;#ba55d3&#39;,&#39;#cd5c5c&#39;,&#39;#ffa500&#39;,&#39;#40e0d0&#39;,      &#39;#1e90ff&#39;,&#39;#ff6347&#39;,&#39;#7b68ee&#39;,&#39;#00fa9a&#39;,&#39;#ffd700&#39;,      &#39;#6699FF&#39;,&#39;#ff6666&#39;,&#39;#3cb371&#39;,&#39;#b8860b&#39;,&#39;#30e0e0&#39;],</code></pre><h3 id="1-图表标题"><a href="#1-图表标题" class="headerlink" title="1.图表标题"></a>1.图表标题</h3><pre><code>  title: {      x: &#39;left&#39;,                // 水平安放位置，默认为左对齐，可选为：                        // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39;                        // ¦ {number}（x坐标，单位px）      y: &#39;top&#39;,             // 垂直安放位置，默认为全图顶端，可选为：                        // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39;                        // ¦ {number}（y坐标，单位px）      //textAlign: null          // 水平对齐方式，默认根据x设置自动调整      backgroundColor: &#39;rgba(0,0,0,0)&#39;,      borderColor: &#39;#ccc&#39;,          // 标题边框颜色      borderWidth: 0,           // 标题边框线宽，单位px，默认为0（无边框）      padding: 5,             // 标题内边距，单位px，默认各方向内边距为5，                                // 接受数组分别设定上右下左边距，同css      itemGap: 10,             // 主副标题纵向间隔，单位px，默认为10，      textStyle: {          fontSize: 18,          fontWeight: &#39;bolder&#39;,          color: &#39;#333&#39;                             // 主标题文字颜色      },      subtextStyle: {          color: &#39;#aaa&#39;                            // 副标题文字颜色      }  },</code></pre><h3 id="2-图例"><a href="#2-图例" class="headerlink" title="2.图例"></a>2.图例</h3><pre><code>  legend: {      orient: &#39;horizontal&#39;,          // 布局方式，默认为水平布局，可选为：                        // &#39;horizontal&#39; ¦ &#39;vertical&#39;      x: &#39;center&#39;,                // 水平安放位置，默认为全图居中，可选为：                                // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39;                        // ¦ {number}（x坐标，单位px）      y: &#39;top&#39;,              // 垂直安放位置，默认为全图顶端，可选为：                        // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39;                        // ¦ {number}（y坐标，单位px）      backgroundColor: &#39;rgba(0,0,0,0)&#39;,      borderColor: &#39;#ccc&#39;,            // 图例边框颜色      borderWidth: 0,                // 图例边框线宽，单位px，默认为0（无边框）      padding: 5,                  // 图例内边距，单位px，默认各方向内边距为5，                                // 接受数组分别设定上右下左边距，同css      itemGap: 10,              // 各个item之间的间隔，单位px，默认为10，                          // 横向布局时为水平间隔，纵向布局时为纵向间隔      itemWidth: 20,             // 图例图形宽度      itemHeight: 14,            // 图例图形高度      textStyle: {          color: &#39;#333&#39;                              // 图例文字颜色      }  },</code></pre><h3 id="3-值域"><a href="#3-值域" class="headerlink" title="3.值域"></a>3.值域</h3><pre><code>  dataRange: {      orient: &#39;vertical&#39;,             // 布局方式，默认为垂直布局，可选为：                          // &#39;horizontal&#39; ¦ &#39;vertical&#39;      x: &#39;left&#39;,                   // 水平安放位置，默认为全图左对齐，可选为：                          // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39;                          // ¦ {number}（x坐标，单位px）      y: &#39;bottom&#39;,                  // 垂直安放位置，默认为全图底部，可选为：                          // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39;                          // ¦ {number}（y坐标，单位px）      backgroundColor: &#39;rgba(0,0,0,0)&#39;,      borderColor: &#39;#ccc&#39;,             // 值域边框颜色      borderWidth: 0,                 // 值域边框线宽，单位px，默认为0（无边框）      padding: 5,                    // 值域内边距，单位px，默认各方向内边距为5，                          // 接受数组分别设定上右下左边距，同css      itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，                          // 横向布局时为水平间隔，纵向布局时为纵向间隔      itemWidth: 20,             // 值域图形宽度，线性渐变水平布局宽度为该值 * 10      itemHeight: 14,            // 值域图形高度，线性渐变垂直布局高度为该值 * 10      splitNumber: 5,            // 分割段数，默认为5，为0时为线性渐变      color:[&#39;#1e90ff&#39;,&#39;#f0ffff&#39;],//颜色      //text:[&#39;高&#39;,&#39;低&#39;],              // 文本，默认为数值文本      textStyle: {          color: &#39;#333&#39;                                // 值域文字颜色      }  },  toolbox: {      orient: &#39;horizontal&#39;,            // 布局方式，默认为水平布局，可选为：                          // &#39;horizontal&#39; ¦ &#39;vertical&#39;      x: &#39;right&#39;,              // 水平安放位置，默认为全图右对齐，可选为：                          // &#39;center&#39; ¦ &#39;left&#39; ¦ &#39;right&#39;                          // ¦ {number}（x坐标，单位px）      y: &#39;top&#39;,               // 垂直安放位置，默认为全图顶端，可选为：                          // &#39;top&#39; ¦ &#39;bottom&#39; ¦ &#39;center&#39;                          // ¦ {number}（y坐标，单位px）      color : [&#39;#1e90ff&#39;,&#39;#22bb22&#39;,&#39;#4b0082&#39;,&#39;#d2691e&#39;],      backgroundColor: &#39;rgba(0,0,0,0)&#39;,    // 工具箱背景颜色      borderColor: &#39;#ccc&#39;,             // 工具箱边框颜色      borderWidth: 0,                 // 工具箱边框线宽，单位px，默认为0（无边框）      padding: 5,                    // 工具箱内边距，单位px，默认各方向内边距为5，                                  // 接受数组分别设定上右下左边距，同css      itemGap: 10,                  // 各个item之间的间隔，单位px，默认为10，                                  // 横向布局时为水平间隔，纵向布局时为纵向间隔      itemSize: 16,              // 工具箱图形宽度      featureImageIcon : {},            // 自定义图片icon      featureTitle : {          mark : &#39;辅助线开关&#39;,          markUndo : &#39;删除辅助线&#39;,          markClear : &#39;清空辅助线&#39;,          dataZoom : &#39;区域缩放&#39;,          dataZoomReset : &#39;区域缩放后退&#39;,          dataView : &#39;数据视图&#39;,          lineChart : &#39;折线图切换&#39;,          barChart : &#39;柱形图切换&#39;,          restore : &#39;还原&#39;,          saveAsImage : &#39;保存为图片&#39;      }  },</code></pre><h3 id="4-提示框"><a href="#4-提示框" class="headerlink" title="4.提示框"></a>4.提示框</h3><pre><code>  tooltip: {      trigger: &#39;item&#39;,           // 触发类型，默认数据触发，见下图，可选为：&#39;item&#39; ¦ &#39;axis&#39;      showDelay: 20,             // 显示延迟，添加显示延迟可以避免频繁切换，单位ms      hideDelay: 100,            // 隐藏延迟，单位ms      transitionDuration : 0.4,         // 动画变换时间，单位s      backgroundColor: &#39;rgba(0,0,0,0.7)&#39;,  // 提示背景颜色，默认为透明度为0.7的黑色      borderColor: &#39;#333&#39;,            // 提示边框颜色      borderRadius: 4,                // 提示边框圆角，单位px，默认为4      borderWidth: 0,                // 提示边框线宽，单位px，默认为0（无边框）      padding: 5,                   // 提示内边距，单位px，默认各方向内边距为5，                                  // 接受数组分别设定上右下左边距，同css      axisPointer : {                 // 坐标轴指示器，坐标轴触发有效          type : &#39;line&#39;,         // 默认为直线，可选为：&#39;line&#39; | &#39;shadow&#39;          lineStyle : {          // 直线指示器样式设置              color: &#39;#48b&#39;,              width: 2,              type: &#39;solid&#39;          },          shadowStyle : {              // 阴影指示器样式设置              width: &#39;auto&#39;,         // 阴影大小              color: &#39;rgba(150,150,150,0.3)&#39;  // 阴影颜色          }      },      textStyle: {          color: &#39;#fff&#39;      }  },</code></pre><h3 id="5-区域缩放控制器"><a href="#5-区域缩放控制器" class="headerlink" title="5.区域缩放控制器"></a>5.区域缩放控制器</h3><pre><code>  dataZoom: {      orient: &#39;horizontal&#39;,         // 布局方式，默认为水平布局，可选为：                              // &#39;horizontal&#39; ¦ &#39;vertical&#39;      // x: {number},              // 水平安放位置，默认为根据grid参数适配，可选为：                              // {number}（x坐标，单位px）      // y: {number},              // 垂直安放位置，默认为根据grid参数适配，可选为：                              // {number}（y坐标，单位px）      // width: {number},           // 指定宽度，横向布局时默认为根据grid参数适配      // height: {number},          // 指定高度，纵向布局时默认为根据grid参数适配      backgroundColor: &#39;rgba(0,0,0,0)&#39;,    // 背景颜色      dataBackgroundColor: &#39;#eee&#39;,       // 数据背景颜色      fillerColor: &#39;rgba(144,197,237,0.2)&#39;, // 填充颜色      handleColor: &#39;rgba(70,130,180,0.8)&#39;       // 手柄颜色  },</code></pre><h3 id="6-网格"><a href="#6-网格" class="headerlink" title="6.网格"></a>6.网格</h3><pre><code>  grid: {      x: 80,      y: 60,      x2: 80,      y2: 60,      // width: {totalWidth} - x - x2,      // height: {totalHeight} - y - y2,      backgroundColor: &#39;rgba(0,0,0,0)&#39;,      borderWidth: 1,      borderColor: &#39;#ccc&#39;  },</code></pre><h3 id="7-类目轴"><a href="#7-类目轴" class="headerlink" title="7.类目轴"></a>7.类目轴</h3><pre><code>  categoryAxis: {      position: &#39;bottom&#39;,        // 位置      nameLocation: &#39;end&#39;,      // 坐标轴名字位置，支持&#39;start&#39; | &#39;end&#39;      boundaryGap: true,     // 类目起始和结束两端空白策略      axisLine: {            // 坐标轴线          show: true,         // 默认显示，属性show控制显示与否          lineStyle: {        // 属性lineStyle控制线条样式              color: &#39;#48b&#39;,              width: 2,              type: &#39;solid&#39;          }      },      axisTick: {            // 坐标轴小标记          show: true,       // 属性show控制显示与否，默认不显示          interval: &#39;auto&#39;,          // onGap: null,          inside : false,        // 控制小标记是否在grid里          length :5,         // 属性length控制线长          lineStyle: {       // 属性lineStyle控制线条样式              color: &#39;#333&#39;,              width: 1          }      },      axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel          show: true,          interval: &#39;auto&#39;,          rotate: 0,          margin: 8,          // formatter: null,          textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE              color: &#39;#333&#39;          }      },      splitLine: {                // 分隔线          show: true,        // 默认显示，属性show控制显示与否          // onGap: null,          lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式              color: [&#39;#ccc&#39;],              width: 1,              type: &#39;solid&#39;          }      },      splitArea: {                // 分隔区域          show: false,       // 默认不显示，属性show控制显示与否          // onGap: null,          areaStyle: {        // 属性areaStyle（详见areaStyle）控制区域样式              color: [&#39;rgba(250,250,250,0.3)&#39;,&#39;rgba(200,200,200,0.3)&#39;]          }      }  },</code></pre><h3 id="8-数值型坐标轴默认参数"><a href="#8-数值型坐标轴默认参数" class="headerlink" title="8.数值型坐标轴默认参数"></a>8.数值型坐标轴默认参数</h3><pre><code>  valueAxis: {      position: &#39;left&#39;,      // 位置      nameLocation: &#39;end&#39;,     // 坐标轴名字位置，支持&#39;start&#39; | &#39;end&#39;      nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式      boundaryGap: [0, 0],    // 数值起始和结束两端空白策略      splitNumber: 5,        // 分割段数，默认为5      axisLine: {             // 坐标轴线          show: true,      // 默认显示，属性show控制显示与否          lineStyle: {      // 属性lineStyle控制线条样式              color: &#39;#48b&#39;,              width: 2,              type: &#39;solid&#39;          }      },      axisTick: {            // 坐标轴小标记          show: false,       // 属性show控制显示与否，默认不显示          inside : false,      // 控制小标记是否在grid里          length :5,          // 属性length控制线长          lineStyle: {       // 属性lineStyle控制线条样式              color: &#39;#333&#39;,              width: 1          }      },      axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel          show: true,          rotate: 0,          margin: 8,          // formatter: null,          textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE              color: &#39;#333&#39;          }      },      splitLine: {                // 分隔线          show: true,        // 默认显示，属性show控制显示与否          lineStyle: {          // 属性lineStyle（详见lineStyle）控制线条样式              color: [&#39;#ccc&#39;],              width: 1,              type: &#39;solid&#39;          }      },      splitArea: {                // 分隔区域          show: false,       // 默认不显示，属性show控制显示与否          areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式              color: [&#39;rgba(250,250,250,0.3)&#39;,&#39;rgba(200,200,200,0.3)&#39;]          }      }  },  polar : {      center : [&#39;50%&#39;, &#39;50%&#39;],    // 默认全局居中      radius : &#39;75%&#39;,      startAngle : 90,      splitNumber : 5,      name : {          show: true,          textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE              color: &#39;#333&#39;          }      },      axisLine: {            // 坐标轴线          show: true,         // 默认显示，属性show控制显示与否          lineStyle: {        // 属性lineStyle控制线条样式              color: &#39;#ccc&#39;,              width: 1,              type: &#39;solid&#39;          }      },      axisLabel: {                // 坐标轴文本标签，详见axis.axisLabel          show: false,          textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE              color: &#39;#333&#39;          }      },      splitArea : {          show : true,          areaStyle : {              color: [&#39;rgba(250,250,250,0.3)&#39;,&#39;rgba(200,200,200,0.3)&#39;]          }      },      splitLine : {          show : true,          lineStyle : {              width : 1,              color : &#39;#ccc&#39;          }      }  },</code></pre><h3 id="9-柱形图默认参数"><a href="#9-柱形图默认参数" class="headerlink" title="9.柱形图默认参数"></a>9.柱形图默认参数</h3><pre><code>  bar: {      barMinHeight: 0,            // 最小高度改为0      // barWidth: null,        // 默认自适应      barGap: &#39;30%&#39;,           // 柱间距离，默认为柱形宽度的30%，可设固定值      barCategoryGap : &#39;20%&#39;,   // 类目间柱形距离，默认为类目间距的20%，可设固定值      itemStyle: {          normal: {              // color: &#39;各异&#39;,              barBorderColor: &#39;#fff&#39;,         // 柱条边线              barBorderRadius: 0,            // 柱条边线圆角，单位px，默认为0              barBorderWidth: 1,             // 柱条边线线宽，单位px，默认为1              label: {                  show: false                                          // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                                          // &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                                          // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE              }          },          emphasis: {              // color: &#39;各异&#39;,              barBorderColor: &#39;rgba(0,0,0,0)&#39;,            // 柱条边线              barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0              barBorderWidth: 1,                     // 柱条边线线宽，单位px，默认为1              label: {                  show: false                  // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                  //           &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              }          }      }  },</code></pre><h3 id="10-折线图默认参数"><a href="#10-折线图默认参数" class="headerlink" title="10.折线图默认参数"></a>10.折线图默认参数</h3><pre><code>  line: {      itemStyle: {          normal: {              // color: 各异,              label: {                  show: false                  // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                  //           &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              lineStyle: {                  width: 2,                  type: &#39;solid&#39;,                  shadowColor : &#39;rgba(0,0,0,0)&#39;, //默认透明                  shadowBlur: 5,                  shadowOffsetX: 3,                  shadowOffsetY: 3              }          },          emphasis: {              // color: 各异,              label: {                  show: false                  // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                  //           &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              }          }      },      //smooth : false,      //symbol: null,             // 拐点图形类型      symbolSize: 2,          // 拐点图形大小      //symbolRotate : null,       // 拐点图形旋转控制      showAllSymbol: false                   // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）  },</code></pre><h3 id="11-K线图默认参数"><a href="#11-K线图默认参数" class="headerlink" title="11.K线图默认参数"></a>11.K线图默认参数</h3><pre><code>  k: {      // barWidth : null              // 默认自适应      // barMaxWidth : null           // 默认自适应      itemStyle: {          normal: {              color: &#39;#fff&#39;,      // 阳线填充颜色              color0: &#39;#00aa11&#39;,  // 阴线填充颜色              lineStyle: {                  width: 1,                  color: &#39;#ff3200&#39;,    // 阳线边框颜色                  color0: &#39;#00aa11&#39;          // 阴线边框颜色              }          },          emphasis: {              // color: 各异,              // color0: 各异          }      }  },</code></pre><h3 id="12-散点图默认参数"><a href="#12-散点图默认参数" class="headerlink" title="12.散点图默认参数"></a>12.散点图默认参数</h3><pre><code>  scatter: {      //symbol: null,         // 图形类型      symbolSize: 4,       // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2      //symbolRotate : null,   // 图形旋转控制      large: false,        // 大规模散点图      largeThreshold: 2000,   // 大规模阀值，large为true且数据量&gt;largeThreshold才启用大规模模式      itemStyle: {          normal: {              // color: 各异,              label: {                  show: false                  // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                  //           &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              }          },          emphasis: {              // color: &#39;各异&#39;              label: {                  show: false                  // position: 默认自适应，水平布局为&#39;top&#39;，垂直布局为&#39;right&#39;，可选为                  //           &#39;inside&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              }          }      }  },</code></pre><h3 id="13-雷达图默认参数"><a href="#13-雷达图默认参数" class="headerlink" title="13.雷达图默认参数"></a>13.雷达图默认参数</h3><pre><code>  radar : {      itemStyle: {          normal: {              // color: 各异,              label: {                  show: false              },              lineStyle: {                  width: 2,                  type: &#39;solid&#39;              }          },          emphasis: {              // color: 各异,              label: {                  show: false              }          }      },      //symbol: null,          // 拐点图形类型      symbolSize: 2          // 可计算特性参数，空数据拖拽提示图形大小      //symbolRotate : null,    // 图形旋转控制  },</code></pre><h3 id="14-饼图默认参数"><a href="#14-饼图默认参数" class="headerlink" title="14.饼图默认参数"></a>14.饼图默认参数</h3><pre><code>  pie: {      center : [&#39;50%&#39;, &#39;50%&#39;],          // 默认全局居中      radius : [0, &#39;75%&#39;],      clockWise : false,             // 默认逆时针      startAngle: 90,      minAngle: 0,                 // 最小角度改为0      selectedOffset: 10,         // 选中是扇区偏移量      itemStyle: {          normal: {              // color: 各异,              borderColor: &#39;#fff&#39;,              borderWidth: 1,              label: {                  show: true,                  position: &#39;outer&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              labelLine: {                  show: true,                  length: 20,                  lineStyle: {                      // color: 各异,                      width: 1,                      type: &#39;solid&#39;                  }              }          },          emphasis: {              // color: 各异,              borderColor: &#39;rgba(0,0,0,0)&#39;,              borderWidth: 1,              label: {                  show: false                  // position: &#39;outer&#39;                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              labelLine: {                  show: false,                  length: 20,                  lineStyle: {                      // color: 各异,                      width: 1,                      type: &#39;solid&#39;                  }              }          }      }  },  map: {      mapType: &#39;china&#39;,   // 各省的mapType暂时都用中文      mapLocation: {          x : &#39;center&#39;,          y : &#39;center&#39;          // width    // 自适应          // height   // 自适应      },      showLegendSymbol : true,       // 显示图例颜色标识（系列标识的小圆点），存在legend时生效      itemStyle: {          normal: {              // color: 各异,              borderColor: &#39;#fff&#39;,              borderWidth: 1,              areaStyle: {                  color: &#39;#ccc&#39;   //rgba(135,206,250,0.8)              },              label: {                  show: false,                  textStyle: {                      color: &#39;rgba(139,69,19,1)&#39;                  }              }          },          emphasis: {                // 也是选中样式              // color: 各异,              borderColor: &#39;rgba(0,0,0,0)&#39;,              borderWidth: 1,              areaStyle: {                  color: &#39;rgba(255,215,0,0.8)&#39;              },              label: {                  show: false,                  textStyle: {                      color: &#39;rgba(139,69,19,1)&#39;                  }              }          }      }  },  force : {      // 数据map到圆的半径的最小值和最大值      minRadius : 10,      maxRadius : 20,      density : 1.0,      attractiveness : 1.0,      // 初始化的随机大小位置      initSize : 300,      // 向心力因子，越大向心力越大      centripetal : 1,      // 冷却因子      coolDown : 0.99,      // 分类里如果有样式会覆盖节点默认样式      itemStyle: {          normal: {              // color: 各异,              label: {                  show: false                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              nodeStyle : {                  brushType : &#39;both&#39;,                  color : &#39;#f08c2e&#39;,                  strokeColor : &#39;#5182ab&#39;              },              linkStyle : {                  strokeColor : &#39;#5182ab&#39;              }          },          emphasis: {              // color: 各异,              label: {                  show: false                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              nodeStyle : {},              linkStyle : {}          }      }  },  chord : {      radius : [&#39;65%&#39;, &#39;75%&#39;],      center : [&#39;50%&#39;, &#39;50%&#39;],      padding : 2,      sort : &#39;none&#39;,   // can be &#39;none&#39;, &#39;ascending&#39;, &#39;descending&#39;      sortSub : &#39;none&#39;, // can be &#39;none&#39;, &#39;ascending&#39;, &#39;descending&#39;      startAngle : 90,      clockWise : false,      showScale : false,      showScaleText : false,      itemStyle : {          normal : {              label : {                  show : true                  // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE              },              lineStyle : {                  width : 0,                  color : &#39;#000&#39;              },              chordStyle : {                  lineStyle : {                      width : 1,                      color : &#39;#666&#39;                  }              }          },          emphasis : {              lineStyle : {                  width : 0,                  color : &#39;#000&#39;              },              chordStyle : {                  lineStyle : {                      width : 2,                      color : &#39;#333&#39;                  }              }          }      }  },  island: {      r: 15,      calculateStep: 0.1  // 滚轮可计算步长 0.1 = 10%  },  markPoint : {      symbol: &#39;pin&#39;,         // 标注类型      symbolSize: 10,            // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2      //symbolRotate : null, // 标注旋转控制      itemStyle: {          normal: {              // color: 各异，              // borderColor: 各异,     // 标注边线颜色，优先于color              borderWidth: 2,         // 标注边线线宽，单位px，默认为1              label: {                  show: true,                  position: &#39;inside&#39;    // 可选为&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE              }          },          emphasis: {              // color: 各异              label: {                  show: true                  // position: &#39;inside&#39;    // &#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE              }          }      }  },  markLine : {      // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string      symbol: [&#39;circle&#39;, &#39;arrow&#39;],       // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2      symbolSize: [2, 4],      // 标线起始和结束的symbol旋转控制      //symbolRotate : null,      itemStyle: {          normal: {              // color: 各异,           // 标线主色，线色，symbol主色              // borderColor: 随color,       // 标线symbol边框颜色，优先于color              borderWidth: 2,          // 标线symbol边框线宽，单位px，默认为2              label: {                  show: false,                  // 可选为 &#39;start&#39;|&#39;end&#39;|&#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  position: &#39;inside&#39;,                   textStyle: {         // 默认使用全局文本样式，详见TEXTSTYLE                      color: &#39;#333&#39;                  }              },              lineStyle: {                  // color: 随borderColor,    // 主色，线色，优先级高于borderColor和color                  // width: 随borderWidth,    // 优先于borderWidth                  type: &#39;solid&#39;,                  shadowColor : &#39;rgba(0,0,0,0)&#39;, //默认透明                  shadowBlur: 5,                  shadowOffsetX: 3,                  shadowOffsetY: 3              }          },          emphasis: {              // color: 各异              label: {                  show: false                  // position: &#39;inside&#39;   // &#39;left&#39;|&#39;right&#39;|&#39;top&#39;|&#39;bottom&#39;                  // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE              },              lineStyle : {}          }      }  },  textStyle: {      decoration: &#39;none&#39;,      fontFamily: &#39;Arial, Verdana, sans-serif&#39;,      fontFamily2: &#39;微软雅黑&#39;,    // IE8- 字体模糊并且不支持不同字体混排，额外指定一份      fontSize: 12,      fontStyle: &#39;normal&#39;,      fontWeight: &#39;normal&#39;  },</code></pre><h3 id="15-默认标志图形类型列表"><a href="#15-默认标志图形类型列表" class="headerlink" title="15.默认标志图形类型列表"></a>15.默认标志图形类型列表</h3><pre><code>  symbolList : [    &#39;circle&#39;, &#39;rectangle&#39;, &#39;triangle&#39;, &#39;diamond&#39;,    &#39;emptyCircle&#39;, &#39;emptyRectangle&#39;, &#39;emptyTriangle&#39;, &#39;emptyDiamond&#39;  ],  loadingText : &#39;Loading...&#39;,</code></pre><h3 id="16-可计算特性配置，孤岛，提示颜色"><a href="#16-可计算特性配置，孤岛，提示颜色" class="headerlink" title="16.可计算特性配置，孤岛，提示颜色"></a>16.可计算特性配置，孤岛，提示颜色</h3><pre><code>  calculable: false,                       // 默认关闭可计算特性  calculableColor: &#39;rgba(255,165,0,0.6)&#39;,       // 拖拽提示边框颜色  calculableHolderColor: &#39;#ccc&#39;,               // 可计算占位提示颜色  nameConnector: &#39; &amp; &#39;,  valueConnector: &#39; : &#39;,  animation: true,  animationThreshold: 2500,           // 动画元素阀值，产生的图形原素超过2500不出动画  addDataAnimation: true,         // 动态数据接口是否开启动画效果  animationDuration: 2000,  animationEasing: &#39;ExponentialOut&#39;             //BounceOut</code></pre><h2 id="3-Echars官方案例"><a href="#3-Echars官方案例" class="headerlink" title="3. Echars官方案例"></a>3. Echars官方案例</h2><ul><li><a href="https://www.echartsjs.com/examples/zh/index.html" target="_blank" rel="noopener">Echars官方案例</a></li></ul><h2 id="4-Echars社区经典模板"><a href="#4-Echars社区经典模板" class="headerlink" title="4. Echars社区经典模板"></a>4. <a href="https://gallery.echartsjs.com/explore.html" target="_blank" rel="noopener">Echars社区</a>经典模板</h2><ul><li><p><a href="https://gallery.echartsjs.com/editor.html?c=xmCAi_XNuJ" target="_blank" rel="noopener">自定义tooltip，实时获取最新geojson数据</a><br><img src="2.jpg" alt></p></li><li><p><a href="https://gallery.echartsjs.com/editor.html?c=xPkPpAWqSt" target="_blank" rel="noopener">中国地图自定义轮播</a><br><img src="1.jpg" alt></p></li><li><p>……</p></li></ul><!-- ## 5.Echars在Vue项目中的使用 -->]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目配置proxy代理</title>
      <link href="/2021/06/30/xiang-mu-pei-zhi-proxy-dai-li/"/>
      <url>/2021/06/30/xiang-mu-pei-zhi-proxy-dai-li/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1856318957&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><blockquote><p><strong>什么是proxy</strong><br>proxy，默认为NULL，类型为URL，一个为了发送http请求的代理。</p></blockquote><h2 id="1-安装-cross-env"><a href="#1-安装-cross-env" class="headerlink" title="1. 安装  cross-env"></a>1. 安装  cross-env</h2><pre class="line-numbers language-js"><code class="language-js">yarn add  cross<span class="token operator">-</span>env <span class="token operator">-</span>D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-新建proxy网络配置文件"><a href="#2-新建proxy网络配置文件" class="headerlink" title="2. 新建proxy网络配置文件"></a>2. 新建proxy网络配置文件</h2><p>代码如下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token string">'use strict'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// dev环境</span><span class="token keyword">const</span> devTarget <span class="token operator">=</span> <span class="token string">'http://xx.com.cn'</span><span class="token comment" spellcheck="true">// sit环境</span><span class="token keyword">const</span> sitTarget <span class="token operator">=</span> <span class="token string">'https://xxx.com.cn'</span><span class="token comment" spellcheck="true">// 对应环境的target</span><span class="token keyword">let</span> isDev <span class="token operator">=</span> <span class="token boolean">false</span><span class="token comment" spellcheck="true">// APP_ENV-区分环境的node变量</span><span class="token keyword">if</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>APP_ENV <span class="token operator">===</span> <span class="token string">"dev"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    isDev <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// http proxy的数组</span><span class="token keyword">let</span> proxyPath <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'/xxx/'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 需要代理的api路径,支持多路径</span><span class="token keyword">let</span> proxyParam <span class="token operator">=</span> <span class="token punctuation">{</span>    context<span class="token punctuation">:</span> proxyPath<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 多个路径代理到同一个target下</span>    target<span class="token punctuation">:</span> isDev <span class="token operator">?</span> devTarget <span class="token punctuation">:</span> sitTarget<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 接口的域名</span>    changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 如果接口跨域，需要进行这个参数配置</span>    secure<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token comment" spellcheck="true">// 如果是https接口，需要配置这个参数</span><span class="token punctuation">}</span><span class="token punctuation">;</span>exports<span class="token punctuation">.</span>proxyParam <span class="token operator">=</span> proxyParam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-配置-config-index-js"><a href="#3-配置-config-index-js" class="headerlink" title="3. 配置(config/index.js)"></a>3. 配置(config/index.js)</h2><ul><li>引入<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 代理模式配置</span><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./proxy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>使用</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// H5 端使用 devServer 实现跨域，</span><span class="token comment" spellcheck="true">// 需要修改 package.json 的运行命令，加入环境变量 CLIENT_ENV</span><span class="token comment" spellcheck="true">// process.env-node变量</span><span class="token keyword">const</span> isH5 <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>CLIENT_ENV <span class="token operator">===</span> <span class="token string">'h5'</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token operator">...</span><span class="token comment" spellcheck="true">// 其他内容</span>  h5<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>      proxy<span class="token punctuation">:</span> isH5 <span class="token operator">?</span> <span class="token punctuation">[</span>proxy<span class="token punctuation">.</span>proxyParam<span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-配置-package-json"><a href="#4-配置-package-json" class="headerlink" title="4. 配置 package.json"></a>4. 配置 package.json</h2><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// CLIENT_ENV-区分端 APP_ENV-区分环境</span><span class="token string">"dev:h5"</span><span class="token punctuation">:</span> <span class="token string">"cross-env CLIENT_ENV=h5 APP_ENV=dev  -- --watch"</span><span class="token punctuation">,</span><span class="token string">"dev:rn"</span><span class="token punctuation">:</span> <span class="token string">"cross-env CLIENT_ENV=rn APP_ENV=dev  -- --watch"</span><span class="token punctuation">,</span><span class="token string">"sit:h5"</span><span class="token punctuation">:</span> <span class="token string">"cross-env CLIENT_ENV=h5 APP_ENV=sit  -- --watch"</span><span class="token punctuation">,</span><span class="token string">"sit:rn"</span><span class="token punctuation">:</span> <span class="token string">"cross-env CLIENT_ENV=rn APP_ENV=sit  -- --watch"</span><span class="token punctuation">,</span><span class="token string">"build:h5"</span><span class="token punctuation">:</span> <span class="token string">"cross-env CLIENT_ENV=h5 taro build --type h5"</span><span class="token punctuation">,</span><span class="token string">"build:rn"</span><span class="token punctuation">:</span> <span class="token string">"cross-env CLIENT_ENV=rn taro build --type rn"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序和H5页面之间互相跳转</title>
      <link href="/2021/05/13/xiao-cheng-xu-he-h5-ye-mian-zhi-jian-hu-xiang-tiao-zhuan/"/>
      <url>/2021/05/13/xiao-cheng-xu-he-h5-ye-mian-zhi-jian-hu-xiang-tiao-zhuan/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1843365040&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><h1 id="1-小程序跳转H5"><a href="#1-小程序跳转H5" class="headerlink" title="1. 小程序跳转H5"></a>1. 小程序跳转H5</h1><blockquote><p>由于小程序官方没有提供外部H5网页直接跳转到小程序的api，所以目前只支持小程序内嵌H5，并且只有内嵌的H5才能跳回小程序</p></blockquote><ul><li><p>小程序自带的web-view,<a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" target="_blank" rel="noopener">官方文档</a></p></li><li><p>web-view是承载网页的容器。会自动铺满整个小程序页面，个人类型的小程序暂不支持使用。写法如下：</p></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"pages"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>web<span class="token operator">-</span>view src<span class="token operator">=</span><span class="token string">"https://xxx.com/test.html"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>web<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注：当在微信开发中工具里返回“{“base_resp”:{“ret”:-1}}”时，需要点左上角“设置”–“项目设置”–勾选“不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书”</p></blockquote><p><img src="test.png" alt></p><h1 id="2-H5跳转小程序"><a href="#2-H5跳转小程序" class="headerlink" title="2. H5跳转小程序"></a>2. H5跳转小程序</h1><blockquote><p>外部h5无法跳转到小程序，因此需要把h5内嵌到小程序的web-view中。</p></blockquote><h2 id="2-1首页小程序内嵌h5网页-内嵌这一步就相当于上面的小程序跳转h5："><a href="#2-1首页小程序内嵌h5网页-内嵌这一步就相当于上面的小程序跳转h5：" class="headerlink" title="2.1首页小程序内嵌h5网页,内嵌这一步就相当于上面的小程序跳转h5："></a>2.1首页小程序内嵌h5网页,内嵌这一步就相当于上面的小程序跳转h5：</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"pages"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>web<span class="token operator">-</span>view src<span class="token operator">=</span><span class="token string">"https://xxx.com/test.html"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>web<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-2-1在内嵌的网页里引入js，调用wx-miniProgram-navigateTo跳转小程序方法"><a href="#2-2-1在内嵌的网页里引入js，调用wx-miniProgram-navigateTo跳转小程序方法" class="headerlink" title="2.2.1在内嵌的网页里引入js，调用wx.miniProgram.navigateTo跳转小程序方法"></a>2.2.1在内嵌的网页里引入js，调用wx.miniProgram.navigateTo跳转小程序方法</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>    <span class="token operator">&lt;</span>head<span class="token operator">></span>        <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>title<span class="token operator">></span>h5跳转小程序<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>        <span class="token operator">&lt;</span>h3 align<span class="token operator">=</span><span class="token string">"center"</span><span class="token operator">></span>正在跳转到小程序<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span>        <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"https://res.wx.qq.com/open/js/jweixin-1.3.2.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>        <span class="token operator">&lt;</span>script<span class="token operator">></span>                wx<span class="token punctuation">.</span>miniProgram<span class="token punctuation">.</span><span class="token function">navigateTo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>url<span class="token punctuation">:</span> <span class="token string">'/index/index'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-2在内嵌的网页里引入navigationTo-js，调用跳转小程序方法-支持多端"><a href="#2-2-2在内嵌的网页里引入navigationTo-js，调用跳转小程序方法-支持多端" class="headerlink" title="2.2.2在内嵌的网页里引入navigationTo.js，调用跳转小程序方法(支持多端)"></a>2.2.2在内嵌的网页里引入navigationTo.js，调用跳转小程序方法(支持多端)</h2><p><a href="https://github.com/Lingtian007/navigationTo" target="_blank" rel="noopener">navigationTo.js源码地址</a></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>    <span class="token operator">&lt;</span>head<span class="token operator">></span>        <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>title<span class="token operator">></span>h5跳转小程序<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>        <span class="token operator">&lt;</span>h3 align<span class="token operator">=</span><span class="token string">"center"</span><span class="token operator">></span>正在跳转到小程序<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span>        <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"https://raw.githubusercontent.com/Lingtian007/navigationTo/main/navigationTo.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>        <span class="token operator">&lt;</span>script<span class="token operator">></span>               actions<span class="token punctuation">.</span><span class="token function">navigateTo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                  url<span class="token punctuation">:</span> <span class="token string">'../index/index'</span><span class="token punctuation">,</span>                  success<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"navigateTo success!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span><span class="token punctuation">,</span>                  fail<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"navigateTo fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span><span class="token punctuation">,</span>                  complete<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"navigateTo complete!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-源码地址"><a href="#3-源码地址" class="headerlink" title="3. 源码地址"></a>3. 源码地址</h1><p><a href="https://github.com/Lingtian007/xiaochengxu_demo" target="_blank" rel="noopener">仓库地址</a><br><img src="demo.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端项目优化方案</title>
      <link href="/2021/02/24/qian-duan-xiang-mu-you-hua-fang-an/"/>
      <url>/2021/02/24/qian-duan-xiang-mu-you-hua-fang-an/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="前端项目优化"><a href="#前端项目优化" class="headerlink" title="前端项目优化"></a>前端项目优化</h1><h2 id="常见优化方法"><a href="#常见优化方法" class="headerlink" title="常见优化方法"></a>常见优化方法</h2><p>从资源请求数量+代码执行效率两个角度来考虑</p><h2 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h2><ul><li>1.样式表放在头部，防止白屏和闪屏</li><li>2.JS脚本放在底部或异步获取，防止阻塞资源加载</li><li>3.使用语义化标签，优化精简DOM结构</li><li>4.减少DOM操作频率</li><li>5.减少重绘与回流</li></ul><h2 id="JS脚本"><a href="#JS脚本" class="headerlink" title="JS脚本"></a>JS脚本</h2><ul><li>优化脚本结构，移除重复的脚本</li><li>模块就近加载（CMD）</li><li>按需加载加载组件和路由</li><li>图片懒加载，列表分页</li><li>使用节流与防抖减少事件触发频率</li><li>尽量使用CSS动画代替js动画，开启硬件加速</li></ul><h2 id="资源打包上线"><a href="#资源打包上线" class="headerlink" title="资源打包上线"></a>资源打包上线</h2><ul><li>1.使用打包构建工具（webpack）清除注释，压缩页面资源，js、css、html、图片、字体等等</li><li>混淆js代码</li><li>分离非业务逻辑相关vendor依赖，使用长缓存缓存和CDN分发网络</li></ul><h2 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h2><ul><li>1.减少Http请求，合并页面资源，js，css单一入口。js特殊可以分为两个文件，一个业务逻辑，一个非业务逻辑</li><li>2.把小图标合成雪碧图，不太适用经常更新的移动端开发</li><li>3.把小的图片，字体等资源base64化</li><li>4.开启GZip压缩，减少资源传输大小</li><li>5.使用强缓存和协商缓存，减少资源重复请求</li></ul><h2 id="Vue中可以优化的点"><a href="#Vue中可以优化的点" class="headerlink" title="Vue中可以优化的点"></a>Vue中可以优化的点</h2><ul><li>1.Vue库dist里面的Runtime-only比Runtime+Compiler小30%</li><li>2.Vue的计算属性会根据依赖的data进行缓存</li><li>3.keep-alive可以缓存常用组件</li><li>4.Vuex中的getter也会根据依赖的state进行缓存</li><li>5.v-for中唯一key的使用</li><li>6.Vue全局错误处理errorHandle</li><li>7.Vue路由懒加载</li><li>8.Vue组件动态加载</li></ul><h2 id="React中可以优化的点"><a href="#React中可以优化的点" class="headerlink" title="React中可以优化的点"></a>React中可以优化的点</h2><ul><li>1.在constructor改变this指向代替箭头函数和render内绑定this，避免函数作为props带来不必要的rerender</li><li>2.shouldComponentUpdate，减少不不必要的rerender</li><li>3.PureComponent高性能组件只响应引用数据的深拷贝</li><li>4.使用唯一key优化list diff</li><li>5.合并setState操作，减少虚拟dom对比频率</li><li>6.React路由动态加载react-loadable</li></ul>]]></content>
      
      
      <categories>
          
          <category> 方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文了解JS执行顺序</title>
      <link href="/2021/02/23/yi-wen-liao-jie-js-zhi-xing-shun-xu/"/>
      <url>/2021/02/23/yi-wen-liao-jie-js-zhi-xing-shun-xu/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><h1 id="1-问题的引出"><a href="#1-问题的引出" class="headerlink" title="1. 问题的引出"></a>1. 问题的引出</h1><p>event loop都不陌生，是指主线程从“任务队列”中循环读取任务，比如</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 例1</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输出2,1 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在上述的例子中，我们明白首先执行主线程中的同步任务，当主线程任务执行完毕后，再从event loop中读取任务，因此先输出2，再输出1。</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 例2</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出为  1  2 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>先输出1，没有问题，因为是同步任务在主线程中优先执行，这里的问题是setTimeout和Promise.then任务的执行优先级是如何定义的。</p></blockquote><h1 id="2-Job-queue中的执行顺序"><a href="#2-Job-queue中的执行顺序" class="headerlink" title="2 . Job queue中的执行顺序"></a>2 . Job queue中的执行顺序</h1><p>macro-task队列真实包含任务：<br>script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering</p><p>micro-task队列真实包含任务： process.nextTick, Promises, Object.observe, MutationObserver<br>由此我们得到的执行顺序应该为：<br>script(主程序代码)—&gt;process.nextTick—&gt;Promises…——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I/O——&gt;UI rendering</p><h1 id="3-真实环境中执行顺序的举例"><a href="#3-真实环境中执行顺序的举例" class="headerlink" title="3 . 真实环境中执行顺序的举例"></a>3 . 真实环境中执行顺序的举例</h1><ul><li>process.nextTick和promise、setTimeout</li></ul><pre class="line-numbers language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// 例子3：</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出2,6,5,3,4,1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>首先分析Job queue的执行顺序：<br>script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout</p></blockquote><ul><li>更复杂的例子</li></ul><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// 例4 </span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出的是  2 6 5 1 3 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>区别在于promise的构造中，没有同步的resolve，因此promise.then在当前的执行队列中是不存在的，只有promise从pending转移到resolve，才会有then方法，而这个resolve是在一个setTimout时间中完成的，因此3,4最后输出。</p></blockquote><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p> [微任务]包括：Promise ,    process.nextTick() *node.js里面的<br> [宏任务]包括：整体代码script,  setTimeout    setInterval</p><blockquote><p>先输出同步，然后把异步的放到异步队列。然后先执行异步队列的微任务，再执行里面的宏任务</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React复习笔记</title>
      <link href="/2021/01/22/react-fu-xi-bi-ji/"/>
      <url>/2021/01/22/react-fu-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>你真的了解React吗？</p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ol><li>区分Real DOM和Virtual DOM</li></ol><table><thead><tr><th>Real DOM</th><th align="right">Virtual DOM</th></tr></thead><tbody><tr><td>1. 更新缓慢。</td><td align="right">1. 更新更快。</td></tr><tr><td>2. 可以直接更新 HTML。</td><td align="right">2. 无法直接更新 HTML。</td></tr><tr><td>3. 如果元素更新，则创建新DOM。</td><td align="right">3. 如果元素更新，则更新 JSX。</td></tr><tr><td>4. DOM操作代价很高。</td><td align="right">4. DOM 操作非常简单。</td></tr><tr><td>5. 消耗的内存较多。</td><td align="right">5. 很少的内存消耗。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常用方法</title>
      <link href="/2021/01/22/js-chang-yong-fang-fa/"/>
      <url>/2021/01/22/js-chang-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>你真的了解JS的那些方法吗？</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS组件系列-图表组件</title>
      <link href="/2021/01/18/js-zu-jian-xi-lie-shi-yong-dan-li-mo-shi-shi-xian-tu-biao-zu-jian/"/>
      <url>/2021/01/18/js-zu-jian-xi-lie-shi-yong-dan-li-mo-shi-shi-xian-tu-biao-zu-jian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1460682463&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><hr><p>在写项目的时候，我们经常会用一些组件，比如：模态框、图表、分页等。组件的应用大大减少了项目的开发成本，同时也提高了代码的质量等。所以，封装组件成为了每个人的必须拥有的技能。本篇文章将使用<code>单例模式</code>封装一个<code>图表组件</code>。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul><li>什么是单例模式:<br>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</li><li>特点 : 　<br>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 图表组件 * @param params * {     id，绘图的id,     text:文字信息,     legend_color:图例颜色,     data:x轴数据 [] [2020-01-18],     y_data，y轴数据[]  ['xxx','xxx','#F06A6B'],     tooltip_callback:回调函数 * } */</span> <span class="token comment" spellcheck="true">// 引入echarts</span><span class="token keyword">var</span> echarts <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'src/vendors/echartsjs/echarts'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">PieCharts</span><span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>chart<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">_init</span><span class="token punctuation">(</span>params<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> params<span class="token punctuation">.</span>id<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>y_data <span class="token operator">=</span> params<span class="token punctuation">.</span>y_data<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> params<span class="token punctuation">.</span>text<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>tooltip_callback <span class="token operator">=</span> params<span class="token punctuation">.</span>tooltip_callback<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>legend_color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据颜色</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据</span>      params<span class="token punctuation">.</span>y_data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span><span class="token keyword">this</span><span class="token punctuation">.</span>legend_color<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      params<span class="token punctuation">.</span>y_data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span>item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'value'</span><span class="token punctuation">:</span>item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    *获取当前选中tooltips 下标    * @param params  index 下标    */</span>    <span class="token function">_getNow</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span>        self<span class="token punctuation">.</span>chart<span class="token punctuation">.</span><span class="token function">dispatchAction</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            type<span class="token punctuation">:</span> <span class="token string">'highlight'</span><span class="token punctuation">,</span>            seriesIndex<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>            dataIndex<span class="token punctuation">:</span> index        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            self<span class="token punctuation">.</span>chart<span class="token punctuation">.</span><span class="token function">dispatchAction</span><span class="token punctuation">(</span><span class="token punctuation">{</span>               type<span class="token punctuation">:</span> <span class="token string">'downplay'</span><span class="token punctuation">,</span>               seriesIndex<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>               dataIndex<span class="token punctuation">:</span> i           <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * 创建图表模板    */</span>    <span class="token function">_createConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span>      <span class="token comment" spellcheck="true">// 基于准备好的dom，初始化echarts实例</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>chart <span class="token operator">=</span> echarts<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 指定图表的配置项和数据</span>      <span class="token keyword">let</span> option <span class="token operator">=</span> <span class="token punctuation">{</span>               title<span class="token punctuation">:</span> <span class="token punctuation">{</span>                     text<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">,</span>                     subtext<span class="token punctuation">:</span><span class="token string">"总计(亿)"</span><span class="token punctuation">,</span>                     <span class="token comment" spellcheck="true">// x: 'center',</span>                     <span class="token comment" spellcheck="true">// y: 'center',</span>                     top<span class="token punctuation">:</span> <span class="token string">'40%'</span><span class="token punctuation">,</span>                     textAlign<span class="token punctuation">:</span> <span class="token string">"center"</span><span class="token punctuation">,</span>                     left<span class="token punctuation">:</span> <span class="token string">"48%"</span><span class="token punctuation">,</span>                     textStyle<span class="token punctuation">:</span> <span class="token punctuation">{</span>                        fontSize<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">,</span>                        fontFamily<span class="token punctuation">:</span> <span class="token string">'DINPro-Medium, Helvetica Neue'</span>                     <span class="token punctuation">}</span><span class="token punctuation">,</span>                     subtextStyle<span class="token punctuation">:</span><span class="token punctuation">{</span>                        fontSize<span class="token punctuation">:</span> <span class="token number">14</span><span class="token punctuation">,</span>                        color<span class="token punctuation">:</span><span class="token string">'#444444'</span><span class="token punctuation">,</span>                        fontFamily<span class="token punctuation">:</span> <span class="token string">'DINPro-Medium, Helvetica Neue'</span>                        <span class="token comment" spellcheck="true">// lineHeight:10</span>                     <span class="token punctuation">}</span>               <span class="token punctuation">}</span><span class="token punctuation">,</span>               tooltip<span class="token punctuation">:</span> <span class="token punctuation">{</span>                     trigger<span class="token punctuation">:</span> <span class="token string">'item'</span><span class="token punctuation">,</span>                     formatter<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">{</span>                          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'===当前 params==='</span><span class="token punctuation">,</span>params <span class="token punctuation">)</span><span class="token punctuation">;</span>                         self<span class="token punctuation">.</span>dataIndex <span class="token operator">=</span> params<span class="token punctuation">.</span>dataIndex                          <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>                             value<span class="token punctuation">:</span>params<span class="token punctuation">.</span>value<span class="token punctuation">,</span>                             name<span class="token punctuation">:</span>params<span class="token punctuation">.</span>name<span class="token punctuation">,</span>                             index<span class="token punctuation">:</span>params<span class="token punctuation">.</span>dataIndex<span class="token punctuation">,</span>                          <span class="token punctuation">}</span>                          self<span class="token punctuation">.</span><span class="token function">_getNow</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span>dataIndex<span class="token punctuation">)</span>                           self<span class="token punctuation">.</span><span class="token function">tooltip_callback</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>                     <span class="token punctuation">}</span>               <span class="token punctuation">}</span><span class="token punctuation">,</span>               series<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>                     type<span class="token punctuation">:</span> <span class="token string">'pie'</span><span class="token punctuation">,</span>                     center<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'50%'</span><span class="token punctuation">,</span> <span class="token string">'50%'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     radius<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'55%'</span><span class="token punctuation">,</span> <span class="token string">'85%'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token comment" spellcheck="true">// clockwise: true,</span>                     <span class="token comment" spellcheck="true">// avoidLabelOverlap: true,</span>                     avoidLabelOverlap<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                     hoverOffset<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>                     itemStyle<span class="token punctuation">:</span> <span class="token punctuation">{</span>                        normal<span class="token punctuation">:</span> <span class="token punctuation">{</span>                           color<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                 <span class="token keyword">return</span> self<span class="token punctuation">.</span>legend_color<span class="token punctuation">[</span>params<span class="token punctuation">.</span>dataIndex<span class="token punctuation">]</span>                           <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                     <span class="token punctuation">}</span><span class="token punctuation">,</span>                     label<span class="token punctuation">:</span> <span class="token punctuation">{</span>                        show<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                     <span class="token punctuation">}</span><span class="token punctuation">,</span>                     labelLine<span class="token punctuation">:</span> <span class="token punctuation">{</span>                        normal<span class="token punctuation">:</span> <span class="token punctuation">{</span>                           length<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>                           length2<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>                           lineStyle<span class="token punctuation">:</span> <span class="token punctuation">{</span>                                 width<span class="token punctuation">:</span> <span class="token number">0</span>                           <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                     <span class="token punctuation">}</span><span class="token punctuation">,</span>                     data<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span>               <span class="token punctuation">}</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用刚指定的配置项和数据显示图表。</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>chart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    * 渲染图表     */</span>    <span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>      self<span class="token punctuation">.</span><span class="token function">_createConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span>params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PieTitleCharts</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">setHideToolTip_xxx</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                self<span class="token punctuation">.</span>chart<span class="token punctuation">.</span><span class="token function">dispatchAction</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                  type<span class="token punctuation">:</span> <span class="token string">'downplay'</span><span class="token punctuation">,</span>                  seriesIndex<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                  dataIndex<span class="token punctuation">:</span> i              <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 引入</span><span class="token keyword">import</span> xxx_echarts <span class="token keyword">from</span> <span class="token string">'common/plugin/chart/happy/xxx_echarts'</span><span class="token comment" spellcheck="true">// 初始化数据</span><span class="token keyword">const</span> xxx_init <span class="token operator">=</span> _ <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> param <span class="token operator">=</span> <span class="token punctuation">{</span>      id<span class="token punctuation">:</span><span class="token string">"xxx_init"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// id</span>      text<span class="token punctuation">:</span><span class="token string">"123,44"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 文字信息</span>      y_data<span class="token punctuation">:</span><span class="token punctuation">[</span>          <span class="token punctuation">[</span><span class="token string">'证投部'</span><span class="token punctuation">,</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'#ff4433'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token punctuation">[</span><span class="token string">'固收部'</span><span class="token punctuation">,</span>list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'#ff894c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>               <span class="token punctuation">[</span><span class="token string">'金衍部'</span><span class="token punctuation">,</span>list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'#ffc573'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token punctuation">[</span><span class="token string">'资金部'</span><span class="token punctuation">,</span>list<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'#a6cbff'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token punctuation">[</span><span class="token string">'股权部'</span><span class="token punctuation">,</span>list<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'#74a3ff'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token punctuation">[</span><span class="token string">'其他部门'</span><span class="token punctuation">,</span>list<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'#4070ff'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 数据</span>      tooltip_callback<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>_param<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 提示框点击返回数据,</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"提示信息"</span><span class="token punctuation">,</span>_param<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span>  xxx_echarts<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">export</span><span class="token punctuation">{</span>  xxx_init<span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见面试题总结react篇</title>
      <link href="/2021/01/11/chang-jian-mian-shi-ti-zong-jie-react-pian/"/>
      <url>/2021/01/11/chang-jian-mian-shi-ti-zong-jie-react-pian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=525278524&auto=1&height=66"></iframe></div><p>闲来无事，随便写写 ……</p><h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>总结一下面试遇到的问题，为了方便自己查阅，也希望对小伙伴们有所帮助！</p></blockquote><h3 id="一、执行顺序"><a href="#一、执行顺序" class="headerlink" title="一、执行顺序"></a>一、执行顺序</h3><p><img src="sx.jpg" alt></p><h3 id="二、生命周期钩子函数"><a href="#二、生命周期钩子函数" class="headerlink" title="二、生命周期钩子函数"></a>二、生命周期钩子函数</h3><blockquote><p>React 的生命周期从广义上分为三个阶段：挂载、渲染、卸载<br>因此可以把 React 的生命周期分为两类：挂载卸载过程和更新过程</p></blockquote><h4 id="1-1、旧版钩子函数【淘汰】"><a href="#1-1、旧版钩子函数【淘汰】" class="headerlink" title="1.1、旧版钩子函数【淘汰】"></a>1.1、旧版钩子函数【淘汰】</h4><ul><li>16.3 之前的版本生命周期图示：</li></ul><p><img src="old.jpg" alt></p><ul><li>旧版本独有的，17.0 版本已经删除了的钩子函数(17.0 之前的版本仍可以继续使用)：</li><li>componentWillMount，componentWillReceiveProps，componentWillUpdate</li><li>在使用这几个钩子函数时，前面要加 UNSAFE_</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">"react-dom"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子组件</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 初始化数据</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 当组件接收到新的props值会触发，新版已经淘汰</span>  <span class="token function">UNSAFE_componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"componentWillReceiveProps 运行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>子节点：<span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"constructor 运行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> num<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 组件挂载前，新版已经淘汰了</span>  <span class="token function">UNSAFE_componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"componentWillMount 运行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 箭头函数</span>  changeNum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> num<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>num <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 渲染数据</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"render 运行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        根节点        <span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span>        <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* &lt;br>必须加/&lt;br/> */</span><span class="token punctuation">}</span>        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>changeNum<span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">++</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>num<span class="token punctuation">}</span>        <span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span>        子组件：        <span class="token operator">&lt;</span>Child num<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>num<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 组件更新前，新版已经淘汰了</span>  <span class="token function">UNSAFE_componentWillUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"componentWillUpdate 运行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2、新版钩子函数【新增】"><a href="#1-2、新版钩子函数【新增】" class="headerlink" title="1.2、新版钩子函数【新增】"></a>1.2、新版钩子函数【新增】</h4><p><img src="new.png" alt></p><ul><li>增加了：static getDerivedStateFromProps()和 getSnapshotBeforeUpdate()</li><li>用来替代被弃用的旧版本那三个钩子函数</li><li>还增加了：static getDerivedStateFromError()和 componentDidCatch() - 用来处理错误</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">"react-dom"</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"constructor 运行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>      count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 一般用不到：通过props设置获取到 state的值</span>  <span class="token comment" spellcheck="true">// getDerivedStateFromProps前面要加上static保留字，声明为静态方法，不然会被react忽略掉</span>  <span class="token comment" spellcheck="true">// getDerivedStateFromProps里面的this为undefined</span>  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"getDerivedStateFromProps 运行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 一般用不到：滚动的特殊处理，与componentDidUpdate 配对使用的</span>  <span class="token comment" spellcheck="true">/*  在react `render()`后的输出被渲染到DOM之前被调用。       它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。       这个生命周期返回的任何值都将作为参数传递给componentDidUpdate（）*/</span>  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"getSnapshotBeforeUpdate 运行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">11</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"componentDidUpdate 运行了"</span><span class="token punctuation">,</span> snapState<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 本身或后代有报错会触发</span>  <span class="token function">componentDidCatch</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"componentDidCatch 运行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 后代组件抛出错误后会触发</span>  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromError</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"getDerivedStateFromError 运行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 定义事件</span>  changeCount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 渲染数据</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>changeCount<span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">++</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3、常用的钩子函数"><a href="#1-3、常用的钩子函数" class="headerlink" title="1.3、常用的钩子函数"></a>1.3、常用的钩子函数</h4><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//初始化  ，state  ，props，ref，绑定this</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//渲染  ，父组件 执行了渲染，默认子组件的渲染函数也要执行</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>首页<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//是否需要更新  ，不需要 返回 false   ；需要 返回true</span>  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// DOM操作，实例化，数据请求</span>  <span class="token comment" spellcheck="true">//异步处理，有副作用的处理  ；获取数据、执行 setTimeout  setInterval</span>  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"componentDidMount"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//更新时的钩子函数</span>  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"componentDidUpdate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//卸载 回收操作  定时器  解除绑定</span>  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 类似于vue 的beforeDestory</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"componentDidUpdate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、生命周期各阶段"><a href="#三、生命周期各阶段" class="headerlink" title="三、生命周期各阶段"></a>三、生命周期各阶段</h3><blockquote><p>React 中组件也有生命周期，也就是说也有很多钩子函数供我们使用, 组件的生命周期，我们会分为四个阶段，初始化（挂载）、运行中（更新）、销毁（卸载）、错误处理（异常）(16.3 之后)</p></blockquote><blockquote><p>常用的生命周期方法就下面几个，为啥？因为好记，好记才会常用。程序员的本性。<br>其实其他生命周期方法也好用，但是需要特地条件下使用才会觉得方便。所以就不太常用</p></blockquote><ul><li>常用</li></ul><ul><li>constructor()</li><li>render()</li><li>componentDidMount()</li><li>componentDidUpdate()</li><li>componentWillUnmount()</li><li>getDerivedStateFromProps</li></ul><h4 id="2-1、挂载阶段"><a href="#2-1、挂载阶段" class="headerlink" title="2.1、挂载阶段"></a>2.1、挂载阶段</h4><ul><li>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</li></ul><ul><li>constructor</li><li>static getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ul><h4 id="2-2、更新阶段"><a href="#2-2、更新阶段" class="headerlink" title="2.2、更新阶段"></a>2.2、更新阶段</h4><ul><li>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</li></ul><ul><li>static getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ul><h4 id="2-3、卸载阶段"><a href="#2-3、卸载阶段" class="headerlink" title="2.3、卸载阶段"></a>2.3、卸载阶段</h4><ul><li>当组件从 DOM 中移除时会调用如下方法：</li></ul><ul><li>componentWillUnmount【!】</li><li>componentWillUnmount()</li><li>调用：在组件卸载之前</li><li>作用：执行一些清理工作<blockquote><p>例如：<br>清除组件中使用的定时器，<br>取消网络请求或清理在 componentDidMount 中创建的任何监听<br>清除 componentDidMount 中手动创建的 DOM 元素</p></blockquote></li></ul><h4 id="2-4、错误处理"><a href="#2-4、错误处理" class="headerlink" title="2.4、错误处理"></a>2.4、错误处理</h4><ul><li>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</li></ul><ul><li>componentDidCatch</li><li>componentDidCatch(error, info)</li><li>此生命周期在后代组件抛出错误后被调用。</li><li>error —— 抛出的错误。</li><li>info —— 带有 componentStack key 的对象</li><li>componentDidCatch() 会在“提交”阶段被调用，因此允许执行副作用。</li><li>它应该用于记录错误之类的情况</li><li>static getDerivedStateFromError</li><li>static getDerivedStateFromError(error)</li><li>此生命周期会在后代组件抛出错误后被调用</li><li>它将抛出的错误作为参数，并返回一个值以更新 state</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>未完待续,持续更新中……</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在2020的尾声</title>
      <link href="/2020/12/16/xie-zai-2020-de-wei-sheng/"/>
      <url>/2020/12/16/xie-zai-2020-de-wei-sheng/</url>
      
        <content type="html"><![CDATA[<div align="middle"><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1460682463&auto=1&height=66"></iframe> --><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1313052971&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><hr><p><img src="2222.jpg" alt></p><h1 id="诗意的开头"><a href="#诗意的开头" class="headerlink" title="诗意的开头"></a>诗意的开头</h1><blockquote><p>牵着时光的衣襟，无意间迎面的寒风吹过，轻轻地将温暖的阳光拥入怀中，酌一杯清茶,听一曲江南婉韵，伏案静坐，将似水流年浅斟轻酌,风带走花的馨香，一样也可以捎来异地花香的梦影,身在异乡的你,还好吗?<br>脑海里流淌着淡淡的思绪,岁月,依一抹浅香于心间,看年华向晚,闻花香送暖,给时光一个浅浅的回眸,给自己一份微笑从容,情不知所起,一往情深,恨不知所踪,一笑而泯! 你好2021,再见2020~</p></blockquote><h1 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h1><hr><blockquote><p>2020年，我在上海，你在哪呢？细数着日子，沪漂的生活将至三年…</p></blockquote><p>现在所在的公司是5月份刚入职的,也是工作以来最大规模的一家公司,因为当时是疫情刚刚结束,面的不多,拿了几个offer随便挑了一家入职(ps:其实是把拿到offer的都去体验了一遍,毕竟还是需要比较一下)。经历了一段适应期后也慢慢适应了现在的生活节奏,虽然偶尔会有一定加班,但是都不长,并且没有出现像上一家那种上线搞到凌晨才回家的情况了,也算是少了一些“福报”吧，哈哈。</p><h1 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h1><hr><p>现在公司技术栈大部分是React，所以刚入职那段时间算是恶补了React这块的东西。（之前都是用的Vue技术栈）整体上我还算是幸运的吧，刚入职时领导愿意给时间学,这点还是很不错的,前前后后花了一周多,算是可以上手,当然离精通还差的远!</p><p>除了前端的日常开发所需的技术栈，这一年我更多地补了一些node方向（毕竟不是科班出身）和浏览器方面的知识。目前唯都还没学完,继续加油吧，虽然这些对日常开发起不到多大作用，但是对一些知识的理解还是很有帮助的。<br><img src="4.png" alt></p><p>还有想说一点就是，当你看不懂一些知识点的时候，往往是积累还不够或者相关基础知识欠缺。书读百遍其义自见，这个义不仅仅是你读出来的，也是你知识积累出来的。</p><h1 id="关于理财"><a href="#关于理财" class="headerlink" title="关于理财"></a>关于理财</h1><hr><p>因为刚入职的公司就是一家证券公司,日常工作写的业务也是理财基金股票相关的,也算是受环境影响吧,开始慢慢接触基金,刚开始是跟着同事一起,慢慢倒入自己也会有点看法开始尝试自己选基,这里不得不说下,白酒NB。</p><p>我开始理财的目的就很明确，通过分散投资规避风险，尽量跑赢通胀。说白了就是不满足于余额宝的那点收益了，很明显那是怕不赢通胀的。然后这一年里我也看了一些经济学的文章，觉得经济学真的还是蛮有意思的，能够解决很多疑惑。我想，投资这件事我还是会坚持下去的吧，投资理念和经济观念上的学习比赚到的钱更加重要，而且也能锻炼理性思考的能力。</p><h1 id="关于旅游"><a href="#关于旅游" class="headerlink" title="关于旅游"></a>关于旅游</h1><hr><p>年中的时候去了一趟浙江莫干山，在上海这种快节奏的城市待久了，换个地方看看山和水挺不错。</p><p>计划年尾去一趟重庆，期待…</p><h1 id="展望2021"><a href="#展望2021" class="headerlink" title="展望2021"></a>展望2021</h1><hr><p>对于2021就不提太多具体的目标了，毕竟2020年提的那些有很多都还没实现呢。</p><p>总的来说，2021年在工作上希望自己还是两条腿走路吧，技术上更深入而不是仅仅满足于知道API的使用，管理能力上做更多的尝试与探索。</p><p>我们往往喜欢盯着那些能力强的人看，这没问题，但这就像仰望星空，星空再美，最终也只能给我们指引一个大方向，最终自己能走多远还得脚踏实地。所以，2021年想跟自己达成和解的是，别眼高手低，少些想，多些做。</p><p>愿2021能变得更加强大，也能更加快乐，少些仰望星空，多些践踏实地！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端缓存方案</title>
      <link href="/2020/11/13/qian-duan-huan-cun-fang-an/"/>
      <url>/2020/11/13/qian-duan-huan-cun-fang-an/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>前端 api 请求缓存方案</p><h1 id="—-TS版-—"><a href="#—-TS版-—" class="headerlink" title="— TS版 —"></a>— TS版 —</h1><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">/*** 存储数据* */</span><span class="token keyword">class</span> <span class="token class-name">CacheData</span><span class="token operator">&lt;</span>A <span class="token keyword">extends</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span><span class="token keyword">any</span><span class="token operator">></span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>key<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> T <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">get</span><span class="token punctuation">(</span>args<span class="token punctuation">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">set</span><span class="token punctuation">(</span>args<span class="token punctuation">:</span> A<span class="token punctuation">,</span> newData<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> newData<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">remove</span><span class="token punctuation">(</span>args<span class="token punctuation">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*** 缓存方法 的 高阶函数* @param fun 需要缓存的函数* */</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> cache<span class="token operator">&lt;</span>A <span class="token keyword">extends</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span><span class="token keyword">any</span><span class="token operator">></span><span class="token punctuation">,</span> R<span class="token operator">></span><span class="token punctuation">(</span>  fun<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">:</span> A<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Promise<span class="token operator">&lt;</span>R<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> cacheMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CacheData</span><span class="token operator">&lt;</span>A<span class="token punctuation">,</span> R<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">cachedFunction</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> cacheData <span class="token operator">=</span> cacheMap<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheData <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>          <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token punctuation">(</span>cacheData as <span class="token keyword">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span><span class="token keyword">constructor</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"从缓存中读取数据"</span><span class="token punctuation">)</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token string">"参数:"</span> <span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> name<span class="token punctuation">,</span> <span class="token string">"返回值:"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>cacheData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>cacheData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>r <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      cacheMap<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 添加缓存对象</span>  cachedFunction<span class="token punctuation">.</span>cache <span class="token operator">=</span> cacheMap<span class="token punctuation">;</span>  <span class="token keyword">return</span> cachedFunction<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用方法</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">import</span> cache <span class="token keyword">from</span> <span class="token string">"common/util/cache"</span><span class="token keyword">import</span> someService <span class="token keyword">from</span> <span class="token string">"service/xxx"</span><span class="token comment" spellcheck="true">// 返回有缓存的Service 的闭包的函数</span><span class="token keyword">const</span> cachedService <span class="token operator">=</span> <span class="token function">cache</span><span class="token punctuation">(</span>someService<span class="token punctuation">)</span> <span class="token keyword">class</span> <span class="token class-name">YourEffect</span> <span class="token punctuation">{</span>    <span class="token function">someEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">cachedService</span><span class="token punctuation">(</span>serviceParams<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ...</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="—-JS版-—"><a href="#—-JS版-—" class="headerlink" title="— JS版 —"></a>— JS版 —</h1><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">const</span> querys <span class="token operator">=</span><span class="token punctuation">{</span>    wares<span class="token punctuation">:</span> <span class="token string">'getWares'</span><span class="token punctuation">,</span>    skus<span class="token punctuation">:</span> <span class="token string">'getSku'</span><span class="token punctuation">}</span><span class="token keyword">const</span> promiseCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>async <span class="token function">queryAll</span><span class="token punctuation">(</span>queryApiName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断传入的数据是否是数组</span>    <span class="token keyword">const</span> queryIsArray <span class="token operator">=</span> <span class="token keyword">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>queryApiName<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 统一化处理数据，无论是字符串还是数组均视为数组</span>    <span class="token keyword">const</span> apis <span class="token operator">=</span> queryIsArray <span class="token operator">?</span> queryApiName <span class="token punctuation">:</span> <span class="token punctuation">[</span>queryApiName<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 获取所有的 请求服务</span>    <span class="token keyword">const</span> promiseApi <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    apis<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>api <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 利用promise </span>        <span class="token keyword">let</span> promise <span class="token operator">=</span> promiseCache<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>api<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果 缓存中有，直接push</span>            promise<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            promise <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>querys<span class="token punctuation">[</span>api<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 对res 进行操作</span>                <span class="token operator">...</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 在请求回来后，如果出现问题，把promise从cache中删除</span>                promiseCache<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>api<span class="token punctuation">)</span>                <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            promiseCache<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>api<span class="token punctuation">,</span> promise<span class="token punctuation">)</span>            promiseCache<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>promiseApi<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 根据传入的 是字符串还是数组来返回数据，因为本身都是数组操作</span>        <span class="token comment" spellcheck="true">// 如果传入的是字符串，则需要取出操作</span>        <span class="token keyword">return</span> queryIsArray <span class="token operator">?</span> res <span class="token punctuation">:</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>调用方式<span class="token function">queryAll</span><span class="token punctuation">(</span><span class="token string">'wares'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token operator">...</span> <span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 第二次调用 不会去取 wares，只会去skus</span><span class="token function">queryAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'wares'</span><span class="token punctuation">,</span> <span class="token string">'skus'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token operator">...</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用函数</title>
      <link href="/2020/09/22/chang-yong-han-shu/"/>
      <url>/2020/09/22/chang-yong-han-shu/</url>
      
        <content type="html"><![CDATA[<div align="middle"><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe> --><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1405128273&auto=1&height=66"></iframe></div><p>闲来无事，随便写写…… </p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><h1 id="一-、时间类"><a href="#一-、时间类" class="headerlink" title="一 、时间类"></a>一 、时间类</h1><h2 id="1-时间戳格式化"><a href="#1-时间戳格式化" class="headerlink" title="1.时间戳格式化"></a>1.时间戳格式化</h2><pre><code>  /**  * 时间戳格式化  * @param {*} timestamp  timestamp:时间戳   * @param {*} num num:0 YYYY-MM-DD  num:1  YYYY-MM-DD hh:mm:ss  */  _timeConvert(timestamp,num){    var date = new Date(timestamp);    var y = date.getFullYear();      var m = date.getMonth() + 1;      m = m &lt; 10 ? (&#39;0&#39; + m) : m;      var d = date.getDate();      d = d &lt; 10 ? (&#39;0&#39; + d) : d;      var h = date.getHours();    h = h &lt; 10 ? (&#39;0&#39; + h) : h;    var minute = date.getMinutes();    var second = date.getSeconds();    minute = minute &lt; 10 ? (&#39;0&#39; + minute) : minute;      second = second &lt; 10 ? (&#39;0&#39; + second) : second;     if(num==0){        return y + &#39;-&#39; + m + &#39;-&#39; + d;      }else{        return y + &#39;-&#39; + m + &#39;-&#39; + d +&#39; &#39;+ h +&#39;:&#39;+ minute +&#39;:&#39; + second;      }  }</code></pre><h2 id="2-时间格式化"><a href="#2-时间格式化" class="headerlink" title="2.时间格式化"></a>2.时间格式化</h2><pre><code>  /**  * 时间格式化成 YYYY-MM-DD  * @param date 日期  */  assetFormattingDateOther(date: string){    if (!date) return &quot;--&quot;;    return date.replace(/(\d{4})(\d{2})(\d{2})/g, &quot;$1-$2-$3&quot;);  };  /**  * 时间格式化成 MM-DD  * @param date 日期  */  export const assetFormattingDate = (date: string) =&gt; {    if (!date) return &quot;--&quot;;    return date.replace(/(\d{4})(\d{2})(\d{2})/g, &quot;$2-$3&quot;);  };</code></pre><h1 id="二-、数值类"><a href="#二-、数值类" class="headerlink" title="二 、数值类"></a>二 、数值类</h1><h2 id="1-转千分位"><a href="#1-转千分位" class="headerlink" title="1.转千分位"></a>1.转千分位</h2><pre><code>  /**  * 转千分位-保留2位小数  * @param value  */  export const transforThounds = (value: number | string | undefined) =&gt; {    if (!value) return &quot;--&quot;;    let n = parseFloat(value.toString());    if (isNaN(n)) {      return &quot;--&quot;;    } else {      let val = parseFloat(value.toString()).toFixed(2);      let re = /\B(?=(\d{3})+(?!\d))/g;      return val.replace(re, &quot;$1,&quot;);    }  };</code></pre><h2 id="2-号替换"><a href="#2-号替换" class="headerlink" title="2.*号替换"></a>2.*号替换</h2><pre><code>  /**  * *号替换  * @param value  */  export const taransforStart = (value: string) =&gt; {    let val = value;    return val.substr(0, 3) + &quot;****&quot; + val.substr(-2, 2);  };</code></pre><h2 id="3-数值格式化函数"><a href="#3-数值格式化函数" class="headerlink" title="3.数值格式化函数"></a>3.数值格式化函数</h2><pre><code> /**  * 数值格式化函数  * @param Dight:要格式化的 数字;  * @param How::要保留的小数位数。   */  ForDight(Dight,How){  var Dight = Math.round (Dight*Math.pow(10,How))/Math.pow(10,How);   return Dight;   } </code></pre><h2 id="4-取整"><a href="#4-取整" class="headerlink" title="4.取整"></a>4.取整</h2><pre><code>  // 1.只保留整数部分（丢弃小数部分）  parseInt(5.1234);// 5  // 2.向下取整（&lt;= 该数值的最大整数）和parseInt()一样  Math.floor(5.1234);// 5      // 3.向上取整（有小数，整数就+1）  Math.ceil(5.1234);  // 4.四舍五入（小数部分）  Math.round(5.1234);// 5  Math.round(5.6789);// 6  // 5.绝对值  Math.abs(-1);// 1  // 6.返回两者中的较大值  Math.max(1,2);// 2  // 7.返回两者中的较小值  Math.min(1,2);// 1  // 随机数（0-1）  Math.random();</code></pre><h1 id="三-、获取URL"><a href="#三-、获取URL" class="headerlink" title="三 、获取URL"></a>三 、获取URL</h1><h2 id="1-截取完整字符串中的host"><a href="#1-截取完整字符串中的host" class="headerlink" title="1.截取完整字符串中的host"></a>1.截取完整字符串中的host</h2><pre><code>  /**  * 截取完整字符串中的host  * @param {String} url 地址  * @returns {String} host  */  export const GetHost = (url) =&gt; {      url = url.match(/https?:\/\/([^/]+)\//i);      let domain = &#39;&#39;;      if (url &amp;&amp; url[1]) {          domain = url[1];      }      return domain;  };    </code></pre><h2 id="2-截取完整字符串中的子地址"><a href="#2-截取完整字符串中的子地址" class="headerlink" title="2.截取完整字符串中的子地址"></a>2.截取完整字符串中的子地址</h2><pre><code>  /**  * 截取完整字符串中的子地址  * @param {String} url 地址  * @returns {String} 子地址  */  export const GetSubUrl = (url) =&gt; {      url = url.match(/https?:\/\/.*?(\/[^]+)/i);      let domain = &#39;&#39;;      if (url &amp;&amp; url[1]) {          domain = url[1];      }      return domain;  };</code></pre><h2 id="3-获取URL中的参数"><a href="#3-获取URL中的参数" class="headerlink" title="3.获取URL中的参数"></a>3.获取URL中的参数</h2><pre><code>url：  http://xxxx.com?name=魅力&amp;id=123js中:var name = getUrlParam(&quot;name&quot;);/*通过正则获取url中的参数*/function getUrlParam(name){    var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);    var r = window.location.search.substr(1).match(reg);    if(r!=null)return  decodeURI(r[2]); return null;}</code></pre><h2 id="4-去掉url前缀"><a href="#4-去掉url前缀" class="headerlink" title="4.去掉url前缀"></a>4.去掉url前缀</h2><pre><code>function removeUrlPrefix(a){    a=a.replace(/：/g,&quot;:&quot;).replace(/．/g,&quot;.&quot;).replace(/／/g,&quot;/&quot;);    while(trim(a).toLowerCase().indexOf(&quot;http://&quot;)==0){        a=trim(a.replace(/http:\/\//i,&quot;&quot;));    }    return a;}</code></pre><h1 id="四-、字符串"><a href="#四-、字符串" class="headerlink" title="四 、字符串"></a>四 、字符串</h1><h2 id="1-js-判断字符串中是否包含某个字符串"><a href="#1-js-判断字符串中是否包含某个字符串" class="headerlink" title="1. js 判断字符串中是否包含某个字符串"></a>1. js 判断字符串中是否包含某个字符串</h2><ul><li><p>String对象的方法</p><pre><code>方法一: indexOf()   (推荐)var str = &quot;123&quot;;console.log(str.indexOf(&quot;3&quot;) != -1 );  // trueindexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。方法二: search() var str = &quot;123&quot;;console.log(str.search(&quot;3&quot;) != -1 );  // truesearch() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。方法三:match()var str = &quot;123&quot;;var reg = RegExp(/3/);if(str.match(reg)){    // 包含        }match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</code></pre></li><li><p>RegExp 对象方法</p></li></ul><pre><code>  方法四:test()   var str = &quot;123&quot;;  var reg = RegExp(/3/);  console.log(reg.test(str)); // true  test() 方法用于检索字符串中指定的值。返回 true 或 false。  方法五:exec()  var str = &quot;123&quot;;  var reg = RegExp(/3/);  if(reg.exec(str)){      // 包含          }  exec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</code></pre><h2 id="2-JS-快速获取数据中的最大、最小值"><a href="#2-JS-快速获取数据中的最大、最小值" class="headerlink" title="2. JS 快速获取数据中的最大、最小值"></a>2. JS 快速获取数据中的最大、最小值</h2><pre><code>  var  numbers = [5,23 , 1420 , 5215 , 228 , 400 , 105, 411];  var maxInNumbers = Math.max.apply(Math, numbers);  var minInNumbers = Math.min.apply(Math, numbers);</code></pre><h2 id="3-加密"><a href="#3-加密" class="headerlink" title="3. 加密"></a>3. 加密</h2><p>用户名-手机号加密特殊处理: <a href="https://juejin.im/post/6854573208323457032" target="_blank" rel="noopener">地址</a></p><h2 id="4-是否为非空"><a href="#4-是否为非空" class="headerlink" title="4. 是否为非空"></a>4. 是否为非空</h2><pre><code>  /**   *是否为非空  *data 值  */  function isNotEmpty(data){     return data !== &#39;&#39; &amp;&amp; data !== null &amp;&amp; data!== undefined &amp;&amp; data !== JSON.stringify(data) !== &#39;[]&#39; &amp;&amp; data !== JSON.stringify(data) !== &#39;{}&#39;  }    isEmpty(null) // false  isEmpty(1)    //true</code></pre><h2 id="5-字符串长度截取"><a href="#5-字符串长度截取" class="headerlink" title="5. 字符串长度截取"></a>5. 字符串长度截取</h2><pre><code>  function cutstr(str, len) {      var temp,          icount = 0,          patrn = /[^\x00-\xff]/，          strre = &quot;&quot;;      for (var i = 0; i &lt; str.length; i++) {          if (icount &lt; len - 1) {              temp = str.substr(i, 1);                  if (patrn.exec(temp) == null) {                    icount = icount + 1              } else {                  icount = icount + 2              }              strre += temp              } else {              break;          }      }      return strre + &quot;...&quot;  }</code></pre><h2 id="6-替换全部"><a href="#6-替换全部" class="headerlink" title="6. 替换全部"></a>6. 替换全部</h2><pre><code>  String.prototype.replaceAll = function(s1, s2) {      return this.replace(new RegExp(s1, &quot;gm&quot;), s2)  }</code></pre><h2 id="7-清除空格"><a href="#7-清除空格" class="headerlink" title="7. 清除空格"></a>7. 清除空格</h2><pre><code>  // 清除 空格  String.prototype.trim = function() {      var reExtraSpace = /^\s*(.*?)\s+$/;      return this.replace(reExtraSpace, &quot;$1&quot;)  }  // 清除左右空格  function ltrim(s){ return s.replace( /^(\s*|　*)/, &quot;&quot;); }   function rtrim(s){ return s.replace( /(\s*|　*)$/, &quot;&quot;); }</code></pre><h2 id="8-待添加"><a href="#8-待添加" class="headerlink" title="8. 待添加"></a>8. 待添加</h2><h1 id="五-、数组类"><a href="#五-、数组类" class="headerlink" title="五 、数组类"></a>五 、数组类</h1><h2 id="1-数组转对象"><a href="#1-数组转对象" class="headerlink" title="1. 数组转对象"></a>1. 数组转对象</h2><pre><code>  // arr需要转换的数组  Object.assign({},...arr)</code></pre><h2 id="2-数组的拼接"><a href="#2-数组的拼接" class="headerlink" title="2. 数组的拼接"></a>2. 数组的拼接</h2><p>  <a href="https://www.cnblogs.com/codebook/p/10472158.html" target="_blank" rel="noopener">地址</a></p><pre><code>    var arr = [&#39;tom&#39;, &#39;jerry&#39;];    var arr2 = [1, 2];    arr.push(...arr2);    console.log(arr)    // [&quot;tom&quot;, &quot;jerry&quot;, 1, 2]</code></pre><h1 id="六-、杂项"><a href="#六-、杂项" class="headerlink" title="六 、杂项"></a>六 、杂项</h1><h2 id="1-防重"><a href="#1-防重" class="headerlink" title="1.防重"></a>1.防重</h2><pre><code>// 一  var isclick= true;  function click(){      if(isclick){        isclick = false;        //下面添加需要执行的事件          ...      }  }// 二  var isclick= true;  function click(){      if(isclick){          isclick= false;          //下面添加需要执行的事件              ...          //定时器          setTimeout(function(){               isclick = true;          }, 500);      }  }</code></pre><h2 id="2-定位到当前位置"><a href="#2-定位到当前位置" class="headerlink" title="2.定位到当前位置"></a>2.定位到当前位置</h2><pre><code>  /**  * 定位到当前位置  * index 当前时间 下标-(0-13)  */    set_month_position( index) {    let w = document.body.clientWidth / 2; //获取当前屏幕宽度    let tab_a = $(`${&quot;#a_detail&quot; + index}`); // 当前选择元素    let tab_aLeft = tab_a.position().left; //获取当前元素距离父元素左侧的距离    let tab_aWidth = tab_a.offset().width / 2; //获取当前元素的宽度    console.log(      tab_a,      w,      tab_aLeft,      tab_aWidth,      &quot;当前元素/视图宽度/元素距离父元素左侧的距离/元素的宽度&quot;    );    let scroll = (tab_a.parent() as any).scrollLeft();    let now_Width = scroll + (tab_aLeft - w) + tab_aWidth; //获取当全选中元素居中需设置的距离    (tab_a.parent() as any).scrollLeft(now_Width); //为当前元素的父元素设置滚动距离  }</code></pre><h2 id="3-渲染几万条数据不卡住页面"><a href="#3-渲染几万条数据不卡住页面" class="headerlink" title="3.渲染几万条数据不卡住页面"></a>3.渲染几万条数据不卡住页面</h2><pre><code>  // 渲染大数据时，合理使用createDocumentFragment和requestAnimationFrame，将操作切分为一小段一小段执行。  setTimeout(() =&gt; {    // 插入十万条数据    const total = 100000;    // 一次插入的数据    const once = 20;    // 插入数据需要的次数    const loopCount = Math.ceil(total / once);    let countOfRender = 0;    const ul = document.querySelector(&#39;ul&#39;);    // 添加数据的方法    function add() {      const fragment = document.createDocumentFragment();      for(let i = 0; i &lt; once; i++) {        const li = document.createElement(&#39;li&#39;);        li.innerText = Math.floor(Math.random() * total);        fragment.appendChild(li);      }      ul.appendChild(fragment);      countOfRender += 1;      loop();    }    function loop() {      if(countOfRender &lt; loopCount) {        window.requestAnimationFrame(add);      }    }    loop();  }, 0)</code></pre><h2 id="4-图片懒加载"><a href="#4-图片懒加载" class="headerlink" title="4.图片懒加载"></a>4.图片懒加载</h2><pre><code>  // &lt;img src=&quot;default.png&quot; data-src=&quot;https://xxxx/real.png&quot;&gt;  function isVisible(el) {    const position = el.getBoundingClientRect()    const windowHeight = document.documentElement.clientHeight    // 顶部边缘可见    const topVisible = position.top &gt; 0 &amp;&amp; position.top &lt; windowHeight;    // 底部边缘可见    const bottomVisible = position.bottom &lt; windowHeight &amp;&amp; position.bottom &gt; 0;    return topVisible || bottomVisible;  }  function imageLazyLoad() {    const images = document.querySelectorAll(&#39;img&#39;)    for (let img of images) {      const realSrc = img.dataset.src      if (!realSrc) continue      if (isVisible(img)) {        img.src = realSrc        img.dataset.src = &#39;&#39;      }    }  }  // 测试  window.addEventListener(&#39;load&#39;, imageLazyLoad)  window.addEventListener(&#39;scroll&#39;, imageLazyLoad)  // or  window.addEventListener(&#39;scroll&#39;, throttle(imageLazyLoad, 1000))</code></pre><h1 id="七-、防抖和节流"><a href="#七-、防抖和节流" class="headerlink" title="七 、防抖和节流"></a>七 、防抖和节流</h1><pre><code>  // 防抖  //定义:触发高频时间后n秒内函数只会执行一次,如果n秒内高频时间再次触发,则重新计算时间。  function debounce(func, ms = 1000) {    let timer;    return function (...args) {      if (timer) {        clearTimeout(timer)      }      timer = setTimeout(() =&gt; {        func.apply(this, args)      }, ms)    }  }  // 测试  const task = () =&gt; { console.log(&#39;run task&#39;) }  const debounceTask = debounce(task, 1000)  window.addEventListener(&#39;scroll&#39;, debounceTask)  // 节流  // 定义:高频时间触发,但n秒内只会执行一次,所以节流会稀释函数的执行频率。  function throttle(func, ms = 1000) {    let canRun = true    return function (...args) {      if (!canRun) return      canRun = false      setTimeout(() =&gt; {        func.apply(this, args)        canRun = true      }, ms)    }  }  // 测试  const task = () =&gt; { console.log(&#39;run task&#39;) }  const throttleTask = throttle(task, 1000)  window.addEventListener(&#39;scroll&#39;, throttleTask)</code></pre><h1 id="八-、待添加"><a href="#八-、待添加" class="headerlink" title="八 、待添加"></a>八 、待添加</h1><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><ul><li>JS方法速查: <a href="https://zhukunpenglinyutong.github.io/1.quickcheck/" target="_blank" rel="noopener">https://zhukunpenglinyutong.github.io/1.quickcheck/</a></li><li>常用JS方法整理: <a href="https://www.juejin.im/post/6844903650586787848#heading-13" target="_blank" rel="noopener">https://www.juejin.im/post/6844903650586787848#heading-13</a></li><li>JS常用数组操作方法: <a href="https://www.juejin.im/post/6844904086870081544" target="_blank" rel="noopener">https://www.juejin.im/post/6844904086870081544</a></li><li>Javascript常用方法函数收集一: <a href="https://www.imooc.com/article/1237" target="_blank" rel="noopener">https://www.imooc.com/article/1237</a></li><li>Javascript常用方法函数收集二: <a href="https://www.imooc.com/article/1242" target="_blank" rel="noopener">https://www.imooc.com/article/1242</a></li><li>32个手撕JS: <a href="https://juejin.im/post/6875152247714480136#heading-37" target="_blank" rel="noopener">https://juejin.im/post/6875152247714480136#heading-37</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写 React Hooks</title>
      <link href="/2020/09/17/shou-xie-react-hooks/"/>
      <url>/2020/09/17/shou-xie-react-hooks/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="手写-React-Hooks"><a href="#手写-React-Hooks" class="headerlink" title="手写 React Hooks"></a>手写 React Hooks</h1><hr><h1 id="Hook-是什么"><a href="#Hook-是什么" class="headerlink" title="Hook 是什么"></a>Hook 是什么</h1><p>Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。</p><h1 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a>Hook 规则</h1><ul><li>只能在函数内部的最外层调用 Hook，不要在循环、条件判断或者子函数中调用</li><li>只在 React 函数中调用 Hook 在 React 的函数组件中调用 Hook 在自定义 Hook 中调用其他 Hook</li></ul><h1 id="1-useState"><a href="#1-useState" class="headerlink" title="1.useState"></a>1.useState</h1><p>useState 会返回一个数组：一个 state，一个更新 state 的函数。</p><p>类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并，而是直接替换</p><pre><code>  // 保存状态的数组  let hookStates = [];  // 索引  let hookIndex = 0;  function useState(initialState) {    hookStates[hookIndex] = hookStates[hookIndex] || initialState;    // 利用闭包维护函数调用位置    let currentIndex = hookIndex;    function setState(newState) {      // 判断传入的state是否为函数,如果是把prevState传入      if (typeof newState === &quot;function&quot;) {        // 重新复制给newState        newState = newState(hookStates[hookIndex]);      }      // 更新state      hookStates[currentIndex] = newState;      // 触发视图更新      render();    }    // 返回数组形式，解构可写成任意变量    return [hookStates[hookIndex++], setState];  }</code></pre><h1 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2.useEffect"></a>2.useEffect</h1><p>  useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API<br>  与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新视图，这让你的应用看起来响应更快。<br>  在特殊情况（例如测量布局），有单独的 useLayoutEffect Hook，使用与 useEffect 相同</p><pre><code>    //保存状态的数组    let hookStates = [];    //索引    let hookIndex = 0;    function useEffect(callback, dependencies) {      if (hookStates[hookIndex]) {        // 非初始调用        let lastDependencies = hookStates[hookIndex];        // 判断传入依赖项跟上一次是否相同        let same = dependencies.every(          (item, index) =&gt; item === lastDependencies[index]        );        if (same) {          hookIndex++;        } else {          hookStates[hookIndex++] = dependencies;          callback();        }      } else {        // 初始调用        hookStates[hookIndex++] = dependencies;        callback();      }    }</code></pre><h1 id="3-useMemo"><a href="#3-useMemo" class="headerlink" title="3.useMemo"></a>3.useMemo</h1><p>  允许你通过「记住」上一次计算结果的方式在多次渲染的之间缓存计算结果<br>  使得控制具体子节点何时更新变得更容易，减少了对纯组件的需要</p><pre><code>    // 保存状态的数组    let hookStates = [];    // 索引    let hookIndex = 0;    function useMemo(factory, dependencies) {      if (hookStates[hookIndex]) {        // 非首次        let [lastMemo, lastDependencies] = hookStates[hookIndex];        // 判断传入依赖项跟上一次是否相同        let same = dependencies.every(          (item, index) =&gt; item === lastDependencies[index]        );        if (same) {          hookIndex++;          return lastMemo;        } else {          // 只要有一个依赖变量不一样的话          let newMemo = factory();          hookStates[hookIndex++] = [newMemo, dependencies];          return newMemo;        }      } else {        // 首次调用        let newMemo = factory();        hookStates[hookIndex++] = [newMemo, dependencies];        return newMemo;      }    }</code></pre><h1 id="4-useCallback"><a href="#4-useCallback" class="headerlink" title="4.useCallback"></a>4.useCallback</h1><p>允许你在重新渲染之间保持对相同的回调引用以使得 shouldComponentUpdate 继续工作</p><pre><code>  // 保存状态的数组  let hookStates = [];  // 索引  let hookIndex = 0;  function useCallback(callback, dependencies) {    if (hookStates[hookIndex]) {      // 非首次      let [lastCallback, lastDependencies] = hookStates[hookIndex];      let same = dependencies.every(        (item, index) =&gt; item === lastDependencies[index]      );      if (same) {        hookIndex++;        return lastCallback;      } else {        // 只要有一个依赖变量不一样的话        hookStates[hookIndex++] = [callback, dependencies];        return callback;      }    } else {      // 首次调用      hookStates[hookIndex++] = [callback, dependencies];      return callback;    }  }</code></pre><h1 id="5-memo"><a href="#5-memo" class="headerlink" title="5.memo"></a>5.memo</h1><pre><code>function memo(OldFunctionComponent) {  return class extends React.PureComponent {    render() {      return &lt;OldFunctionComponent {...this.props} /&gt;;    }  };}</code></pre><h1 id="6-useContext"><a href="#6-useContext" class="headerlink" title="6.useContext"></a>6.useContext</h1><p>  接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值<br>  useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context</p><pre><code>    function useContext(context) {      return context._currentValue;    }    // 父组件    const CountCtx = React.createContext();    function ParentComp() {      const [state, setState] = React.useState({ number: 0 });      return (        &lt;CountCtx.Provider value={{ state, setState }}&gt;          &lt;Child /&gt;        &lt;/CountCtx.Provider&gt;      );    }  // 子组件  function Child() {    let { state, setState } = useContext(CountCtx);    return (      &lt;div&gt;        &lt;p&gt;{state.number}&lt;/p&gt;        &lt;button onClick={() =&gt; setState({ number: state.number + 1 })}&gt;          add        &lt;/button&gt;      &lt;/div&gt;    );  }</code></pre><h1 id="7-useRef"><a href="#7-useRef" class="headerlink" title="7.useRef"></a>7.useRef</h1><p>useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数<br>useRef 返回的 ref 对象在组件的整个生命周期内保持不变，也就是说每次重新渲染函数组件时，返回的 ref 对象都是同一个（注意使用 React.createRef ，每次重新渲染组件都会重新创建 ref）<br>      let lastRef;</p><pre><code>  function useRef(value) {    lastRef = lastRef || { current: value };    return lastRef;  }  复制代码  useReducer  useReducer 和 redux 中 reducer 很像  useState 内部就是靠 useReducer 来实现的  // 保存状态的数组  let hookStates = [];  // 索引  let hookIndex = 0;  function useReducer(reducer, initialState) {    hookStates[hookIndex] = hookStates[hookIndex] || initialState;    let currentIndex = hookIndex;    function dispatch(action) {      hookStates[currentIndex] = reducer        ? reducer(hookStates[currentIndex], action)        : action;      // 触发视图更新      render();    }    return [hookStates[hookIndex++], dispatch];  }  // useState可以使用useReducer改写  function useState(initialState) {    return useReducer(null, initialState);  }</code></pre><h1 id="8-參考"><a href="#8-參考" class="headerlink" title="8.參考"></a>8.參考</h1><p><a href="https://juejin.im/post/6844903985338400782" target="_blank" rel="noopener">React Hooks 详解 【近 1W 字】+ 项目实战</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于jQuery带数据的日历插件</title>
      <link href="/2020/09/01/ji-yu-jquery-dai-shu-ju-de-ri-li-cha-jian/"/>
      <url>/2020/09/01/ji-yu-jquery-dai-shu-ju-de-ri-li-cha-jian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="基于jQuery带数据的日历插件"><a href="#基于jQuery带数据的日历插件" class="headerlink" title="基于jQuery带数据的日历插件"></a>基于jQuery带数据的日历插件</h1><hr><p><a href="https://github.com/Lingtian007/calendar-pro" target="_blank" rel="noopener">源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些提效-创意的 vscode 插件</title>
      <link href="/2020/08/22/na-xie-ti-xiao-chuang-yi-de-vscode-cha-jian/"/>
      <url>/2020/08/22/na-xie-ti-xiao-chuang-yi-de-vscode-cha-jian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="那些提效-创意的-vscode-插件"><a href="#那些提效-创意的-vscode-插件" class="headerlink" title="那些提效/创意的 vscode 插件"></a>那些提效/创意的 vscode 插件</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>在前端开发中，vscode 是最常用的编辑器，而 vscode 有着各种实用插件，有些可以帮助我们提升效率，有些可以让我们的工作过程变得更加快乐。</p></blockquote><p>今天我们就来介绍一下这些好用的插件吧~</p><h1 id="提效类插件"><a href="#提效类插件" class="headerlink" title="提效类插件"></a>提效类插件</h1><h2 id="1-代码神器-Power-Mode"><a href="#1-代码神器-Power-Mode" class="headerlink" title="1. 代码神器 - Power Mode"></a>1. 代码神器 - Power Mode</h2><p>首先，介绍的第一款插件是 Power Mode，它可以让你的编程过程变得更加快乐（如下图）。<br><img src="t1.gif" alt></p><h2 id="2-高亮标识-Todo-Tree"><a href="#2-高亮标识-Todo-Tree" class="headerlink" title="2. 高亮标识 - Todo Tree"></a>2. 高亮标识 - Todo Tree</h2><p>这里可以推荐一个插件来帮助提高效率，那就是 Todo Tree，我们在应用商店搜索进行安装后，我们只需要添加 // TODO: 这样的注释代码，我们就可以在 Todo Tree 中快速定位到这行注释（如下图）。<br><img src="t2.image" alt><br><img src="t3.image" alt></p><h2 id="3-快速定位括号-Bracket-Pair-Colorizer"><a href="#3-快速定位括号-Bracket-Pair-Colorizer" class="headerlink" title="3. 快速定位括号 - Bracket Pair Colorizer"></a>3. 快速定位括号 - Bracket Pair Colorizer</h2><p><img src="t4.image" alt></p><h2 id="4-拼写检查-Code-Spell-Checker"><a href="#4-拼写检查-Code-Spell-Checker" class="headerlink" title="4. 拼写检查 - Code Spell Checker"></a>4. 拼写检查 - Code Spell Checker</h2><p>我们可以使用 Code Spell Checker 插件进行拼写检测，我们安装插件后，还可以在 setting.json 中指定检测的文件，比如我这里开启了对 Vue 文件的拼写检查（如下图）。</p><p><img src="t5.image" alt><br><img src="t6.image" alt></p><h1 id="Git-管理"><a href="#Git-管理" class="headerlink" title="Git 管理"></a>Git 管理</h1><h2 id="1-Git-History"><a href="#1-Git-History" class="headerlink" title="1.Git History"></a>1.Git History</h2><ul><li>Git History 可以帮助你迅速查看 Git 历史记录，图形化的页面，使 Git 历史一目了然（如下图）<br><img src="t7.image" alt></li><li>我们还可以查看指定文件的指定版本（如下图）<br><img src="t8.image" alt></li><li>我们还可以将光标停留在某一行代码，查看该行代码的提交信息（提交人、提交时间、提交信息）（如下图<br><img src="t9.image" alt></li></ul><h2 id="2-Git-Graph"><a href="#2-Git-Graph" class="headerlink" title="2.Git Graph"></a>2.Git Graph</h2><blockquote><p>Git Graph 可以帮助你更好的分析分支之间的关系（如下图）<br><img src="t10.image" alt></p></blockquote><h2 id="3-Git-Emoji"><a href="#3-Git-Emoji" class="headerlink" title="3.Git Emoji"></a>3.Git Emoji</h2><p>Git Emoji 可以更好的帮助团队形成提交规范，使用一个 Emoji 表情概括本次提交，再加上一些文本描述信息，提交记录将会变得赏心悦目（如下图）。<br><img src="t11.image" alt><br><img src="t12.image" alt></p><h2 id="4-GitLens"><a href="#4-GitLens" class="headerlink" title="4.GitLens"></a>4.GitLens</h2><p>GitLens 可以帮助你快速比对不同分支的代码差异（如下图）<br><img src="t13.image" alt></p><h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><ol><li><p>auto close tag<br>   自动关闭标签，在开始标记的结束括号中键入后，将自动插入结束标记</p></li><li><p>Auto Comment Blocks<br>   自动插入注释行</p></li><li><p>Auto Rename Tag<br>   自动重命名配对的HTML / XML标记</p></li><li><p>Auto Complete Tag<br>   结合了自动关闭标签与同时修改同步标签</p></li><li><p>Beautify<br>   美化代码参考资料</p></li><li><p>Code Runner<br>   可以直接运行多种语言的代码片段和文件</p></li><li><p>Code Spell Checker<br>   代码拼写检查工具</p></li><li><p>Drat<br>   支持 Dart编程语言，并提供有效编辑，重构，运行和重新加载Flutter 移动应用程序和AngularDartWeb应用程序的工具。</p></li><li><p>Debugger for Chrome<br>   从VS Code调试在Google Chrome中运行的JavaScript代码。</p></li><li><p>EditorConfig for VS Code<br>  EditorConfig帮助开发人员定义和维护一致的编码风格在不同的编辑器和IDE。<br>  EditorConfig项目包含一个文件格式定义编码风格和文本编辑器插件的集合。<br>  EditorConfig文件易于阅读并且他们与版本控制器很好地合作。</p></li><li><p>ESLint<br>  代码检查工具</p></li><li><p>filesize<br>  实时查看当前文件的大小</p></li><li><p>Flutter<br>  Flutter移动应用程序的支持，以及对Dart编程语言的支持。</p></li><li><p>JavaScript (ES6) code snippets<br>  ES6的代码片段</p></li><li><p>JavaScript Snippet Pack<br>  JS代码片段补全</p></li><li><p>language-stylus<br>  Stylus文件添加语法高亮</p></li><li><p>Open in Browser<br>  在vscode中打开浏览器访问</p></li><li><p>Path Intellisense<br>  自动路径补全</p></li><li><p>Prettier - Code formatter<br>格式化代码</p></li><li><p>Scss<br>  缩进Sass语法高亮</p></li><li><p>TypeScript Importer<br>  自动搜索工作空间文件中的TypeScript定义，并将所有已知符号作为完成项提供，以允许代码完成。</p></li><li><p>Vetur<br>  代码格式化</p></li></ol><h1 id="vscode快捷键"><a href="#vscode快捷键" class="headerlink" title="vscode快捷键"></a>vscode快捷键</h1><p><strong>1.同时打开多个窗口（查看多个项目）</strong></p><ul><li>打开一个新窗口： Ctrl+Shift+N</li><li>关闭窗口： Ctrl+Shift+W</li><li>同时打开多个编辑器（查看多个文件）</li></ul><p><strong>2.新建文件 Ctrl+N</strong></p><ul><li>历史打开文件之间切换 Ctrl+Tab，Alt+Left，Alt+Right</li><li>切出一个新的编辑器（最多3个）Ctrl+\，也可以按住Ctrl鼠标点击Explorer里的文件名</li><li>左中右3个编辑器的快捷键Ctrl+1 Ctrl+2 Ctrl+3</li><li>3个编辑器之间循环切换 Ctrl+`</li><li>编辑器换位置，Ctrl+k然后按Left或Right</li></ul><p><strong>3.格式调整</strong></p><ul><li>代码行缩进Ctrl+[， Ctrl+]</li><li>折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+]</li><li>Ctrl+C Ctrl+V如果不选中，默认复制或剪切一整行</li><li>代码格式化：Shift+Alt+F，或Ctrl+Shift+P后输入format code</li><li>修剪空格Ctrl+Shift+X</li><li>上下移动一行： Alt+Up 或 Alt+Down</li><li>向上向下复制一行： Shift+Alt+Up或Shift+Alt+Down</li><li>在当前行下边插入一行Ctrl+Enter</li><li>在当前行上方插入一行Ctrl+Shift+Enter</li></ul><p><strong>4.光标相关</strong></p><ul><li>移动到行首：Home</li><li>移动到行尾：End</li><li>移动到文件结尾：Ctrl+End</li><li>移动到文件开头：Ctrl+Home</li><li>移动到后半个括号 Ctrl+Shift+]</li><li>选中当前行Ctrl+i（双击）</li><li>选择从光标到行尾Shift+End</li><li>选择从行首到光标处Shift+Home</li><li>删除光标右侧的所有字Ctrl+Delete</li><li>Shrink/expand selection： Shift+Alt+Left和Shift+Alt+Right</li><li>Multi-Cursor：可以连续选择多处，然后一起修改，Alt+Click添加cursor或者Ctrl+Alt+Down 或 Ctrl+Alt+Up</li><li>同时选中所有匹配的Ctrl+Shift+L</li><li>Ctrl+D下一个匹配的也被选中(被我自定义成删除当前行了，见下边Ctrl+Shift+K)</li><li>回退上一个光标操作Ctrl+U</li></ul><p><strong>5.重构代码</strong></p><ul><li>跳转到定义处：F12</li><li>定义处缩略图：只看一眼而不跳转过去Alt+F12</li><li>列出所有的引用：Shift+F12</li><li>同时修改本文件中所有匹配的：Ctrl+F12</li><li>重命名：比如要修改一个方法名，可以选中后按F2，输入新的名字，回车，会发现所有的文件都修改过了。</li><li>跳转到下一个Error或Warning：当有多个错误时可以按F8逐个跳转</li><li>查看diff 在explorer里选择文件右键 Set file to compare，然后需要对比的文件上右键选择Compare with’file_name_you_chose’.</li></ul><p><strong>6.查找替换</strong></p><ul><li>查找 Ctrl+F</li><li>查找替换 Ctrl+H</li><li>整个文件夹中查找 Ctrl+Shift+F</li></ul><p><strong>7.显示相关</strong></p><ul><li>全屏：F11</li><li>zoomIn/zoomOut：Ctrl + =/Ctrl + -</li><li>侧边栏显/隐：Ctrl+B</li><li>预览markdown Ctrl+Shift+V</li></ul><p><strong>8.其他</strong></p><ul><li>自动保存：File -&gt; AutoSave ，或者Ctrl+Shift+P，输入 auto</li></ul><h1 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h1><ol><li>FeHelper(前端助手)<br>JSON自动格式化、手动格式化，支持排序、解码、下载等，</li><li>MONKNOW<br>新标签页 - 个性化面板<br>这是您梦寐以求的新标签页。支持网站网址URL分组管理，数据实时云同步，黑暗深色夜间主题模式。</li><li>Postman Interceptor<br>Sends requests fired through the Postman chrome app.</li><li>有道词典Chrome划词插件<br>支持Chrome浏览器的划词翻译</li><li>谷歌访问助手<br>最简单易用的谷歌访问助手,为chrome扩展用户量身打造。可以解决chrome扩展无法自动更新的问题，同时可以访问谷歌google搜索，gmail邮箱，</li></ol><h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><h2 id="在-vscode-里画流程图-draw-io"><a href="#在-vscode-里画流程图-draw-io" class="headerlink" title="在 vscode 里画流程图 - draw.io"></a>在 vscode 里画流程图 - draw.io</h2><p>安装 draw.io 后，新建一个 helloworld.drawio，就可以在 vscode 里面画流程图啦（如下图）！<br><img src="t14.image" alt></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>持续更新中……</p>]]></content>
      
      
      <categories>
          
          <category> vscode 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些你总是记不住但又总是要用的CSS</title>
      <link href="/2020/08/09/na-xie-ni-zong-shi-ji-bu-zhu-dan-you-zong-shi-yao-yong-de-css/"/>
      <url>/2020/08/09/na-xie-ni-zong-shi-ji-bu-zhu-dan-you-zong-shi-yao-yong-de-css/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="一、设置input-的placeholder的字体样式"><a href="#一、设置input-的placeholder的字体样式" class="headerlink" title="一、设置input 的placeholder的字体样式"></a>一、设置input 的placeholder的字体样式</h1><pre><code>  input::-webkit-input-placeholder {    /* Chrome/Opera/Safari */      color: red;  }  input::-moz-placeholder { /* Firefox 19+ */        color: red;  }  input:-ms-input-placeholder { /* IE 10+ */      color: red;  }  input:-moz-placeholder { /* Firefox 18- */      color: red;  }</code></pre><ul><li><p>设置input聚焦时的样式</p><pre><code>input:focus {     background-color: red;}</code></pre></li><li><p>取消input的边框 </p><pre><code>border: none;outline: none;</code></pre></li></ul><h1 id="二、隐藏滚动条或更改滚动条样式"><a href="#二、隐藏滚动条或更改滚动条样式" class="headerlink" title="二、隐藏滚动条或更改滚动条样式"></a>二、隐藏滚动条或更改滚动条样式</h1><pre><code>  /*css主要部分的样式*//*定义滚动条宽高及背景，宽高分别对应横竖滚动条的尺寸*/  ::-webkit-scrollbar {      width: 10px; /*对垂直流动条有效*/      height: 10px; /*对水平流动条有效*/  }  /*定义滚动条的轨道颜色、内阴影及圆角*/  ::-webkit-scrollbar-track{      -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);      background-color: rosybrown;      border-radius: 3px;  }  /*定义滑块颜色、内阴影及圆角*/  ::-webkit-scrollbar-thumb{       border-radius: 7px;      -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);      background-color: #E8E8E8;  }  /*定义两端按钮的样式*/  ::-webkit-scrollbar-button {      background-color:cyan;  }  /*定义右下角汇合处的样式*/  ::-webkit-scrollbar-corner {      background:khaki;  }</code></pre><h1 id="三、文字超出隐藏并显示省略号"><a href="#三、文字超出隐藏并显示省略号" class="headerlink" title="三、文字超出隐藏并显示省略号"></a>三、文字超出隐藏并显示省略号</h1><h2 id="单行（一定要有宽度）"><a href="#单行（一定要有宽度）" class="headerlink" title="单行（一定要有宽度）"></a>单行（一定要有宽度）</h2><pre><code>  width:200rpx;  white-space: nowrap;  overflow: hidden;  text-overflow: ellipsis;</code></pre><h2 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h2><pre><code>  word-break: break-all;  display: -webkit-box;  -webkit-line-clamp: 2;  -webkit-box-orient: vertical;  overflow: hidden;</code></pre><h1 id="四、控制div内的元素自动换行"><a href="#四、控制div内的元素自动换行" class="headerlink" title="四、控制div内的元素自动换行"></a>四、控制div内的元素自动换行</h1><pre><code>  word-wrap: break-word;  word-break：break-all;</code></pre><h1 id="五、-纯css画三角形"><a href="#五、-纯css画三角形" class="headerlink" title="五、 纯css画三角形"></a>五、 纯css画三角形</h1><pre><code>  #demo {      width: 0;      height: 0;      border-width: 20px;      border-style: solid;      border-color: transparent transparent red transparent;  }</code></pre><h1 id="六、-绝对定位元素居中（水平和垂直方向）"><a href="#六、-绝对定位元素居中（水平和垂直方向）" class="headerlink" title="六、 绝对定位元素居中（水平和垂直方向）"></a>六、 绝对定位元素居中（水平和垂直方向）</h1><pre><code>  #demo {      width: 200px;      height: 200px;      position: absolute;      left: 50%;      top: 50%;      transform: translate(-50%,-50%);      background-color: green;  }</code></pre><h1 id="七、表格边框合并"><a href="#七、表格边框合并" class="headerlink" title="七、表格边框合并"></a>七、表格边框合并</h1><pre><code>  table,tr,td{border: 1px solid #333;}  table{    border-collapse: collapse;  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React函数式编程 - Hooks</title>
      <link href="/2020/07/07/react-hooks-han-shu-shi-bian-cheng/"/>
      <url>/2020/07/07/react-hooks-han-shu-shi-bian-cheng/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1417496128&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数式编程介绍（摘自基维百科）</p><blockquote><p>函数式编程（英语：functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将计算机运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）</p></blockquote><p>面向对象编程介绍（摘自基维百科）</p><blockquote><p>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象</p></blockquote><hr><p>在react 16.8之前，我们使用基于react的框架开发时，声明一个组件有两种方式：</p><ul><li>class声明组件</li><li>函数组件</li></ul><p>在class 组件中，我们可以使用state、react的钩子函数等react特性。但是函数组件是一个无状态组件，而且对于操作DOM、发起请求等副作用并不能很好的处理。为了解决这个问题,react16.8 的新特性可以解决这一问题,以下 三点是 react 官网所提到的 <a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation" target="_blank" rel="noopener">hooks</a>动机.</p><ul><li>代码重用：在hooks出来之前，常见的代码重用方式是 HOC 和render props，这两种方式带来的问题是：你需要解构自己的组件，同时会带来很深的组件嵌套</li><li>复杂的组件逻辑：在class组件中，有许多的lifecycle 函数，你需要在各个函数的里面去做对应的事情。这种方式带来的痛点是：逻辑分散在各处，开发者去维护这些代码会分散自己的精力，理解代码逻辑也很吃力</li><li>class组件的困惑：对于初学者来说，需要理解class组件里面的this是比较吃力的，同时，基于class的组件难以优化。</li></ul><h1 id="什么是React-Hooks"><a href="#什么是React-Hooks" class="headerlink" title="什么是React Hooks"></a>什么是React Hooks</h1><blockquote><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p></blockquote><h1 id="react-Hooks使用规则"><a href="#react-Hooks使用规则" class="headerlink" title="react Hooks使用规则"></a>react Hooks使用规则</h1><blockquote><p>在学习之前先跟大家说下react hooks使用的规则：</p><ul><li>只能在react函数组件中使用Hooks。</li><li>只能在组件的最顶层使用Hooks</li></ul></blockquote><h1 id="react-Hooks使用"><a href="#react-Hooks使用" class="headerlink" title="react Hooks使用"></a>react Hooks使用</h1><h2 id="一、-useState"><a href="#一、-useState" class="headerlink" title="一、 useState"></a>一、 useState</h2><blockquote><p>作用：在函数组件中调用它，可以添加一些内部的state。</p></blockquote><ul><li><p>示例</p><pre><code>      import React,{useState} from &#39;react&#39;;      function Counter(){          //js          const [count,setCount] = useState(0);          //ts          const [count,setCount] = useState&lt;any&gt;(0);          console.log(count)          return(          &lt;div&gt;              &lt;button onClick={()=&gt;{setCount(count+1)}}&gt;+&lt;/button&gt;              {count}              &lt;button onClick={()=&gt;{setCount(count-1)}}&gt;-&lt;/button&gt;          &lt;/div&gt;          )          }      export default Counter;</code></pre></li><li><p>useState 参数</p><blockquote><p>const [state变量，修改该变量的set方法] = useState(初始值)</p></blockquote></li></ul><p>一般来说函数在执行结束后变量就会消失，但是react保留了state变量，当state发生改变后，函数组件都会重新渲染，useState都会将当前的state值传递给state变量。</p><p>setCount是一个useState返回的用于更新state变量的方法，接收state的新值作为参数。</p><p>下面是使用useState需要注意的地方：</p><ul><li><p>每次setCount 都会重新渲染函数组件。</p></li><li><p>你可以设置多个useState，使用多个变量，但是useState也可以很好的接收 数组、对象作为初始值。</p></li><li><p>使用count声明state变量的原因是：使其只能被set函数进行修改，达到setState的效果。</p></li><li><p>setState()接收新的state或者一个返回state的函数（setCount(prevCount =&gt; prevCount - 1)}）</p></li><li><p>在class组件中使用state，当setState时，是将setState的参数与原来的state进行对象的合并。但是  useState则是使用新值替换原来的值。可能这么说不太明白，请看下面的示例：</p><pre><code>  import React,{useState} from &#39;react&#39;;  function Counter(){      const [people,setPeople] = useState({age:16,name:&#39;buzhanhua&#39;});      console.log(people.name)      return(          &lt;div&gt;              &lt;button onClick={()=&gt;{setPeople({age:people.age+1})}}&gt;+&lt;/button&gt;              {people.age}              {people.name}              &lt;button onClick={()=&gt;{setPeople({age:people+1})}}&gt;-&lt;/button&gt;          &lt;/div&gt;      )  }  export default Counter;</code></pre></li></ul><p>当你点击加号以后，你会发现people的name属性变为了undefined，证明该机制是 替换。</p><h2 id="二、useEffect"><a href="#二、useEffect" class="headerlink" title="二、useEffect"></a>二、useEffect</h2><blockquote><p>作用：给函数组件增加操作副作用的能力。和class中的<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnMount</code>的用途一致。</p></blockquote><ul><li><p>示例</p><pre><code>  function UseEffect(){      const [age,setAge] = useState(0);      useEffect(()=&gt;{          let time = setInterval(()=&gt;{              setAge(age+1);              console.log(age)          },1000)          return ()=&gt;{              clearInterval(time)          }      },[age])      return(          &lt;div&gt;              {age}          &lt;/div&gt;      )  }</code></pre></li><li><p>语法：</p><blockquote><p>useEffect(function,arr);</p></blockquote></li><li><p>注释：</p></li></ul><ul><li><p>useEffect接收两个参数，第一个为一个函数（必选），第二个是一个数组（可选）；</p></li><li><p>参数一是一个函数，用于执行你想在在class组件不同生命周期钩子函数执行的一些代码。（下文细说）。</p></li><li><p>参数二是一个数组，由于state变量变化时，函数组件都会重新渲染，那么useEffect也会在每次渲染的时候都会执行，显然在某些条件下，你并不想让全部的useEffect都重新执行，这个参数就是加以限制，只有当列表的变量变化时，useEffect才会重新执行。</p><pre><code>  useEffect(()=&gt;{      // 相当于class组件的componentDidMount和componentDidUpdate      return ()=&gt;{          //可选，该函数将在组件将要卸载时执行，相当于componentWillUnMount      }  },[age])  // 只执行一次  useEffect(()=&gt;{      window.addEventListener(&#39;resize&#39;,onResize);      return ()=&gt;{          window.removeEventListener(&#39;resize&#39;,onResize)      }  },[])  // 参数列表设置为空数组，这样只会在组件加载完成后绑定事件， 组件销毁前解绑事件  // 只会执行一次， 但是这种方式要谨慎使用, 亲测 ： 这种方式 setInterval 会有问题</code></pre></li><li><p>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。</p></li></ul><h2 id="三、useContext"><a href="#三、useContext" class="headerlink" title="三、useContext"></a>三、useContext</h2><blockquote><p>context，你可以理解为一个全局的state，里面可以存变量，方法，可以在provider之下的所有位置进行使用，不用关心层级关系。并可以通过里面的方法对值进行统一处理。</p></blockquote><ul><li><p>16.8的函数组件的context</p><pre><code>  import React ,{createContext,useState,useContext} from &#39;react&#39;;  const UserContext = new createContext();  // 创造一个context  // 创建provider  const UserProvider = props =&gt; {      const [username,setUsername] = useState(&#39;&#39;);      return(          &lt;UserContext.Provider value={{username,setUsername}}&gt;              {props.children}          &lt;/UserContext.Provider&gt;      )  }  const Pannel = () =&gt; {      const {username,setUsername} = useContext(UserContext);// 使用context      return (          &lt;div&gt;              &lt;div&gt;user:{username}&lt;/div&gt;              &lt;input onChange={e =&gt; setUsername(e.target.value)}/&gt;          &lt;/div&gt;      )  }  const UseContext = ()=&gt;(      &lt;UserProvider&gt;          &lt;Pannel/&gt;      &lt;/UserProvider&gt;  )  export default UseContext;</code></pre></li></ul><p>在使用useContext后，就不需要再用consumer包裹取值了</p><h2 id="四、useMemo和useCallback"><a href="#四、useMemo和useCallback" class="headerlink" title="四、useMemo和useCallback"></a>四、useMemo和useCallback</h2><blockquote><p>这两个Hook的作用类似，主要作为性能优化手段进行使用，试想一下这个场景，当你使用set函数改变state时，函数组件将会重新进行渲染，但是你发现，并不是所有的子组件都有必要重新渲染，那么这两个Hook就是解决这种情况的，用于控制当依赖项数组中的state改变时才进行重新渲染。</p></blockquote><ul><li><p>示例：</p><pre><code>  import React,{useState,useMemo,useCallback} from &#39;react&#39;;  function Time(){      return(          &lt;div&gt;{Date.now()}&lt;/div&gt;      )  }  function Count(){      const [count,setCount] = useState(0);      const [name,setName] = useState(&#39;buzhanhua&#39;);      //const memoizedComponent = useMemo(()=&gt;&lt;Time/&gt;,[count]);      const memoizedComponent = useCallback(&lt;Time/&gt;,[count]);      return(          &lt;div&gt;              &lt;button onClick={()=&gt;{setCount(count+1)}}&gt;改变数字&lt;/button&gt;              &lt;button onClick={()=&gt;{setName(name+&#39;ha&#39;)}}&gt;改变名字&lt;/button&gt;              {memoizedComponent}              &lt;p&gt;数字：{count}&lt;/p&gt;              &lt;p&gt;名字：{name}&lt;/p&gt;          &lt;/div&gt;      )  }  export default Count;</code></pre></li><li><p>语法:</p><blockquote><p>useCallback(fn,依赖项数组)等同于useMemo(()=&gt;fn,依赖项数组)</p></blockquote></li></ul><p>在的demo中有两个button按钮，在使用useCallback或者useMemo后，你会发现只有当处于依赖项数组中的count改变时，Time组件才会重新渲染。</p><h2 id="五、useRef"><a href="#五、useRef" class="headerlink" title="五、useRef"></a>五、useRef</h2><blockquote><p>语法： const myRef = useRef(initialValue);<br>useRef返回一个可变的ref对象，其 .current属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。其实就是提供给我们一个保存可变变量的空间，大家想一下这个需求：怎么能够记录组件的渲染次数？其他的Hook都是一个常量，只有使用set函数的时候才可以改变，我们如果想实现该需求的话，需要找到一个可更改但又在改变时不会使组件从新渲染的东西。</p></blockquote><pre><code>    //获取节点demo    import React,{useRef,useState} from &#39;react&#39;;    function UseRef(){        const myRef = useRef(null)        const callback = () =&gt;{            myRef.current.focus()        }        return(            &lt;div&gt;                &lt;input type=&quot;type&quot; ref={myRef}/&gt;                &lt;button onClick={callback}&gt;聚焦&lt;/button&gt;            &lt;/div&gt;        )    }    //保存前一个状态    import React ,{useState,useEffect,useRef}from &#39;react&#39;;    function Rank(props){        const [count, setCount] = useState(0);        const prevCountRef = useRef();        useEffect(() =&gt; {        prevCountRef.current = count;        });        const prevCount = prevCountRef.current;        return(            &lt;div&gt;RankNow: {count}, before: {prevCount}            &lt;button onClick={()=&gt;{setCount(count + 1)}}&gt;点击&lt;/button&gt;            &lt;/div&gt;        )    }    export default React.memo(Rank);</code></pre><p>需求实现demo：</p><pre><code>    import React,{useRef,useState} from &#39;react&#39;;    function Time(props){        console.log(props.current)        return(            &lt;div&gt;{Date.now()}&lt;/div&gt;        )    }    function UseRef(){        const myRef = useRef(0);        const [count,setCount] = useState(0);        myRef.current++        return(            &lt;div&gt;                &lt;Time current={myRef.current}/&gt;                &lt;button onClick={()=&gt;{setCount(count+1)}}&gt;+&lt;/button&gt;            &lt;/div&gt;        )    }    export default UseRef</code></pre><p>注释：</p><ul><li>使用useRef方法返回的{current：…} 和自己创建一个{current:…} 对象的唯一区别就是，每次组件渲染返回的ref对象都是同一个对象，所以它可以实现上面的需求。</li><li>useRef比ref属性更有用，它可以方便的保存任何可变值。</li></ul><h2 id="六、自定义Hook"><a href="#六、自定义Hook" class="headerlink" title="六、自定义Hook"></a>六、自定义Hook</h2><blockquote><p>自定义 Hook 是一个函数，其名称以 “use” 开头（规定），函数内部可以调用其他的 Hook。</p></blockquote><p>下面是一个获取浏览器窗口demo的展示，可以监测手动缩放</p><pre><code>    import React , {useState,useEffect} from &#39;react&#39;;    function WinSize(){        const [size,setSize] = useState({            width:  document.documentElement.clientWidth,            height:  document.documentElement.clientHeight        });        const onResize =  ()=&gt;{            setSize({                width: document.documentElement.clientWidth,                height: document.documentElement.clientHeight            })        }        useEffect(()=&gt;{            window.addEventListener(&#39;resize&#39;,onResize);            return ()=&gt;{                window.removeEventListener(&#39;resize&#39;,onResize);            }        },[])        return size;    }    function Demo6(){        const size = WinSize();        return (            &lt;div&gt;                浏览器窗口：宽 {size.width} 高 : {size.height}            &lt;/div&gt;        )    }    export default Demo6</code></pre><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>highcharts 实时动态刷新曲线图</title>
      <link href="/2020/06/18/highchart-zhi-chu-kui/"/>
      <url>/2020/06/18/highchart-zhi-chu-kui/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><blockquote><p>最近要求做前台的一些东西，用到了 <a href="https://www.highcharts.com.cn/docs/basic-compose" target="_blank" rel="noopener">Highcharts</a>。其实在Highcharts中文网上有相应的演示demo，一般你所需要的图的样式都可以找到。难点在于实际开发中，需要的数据往往是要结合后台请求并响应的数据的。</p></blockquote><hr><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;title&gt;Highcharts Example&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;${ctxPath}/static/code/highcharts.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;${ctxPath}/static/code/modules/exporting.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;${ctxPath}/static/code/modules/export-data.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;container&quot; style=&quot;min-width: 310px; height: 400px; margin: 0 auto&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Highcharts.setOptions({        global: {            useUTC: false        }    });    var max=6;    Highcharts.chart(&#39;container&#39;, {        chart: {            type: &#39;spline&#39;,            animation: Highcharts.svg,             events: {                load: function() {                    var series = this.series;                    var loadData = function() {                        $.getJSON(&quot;http://localhost:8089/echarts/vintage&quot;, function(data) {                            for (var k = 0; k &lt; series.length; k++) {                                console.info(data.length)                                for (var j = 0; j &lt; data[k].length; j++) {                                    var point = data[k][j];                                    console.info(point)                                    console.info(point[0])                                    console.info(point[1])                                    var isShift = series[k].data.length &gt;= max;                                    console.log(&quot;series &quot; + k + &quot;.data.length=&quot; + series[k].data.length);                                    var lastTime = 0;                                    if (series[k].data.length &gt; 0)                                        lastTime = series[k].data[series[k].data.length - 1].x;                                    if (point[0] &gt; lastTime)                                        series[k].addPoint([point[0],point[1]], true, isShift);                                }                            }                        })                    };                    loadData();                    setInterval(loadData, 1000); // 轮询请求                 }            }        },        title: {            text: &#39;访问量实时监控&#39;        },        xAxis: [            {                type: &#39;datetime&#39;,                tickPixelInterval: 120            }        ],        yAxis: [            {                title: {                    text: &#39;总请求/分钟&#39;,                    style: {                        color: &#39;#3E576F&#39;                    }                }            },            {                title: {                    text: &#39;平均响应时间&#39;,                    style: {                        color: &#39;#00AA00&#39;                    }                },opposite:true            }        ],        plotOptions: {            spline: {                marker:{                    enabled: false,                    states: {                        hover: {                            enabled: true,                            symbol: &#39;circle&#39;,                            radius: 5,                            lineWidth: 1                        }                    }                }            }        },        tooltip: {            formatter: function() {                return &#39;&lt;b&gt;&#39; + this.series.name + &#39;&lt;/b&gt;&lt;br/&gt;&#39; +                    Highcharts.dateFormat(&#39;%Y-%m-%d %H:%M:%S&#39;, this.x) + &#39;&lt;br/&gt;&#39; +                    Highcharts.numberFormat(this.y, 2);            }        },        legend: {            enabled: true        },        exporting: {            enabled: false        },        series: [            {                name: &#39;总请求数&#39;,                data: [{x: 1535549581766, y: 8.255385961269337},                    {x: 1535549582766, y: 8.522856658860768},                    {x: 1535549583766, y: 8.85224288300491},                    {x: 1535549584766, y: 8.203602150586137},                    {x: 1535549585766, y: 8.830985714653746},                    {x: 1535549586766, y: 8.648804185628615},                    {x: 1535549587766, y: 8.54365631703881},                    {x: 1535549588766, y: 8.183473493411935},                    {x: 1535549589766, y: 8.107250381815213},                    {x: 1535549590766, y: 8.674642595370756},                    {x: 1535549591766, y: 8.875834458275218},                    {x: 1535549592766, y: 8.104192236371079},                    {x: 1535549593766, y: 8.273510688961343},                    {x: 1535549594766, y: 8.698645044397763},                    {x: 1535549595766, y: 8.630132546505347},                    {x: 1535549596766, y: 8.19276234585974},                    {x: 1535549597766, y: 8.202379301534918},                    {x: 1535549598766, y: 8.888758703470918},                    {x: 1535549599766, y: 8.840359577742495},                    {x: 1535551504135, y: 8.965286133918756}]            },            {                name: &#39;错误请求数&#39;,                data: [{x: 1535549581768, y: 5.631470025269889},                    {x: 1535549582768, y: 5.80833150333066},                    {x: 1535549583768, y: 5.615057046709662},                    {x: 1535549584768, y: 5.608928585842969},                    {x: 1535549585768, y: 5.153605115523144},                    {x: 1535549586768, y: 5.438982653534119},                    {x: 1535549587768, y: 5.434254193425316},                    {x: 1535549588768, y: 5.233764563045739},                    {x: 1535549589768, y: 5.066078696056088},                    {x: 1535549590768, y: 5.402066058377414},                    {x: 1535549591768, y: 5.115167367142142},                    {x: 1535549592768, y: 5.569563848237927},                    {x: 1535549593768, y: 5.3771521799030895},                    {x: 1535549594768, y: 5.557674673748734},                    {x: 1535549595768, y: 5.779198450582005},                    {x: 1535549596768, y: 5.024568401355755},                    {x: 1535549597768, y: 5.999943168524271},                    {x: 1535549598768, y: 5.3633974314345725},                    {x: 1535549599768, y: 5.152136232686349},                    {x: 1535549600768, y: 5.497676337112302}]            },            {                name: &#39;平均响应时间&#39;,                yAxis:1,                data: [{x: 1535549581770, y: 2.9063965576357296},                    {x: 1535549582770, y: 2.115102850799488},                    {x: 1535549583770, y: 2.295125026581167},                    {x: 1535549584770, y: 2.5839580878751627},                    {x: 1535549585770, y: 2.41973580817432},                    {x: 1535549586770, y: 2.2324255066003476},                    {x: 1535549587770, y: 2.877080909195574},                    {x: 1535549588770, y: 2.670387619876992},                    {x: 1535549589770, y: 2.8328323536321003},                    {x: 1535549590770, y: 2.4492166897167564},                    {x: 1535549591770, y: 2.2960889540892544},                    {x: 1535549592770, y: 2.4254398993593957},                    {x: 1535549593770, y: 2.9139794370919248},                    {x: 1535549594770, y: 2.2363677342947907},                    {x: 1535549595770, y: 2.7774917450101677},                    {x: 1535549596770, y: 2.8122490928540937},                    {x: 1535549597770, y: 2.3611332533125644},                    {x: 1535549598770, y: 2.2739320663864726},                    {x: 1535549599770, y: 2.9702427114600276},                    {x: 1535549600770, y: 2.470969458860716}]            }        ]    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p>  <img src="hc.png" alt></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p><a href="https://www.highcharts.com.cn/demo/highcharts/dynamic-update" target="_blank" rel="noopener">官网样例</a></p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 前端面试</title>
      <link href="/2020/05/30/mian-shi-zhi-lu/"/>
      <url>/2020/05/30/mian-shi-zhi-lu/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=525278524&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>总结一下面试遇到的问题，为了方便自己查阅，也希望对小伙伴们有所帮助！</p></blockquote><h3 id="一-HTML"><a href="#一-HTML" class="headerlink" title="一 HTML"></a>一 HTML</h3><ul><li><p>HTML语义化就是让页面内容结构化，它有如下优点</p><ul><li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</li><li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li><li>方便其他设备解析，如盲人阅读器根据语义渲染网页</li><li>有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐</li></ul></li></ul><p>如：</p><pre><code>&lt;header&gt;代表头部&lt;nav&gt;代表超链接区域&lt;main&gt;定义文档主要内容&lt;article&gt;可以表示文章、博客等内容&lt;aside&gt;通常表示侧边栏或嵌入内容&lt;footer&gt;代表尾部</code></pre><ul><li>HTML5新标签 </li></ul><p><code>有&lt;header&gt;、&lt;footer&gt;、&lt;aside&gt;、&lt;nav&gt;、&lt;video&gt;、&lt;audio&gt;、&lt;canvas&gt;等...</code></p><h3 id="二-CSS"><a href="#二-CSS" class="headerlink" title="二 CSS"></a>二 CSS</h3><ul><li><p>盒子模型<br>盒模型分为标准盒模型和怪异盒模型(IE模型)</p><ul><li>标准盒模型 :在标准的盒子模型中，width指content部分的宽度</li><li>IE盒模型: 在IE盒子模型中，width表示content+padding+border这三个部分的宽度</li></ul></li><li><p>rem与em的区别</p></li></ul><blockquote><p>rem是根据根的font-size变化，而em是根据父级的font-size变化</p></blockquote><ul><li><p>CSS选择器 </p><pre><code>通配符：*ID选择器：#ID类选择器：.class元素选择器：p、a    等后代选择器：p span、div a   等伪类选择器：a:hover 等属性选择器：input[type=&quot;text&quot;]  等</code></pre><blockquote><p>权重 !important -&gt; 行内样式 -&gt; #id -&gt; .class -&gt; 元素和伪元素 -&gt; * -&gt; 继承 -&gt; 默认</p></blockquote></li><li><p>CSS新特性 </p><pre><code>transition：过渡transform：旋转、缩放、移动或者倾斜animation：动画 gradient：渐变shadow：阴影border-radius：圆角</code></pre></li><li><p>css命名长短 优缺点<br>性能分为下载性能(速度)和渲染性能，大家认为：</p></li></ul><ol><li>下载性能可能是短命名略胜一筹，因为文件会稍小些；</li><li>渲染性能则是长命名好些，因为CSS中通常短命名我们用类似.box .hd {}定义样式，而长命名直接是.box-hd {}，pagespeed认为选择器长度会影响渲染性能。<br>(注：其实平时工作中这两点都会被忽略。gzip可以进一步减少第一个问题的差距，而由此引发的渲染性能也是微乎其微)</li></ol><p>然后大家就可维护性进行了讨论，这次支持长命名的人较多。</p><ol><li><p>长命名给人较为可靠的感觉；</p></li><li><p>长命名较短命名发生冲突的几率低很多；</p></li><li><p>可复用的内容通过短命名定义，无可争议；<br>…<br>最后是使用场景，玉伯借用YAHOO首页的例子牵头，大家讨论，总结如下：(主要依据可维护性)</p></li><li><p>框架级样式用短命名，比如盒模型、栅格；</p></li><li><p>通用样式用短命名，比如.hidden、.clearfix；</p></li><li><p>应用级样式用长命名，比如淘江湖项目的通用样式都加上“sns”前缀(有.sns-avatar、.sns-box等)；</p></li><li><p>页面级样式用长命名，比如类目模块，可能包含category-hd、category-bd、category-bd-tips等；</p></li><li><p>嵌入式应用用长命名，因为可能会被嵌入到任何复杂环境中，比如开源编辑器、Google的各种应用(map, adsence, gmail…)</p></li></ol><ul><li><p>如何垂直水平居中一个div</p><ul><li>div绝对定位水平垂直居中【Transforms 变形】    </li><li>flex display:flex;<br>  justify-content:center;<br>  align-items:center;</li><li>将父盒子设置为table-cell元素，可以使用text-align:center和 vertical-align:middle实现水平、垂直居中。</li><li>比较完美的解决方案是利用三层结构模拟父子结构</li></ul></li><li><p>less /scss 优点:</p><ol><li>支持嵌套 </li><li>支持变量定义 </li><li>支持“模板函数”（自己定义的名称。。。），比如有些CSS需要做兼容前缀的话，你可以这样使用一个模板函数定义一下，调用的时候传入正常值就可以了。会自动生成前缀的CSS</li></ol></li><li><p>多行元素的文本省略号 </p><pre><code>overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical</code></pre></li><li><p>flex 布局实现div均分自动换行<br>flex-wrap: wrap </p></li></ul><h3 id="三-JavaScript"><a href="#三-JavaScript" class="headerlink" title="三 JavaScript"></a>三 JavaScript</h3><p><strong>JS的几条基本规范</strong></p><blockquote><p>1、不要在同一行声明多个变量<br>2、请使用===/！==来比较true/false或者数值<br>3、使用对象字面量替代new Array这种形式<br>4、不要使用全局变量<br>5、Switch语句必须带有default分支<br>6、函数不应该有时候有返回值，有时候没有返回值<br>7、For循环必须使用大括号<br>8、IF语句必须使用大括号<br>9、for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染</p></blockquote><h4 id="1-JS的基本数据类型与复杂数据类型"><a href="#1-JS的基本数据类型与复杂数据类型" class="headerlink" title="1.JS的基本数据类型与复杂数据类型"></a>1.JS的基本数据类型与复杂数据类型</h4><ul><li><p>基本数据类型存储在栈中，引用数据类型存储在堆中，引用地址存放在栈内，</p></li><li><p>将基本数据存储在栈中是因为它们占据的空间是固定的，更有利于迅速查询变量的值，</p></li><li><p>==&gt;为什么引用数据类型不放在栈中,  :=&gt;由于引用数据类型大小不固定，如果存放在栈中会降低变量的搜索效率(栈内存主要是根据程序逻辑明确申请的内存，所以也会变相降低程序逻辑处理效率。) </p></li><li><p>引用数据类型大小衡量通过占用内存的大小，  在进行比较的时候比较的是引用地址。 </p></li><li><p>基本数据类型有哪些?  </p><ul><li>六种 <code>number  string  boolean   undefind  null   es6新增的symbol</code> ,</li></ul></li><li><p>复杂数据类型有哪些?</p><ul><li><code>object,  Array,function</code></li></ul></li><li><p>什么是symbol?</p></li></ul><blockquote><p>一般问到了基本数据类型种类,你说了symbol的话,肯定会问symbol,   :=&gt; symbol不能使用new,它生成的也是原始数据类型的值, 它生成的数据都是独一无二的.(就算symbol里的变量值相同,那也是两个数据值.    symbol.for和symbol的区别在于 symbol.for会先查找有没有这个key值,有则直接返回,没有才会创建.)  </p></blockquote><blockquote><p>一般问到基本数据类型,就会问检测复杂数据类型的方法 </p></blockquote><ul><li>基本数据类型可以用typeof检测,对复杂数据类型都是返回object,但是fucntion是特例,会返回function.</li><li>判断复杂数据类型可以用 instandof,(instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上)</li><li>还可以借用object原型上的 tostring方法,从后往前截取大概8位.</li></ul><h4 id="2-数组操作"><a href="#2-数组操作" class="headerlink" title="2.数组操作"></a>2.数组操作</h4><pre><code>map: 遍历数组，返回回调返回值组成的新数组forEach: 无法break，可以用try/catch中throw new Error来停止filter: 过滤some: 有一项返回true，则整体为trueevery: 有一项返回false，则整体为falsejoin: 通过指定连接符生成字符串push / pop: 末尾推入和弹出，改变原数组， 返回推入/弹出项【有误】unshift / shift: 头部推入和弹出，改变原数组，返回操作项【有误】sort(fn) / reverse: 排序与反转，改变原数组concat: 连接数组，不影响原数组， 浅拷贝slice(start, end): 返回截断后的新数组，不改变原数组splice(start, number, value...): 返回删除元素组成的数组，value 为插入项，改变原数组indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值，cur 为当前值(从第二项开始)</code></pre><h4 id="3-JS有哪些内置对象"><a href="#3-JS有哪些内置对象" class="headerlink" title="3.JS有哪些内置对象"></a>3.JS有哪些内置对象</h4><pre><code>Object是JavaScript中所有对象的父对象数据封装对象：Object、Array、Boolean、Number和String其他对象：Function、Arguments、Math、Date、RegExp、Error</code></pre><h4 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h4><p><strong>什么是闭包</strong></p><blockquote><p>函数A 里面包含了 函数B，而 函数B 里面使用了 函数A 的变量，那么 函数B 被称为闭包。(闭包就是能够读取其他函数内部变量的函数)</p></blockquote><pre><code>function A() {var a = 1;function B() {    console.log(a);}return B();}</code></pre><p><strong>闭包的特征</strong></p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收制回收</li></ul><p><strong>对闭包的理解</strong></p><blockquote><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p></blockquote><p><strong>闭包的优缺点</strong></p><ul><li>优点: 能够实现封装和缓存等</li><li>缺点: 就是消耗内存、不正当使用会造成<a href="https://blog.csdn.net/weixin_41989325/article/details/102808390" target="_blank" rel="noopener">内存泄露</a>的问题</li></ul><h4 id="5-JS作用域及作用域链"><a href="#5-JS作用域及作用域链" class="headerlink" title="5.JS作用域及作用域链"></a>5.JS作用域及作用域链</h4><blockquote><p>在JavaScript中，作用域分为 <code>全局作用域</code> 和 <code>函数作用域</code></p></blockquote><ul><li>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值,但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。<br><img src="zyy.jpg" alt></li></ul><h4 id="6-原型和原型链"><a href="#6-原型和原型链" class="headerlink" title="6.原型和原型链"></a>6.原型和原型链</h4><p><strong>概念</strong></p><blockquote><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去</p></blockquote><p><strong>完整版原型链</strong></p><p><a href="https://blog.csdn.net/u011313703/article/details/78343108" target="_blank" rel="noopener">完整原型链详细图解（构造函数、原型、实例化对象）</a><br><img src="yxl.jpg" alt></p><h4 id="7-组件化和模块化"><a href="#7-组件化和模块化" class="headerlink" title="7.组件化和模块化"></a>7.组件化和模块化</h4><ul><li>组件化优点: 专一、可配置性、标准性、复用性、可维护性</li><li>模块化优点: 避免变量污染、命名冲突、提高代码复用率、提高了可维护性、方便依赖关系管理</li></ul><h4 id="8-图片的预加载和懒加载"><a href="#8-图片的预加载和懒加载" class="headerlink" title="8.图片的预加载和懒加载"></a>8.图片的预加载和懒加载</h4><ul><li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染</li><li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数</li></ul><h4 id="9-实例化new与不new的区别"><a href="#9-实例化new与不new的区别" class="headerlink" title="9.实例化new与不new的区别"></a>9.实例化new与不new的区别</h4><blockquote><p> 简单来说，就是， new是通过调用构造函数Function来创建函数  ，没有return会返回一个对象,不new只是调用函数把返回值赋值变量。  没有return就返回undefind</p></blockquote><p>null 和undefind的区别   :=&gt;  null用来表示尚未存在的对象, undefind表示还没有赋值.  null转数值为0,  undefind转数值为nan.</p><h4 id="10-什么是promise"><a href="#10-什么是promise" class="headerlink" title="10.什么是promise"></a>10.什么是promise</h4><blockquote><p>一句话概括promise : Promise对象用于异步操作,他表示一个尚未完成切预计在未来会完成的异步操作.</p></blockquote><p><strong>promise 是什么?</strong>  </p><ul><li>promise是es6提供的一种解决回调地狱的方案,它是一个容器,内部存放着某个异步操作的结果,并且提供统一的api进行操作,</li><li>它本身有<code>all,resolve,pending,reject,</code> 原型上有 then,catch方法,  <code>缺点</code>在于,一旦建立,就无法取消</li></ul><p><strong>回调地狱解决方案</strong></p><ul><li>promise </li><li>async/await </li><li>generator </li></ul><h4 id="11-对This对象的理解"><a href="#11-对This对象的理解" class="headerlink" title="11.对This对象的理解"></a>11.对This对象的理解</h4><ul><li>普通函数的this指向大致分为几种:<ul><li>指向window的 -&gt;普通函数调用和定时器，</li><li>指向实例化对象的 -&gt;构造函数，</li><li>指向事件处理对象的 -&gt;事件函数。  </li><li>箭头函数是es6新增的特性，它不能用作构造函数，也没有自己的this,argument,super或new.target.它只会从自己的作用域链的上一层继承this，也就是沿用外一层的this指向。</li></ul></li><li>定时器中的this是指向window的,那么如果对定时器的function改造成箭头函数的话, 它的指向是什么?    :=&gt;  沿用作用域上一层的this,  </li><li>那么怎么去固定定时器中的this  :=&gt;古老的方法: var that = this      工作中常用的方法   .bind(this)  ( 参见贪吃蛇中绑定this的方法)</li></ul><h4 id="12-浅拷贝和深拷贝的区别"><a href="#12-浅拷贝和深拷贝的区别" class="headerlink" title="12.浅拷贝和深拷贝的区别"></a>12.浅拷贝和深拷贝的区别</h4><blockquote><p>简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力赋值。</p></blockquote><p>在引用类型中，只是赋值了指针， 并没有创建对象空间,而浅拷贝和深拷贝都会创建一个新对象只是说浅拷贝的对象是引用类数据的第一层引用 ，拷贝第一层级，指针依然指向引用数据，引用数据内部改变，浅拷贝对象也会发生改变。深拷贝是完全创建一个新对象，拷贝所有层级，复制内部所有结构。两者互不影响.</p><ul><li><p>怎么完成一个浅拷贝</p><ul><li>用es6的spread操作符   …obj</li></ul></li><li><p>怎么用简单的方法实现一个深拷贝 </p><ul><li><p>用json.stringify转字符串,然后json.parse转对象, 但是function的话,在转换过程中会丢失那个function(就是声明类型,面试的时候不要解释) .</p></li><li><p>递归 </p><pre><code>var deepCopy = (obj) =&gt; {    var ret = {}    for (var key in obj) {        var value = obj[key]        ret[key] = typeof value === &#39;object&#39; ? deepCopy(value) : value    }    return ret}</code></pre></li><li><p>通过jQuery的extend方法实现深拷贝</p></li><li><p>Object.assign()拷贝</p></li><li><p>lodash函数库实现深拷贝 -&gt;lodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝</p></li></ul></li></ul><h4 id="12-es5和es6的区别"><a href="#12-es5和es6的区别" class="headerlink" title="12.es5和es6的区别"></a>12.es5和es6的区别</h4><ol><li>箭头函数 </li><li>字符串插值 ：字符串插值允许使用`` 插入字符串 ${}可以解析变量=&gt;模板字符串。  </li><li>let  const  ：  </li><li>类定义和继承： es6引入了对类class ， 构造函数constructor ,和extend的语言支持    class可以理解为是构造函数的另一种写法。类本身指向的就是构造函数。类中所有的方法都是定义在prototype上的， 没有变量提升。</li><li>for-of  ： 可以创建一个循环遍历可迭代对象的循环</li><li>promise： 解决回调地狱的方案</li><li>模块的导入与导出：  import  export default</li><li>拓展运算符 </li><li>解构赋值 =&gt; 用于对对象或数组快速取值 let [] =[]，等式两边属性一一对应，找不到的为undefind.</li><li>from 可以将对象转成数组</li></ol><h3 id="四-杂项"><a href="#四-杂项" class="headerlink" title="四 杂项"></a>四 杂项</h3><h4 id="1-数组操作"><a href="#1-数组操作" class="headerlink" title="1.数组操作"></a>1.数组操作</h4><ol><li>forEach()返回值是undefined，不可以链式调用。</li><li>map()返回一个新数组，原数组不会改变。</li><li>flat()默认只会拉平一层，flat（n）拉平n层，Infinity无限次,flat()会跳过空格,返回新数组不改变原数组</li><li>数组去重，3种方法<ul><li>遍历加indexof去重。 </li><li>for循环嵌套splice去重，     </li><li>es6 new Set去重（原理是通过map实现的）</li></ul></li><li>字符串截取的方法   <ul><li>slice（开始索引，结束索引） </li><li>substring(开始索引，结束索引，包头不包尾)，  </li><li>substr(开始索引，结束索引) </li><li>数组的  splice(下标， 删除个数，目标元素)</li></ul></li></ol><h4 id="2-抖动与防抖"><a href="#2-抖动与防抖" class="headerlink" title="2.抖动与防抖"></a>2.抖动与防抖</h4><p><strong>函数防抖</strong></p><blockquote><p>函数防抖是通过设置定时器，判断，当持续触发事件时，一定时间内没有再触发事件，事件处理函数才会执行一次，如果设定的延时到来之前又触发了事件，那么就重新开始延时.<br>作用: 作用在于限制浏览器发送请求的次数，减少服务器压力，</p></blockquote><p><strong>函数节流</strong>   </p><blockquote><p>函数节流是通过设置定时器加时间戳的模式来控制一定时间内只触发一次函数，原理是判断是否达到给定的时间来触发函数。</p></blockquote><p><code>区别</code>:两者的区别在于函数节流无论事件触发的多频繁，都会保证在规定时间内触发一次函数， 而函数防抖只是在最后一次事件后才触发一次函数。</p><h4 id="3-跨域解决方案"><a href="#3-跨域解决方案" class="headerlink" title="3.跨域解决方案"></a>3.跨域解决方案</h4><p><a href="https://juejin.im/entry/59b8fb276fb9a00a42474a6f" target="_blank" rel="noopener">转前端常见跨域解决方案（全）</a></p><ol><li>jsonp<blockquote><p>原理:主要是利用script标签的src属性不受同源策略影响，向后台发送get请求，并通过回调函数由服务器返回数据，实现跨域，先创建一个唯一的回调函数名，挂载到window属性上，然后创建一个script标签， 把src属性赋值url，然后通过请求之后执行挂载回调获取数据，再将回调删除，再将script删除。  就完成了一个jsonp的封装。</p></blockquote></li><li>cors(后端处理)</li><li>nginx反向代理(通过add_header处理添加一些响应头信息)</li></ol><h4 id="4-get和post区别"><a href="#4-get和post区别" class="headerlink" title="4.get和post区别"></a>4.get和post区别</h4><ul><li>get和post请求的区别在于， get请求需要将参数以？拼接在url后面，而post不需要。  </li><li>post请求需要设置一个请求头 content-type application x-www-form-urlencode,get使用默认请求头</li><li>post请求参数以&amp;拼接放入请求体中，上传给服务器。而get请求体中不传参或null,  </li><li>get 请求相较于post请求，安全性低。  </li><li>get请求对数据大小有4k的限制，而post没有明显限制</li></ul><p><code>put和post的区别</code> : put指定了资源在服务器的位置,而post没有  , put一般用于对资源的创建于修改.</p><h4 id="5-http状态码"><a href="#5-http状态码" class="headerlink" title="5.http状态码"></a>5.http状态码</h4><blockquote><p> 常见的状态码  200  请求成功，  302： 重定向  304： 文件未修改  400：请求语法错误，401：未授权  404： 找不到资源，405：访问不被允许  500 服务器错误。</p></blockquote><h4 id="6-浏览器的渲染原理？"><a href="#6-浏览器的渲染原理？" class="headerlink" title="6.浏览器的渲染原理？"></a>6.浏览器的渲染原理？</h4><p> 解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</p><h4 id="7-当输入地址，按下回车的时候，页面发生了什么？"><a href="#7-当输入地址，按下回车的时候，页面发生了什么？" class="headerlink" title="7.当输入地址，按下回车的时候，页面发生了什么？"></a>7.当输入地址，按下回车的时候，页面发生了什么？</h4><blockquote><p>进行域名解析，  先查看浏览器自身的DNS缓存，  然后查看操作系统本身的DNS缓存， 在查找本地host,最后再到DNS服务器。域名解析完成后，会 发起TCP的三次握手，建立TCP连接后发起http请求，服务器响应请求，浏览器获得html代码。之后浏览器解析代码，并将资源缓存。最后进行渲染。</p></blockquote><h4 id="8-媒体查询写法"><a href="#8-媒体查询写法" class="headerlink" title="8.媒体查询写法:"></a>8.媒体查询写法:</h4><p> <code>@media screen and (max-width:480px){.ads {display:none;}}</code></p><h4 id="9-事件委托"><a href="#9-事件委托" class="headerlink" title="9.事件委托"></a>9.事件委托</h4><blockquote><p>语法：element.addEventListener(event, function, useCapture)；</p></blockquote><ol><li>event:必须。字符串，指定事件名。 </li><li>不加’on’，如click function:必须。指定要事件触发时执行的函数。</li><li>useCapture：可选。布尔值，指定事件是否在捕获或冒泡阶段执行(true-事件句柄在捕获阶段执行；false-默认。事件句柄在冒泡阶段执行)。</li></ol><p><code>移除事件监听</code>：element.removeEventListener(event, function,useCapture) 匿名函数无法移出</p><h4 id="10-浏览器缓存"><a href="#10-浏览器缓存" class="headerlink" title="10.浏览器缓存"></a>10.浏览器缓存</h4><p><a href="https://juejin.im/post/5c417993f265da61285a6075" target="_blank" rel="noopener">转:浏览器缓存</a></p><h3 id="五-VUE"><a href="#五-VUE" class="headerlink" title="五 VUE"></a>五 VUE</h3><h4 id="1-vue源码原理"><a href="#1-vue源码原理" class="headerlink" title="1.vue源码原理"></a>1.vue源码原理</h4><blockquote><p><a href="https://cn.vuejs.org/v2/guide/instance.html?" target="_blank" rel="noopener">vue</a>的原理：主要是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。它是通过observer,compile ,watcher 三个模块来实现的。observer的核心是在数据变化时通过object.definePrototype(/)设置setter和getter，来通知watcher，watcher是observer和compile之间通信的桥梁，主要是调用update方法来触发compile中的回调，compile(使用document fragment操作节点)解析模版指令替换数据，并且为操作节点绑定更新函数，从而更新视图。</p></blockquote><h4 id="2-vue的生命周期"><a href="#2-vue的生命周期" class="headerlink" title="2. vue的生命周期"></a>2. vue的生命周期</h4><blockquote><p> vue的生命周期分为八个阶段,创建前创建后, 挂载前和挂载后, 更新前更新后, 销毁前销毁后.</p></blockquote><ul><li>创建阶段为beforecreate ,create      </li><li>挂载阶段为 beforemount和mounted   </li><li>更新阶段 为beforeupdate 和update   </li><li>销毁阶段为 beforedestroy和destroy </li></ul><p><strong>问题</strong></p><ol><li>创建阶段和挂载阶段有什么区别, create和mounted    :=&gt; create阶段不能操作DOM元素,因为此时el还没有挂载, 而mounted可以,</li><li>父组件的create阶段先执行还是子组件的create阶段先执行  :=&gt;  父组件的create先执行,  但是子组件的mounted阶段又比父组件的mounted先执行</li><li>个人理解:  在页面渲染的时候, 首先应该渲染父组件,所以先执行父组件的create, 而父组件里通常是有子组件的,那么这个时候,因为父组件本身的完整内容是包含子组件的,所以,可以想象 , 如果同时挂载多个子组件的话,那么,肯定要等到子组件渲染完成后, 父组件才能完整的挂载el完成. 因为 子组件是父组件的一部分,要渲染完成父组件,那么部分的组件肯定先比父组件完成挂载.  </li></ol><h4 id="3-vue中子组件传值给父组件-的三种方式"><a href="#3-vue中子组件传值给父组件-的三种方式" class="headerlink" title="3.vue中子组件传值给父组件 的三种方式"></a>3.vue中子组件传值给父组件 的三种方式</h4><ol><li><p>props配合$emit    父组件中必须要有 .sync修饰符  ，它的作用是当一个子组件改变一个prop的值的时候，这个变化会同步到父组件当中所绑定。</p></li><li><p>先在父组件methods中创建一个方法， 然后在子组件用自定义事件触发这个方法进行传值。   </p></li><li><p>v-model  配合 input 。（不推荐）</p><ul><li>===&gt;一般问完组件通信 :=&gt; 父传子:父组件声明变量,子组件使用props声明接收,<br>父:<code>&lt;child :msg=&quot;message&quot;&gt;&lt;/child&gt;</code> 子:<code>&lt;div&gt;&lt;/div&gt;</code></li><li>===&gt; 子传父的方式.   :=&gt; 先在父组件methods中创建一个方法<code>@msgFunc</code>， 然后在子组件用自定义事件触发这个 <code>this.$emit(&#39;msgFunc&#39;)</code>;方法进行传值。</li><li>===&gt;非父子 : <code>Bus.$emit(&#39;on&#39;, &#39;来自兄弟组件&#39;)</code>  -&gt;     <code>Bus.$on(&#39;on&#39;, (msg) =&gt; {  this.message = msg }) =&gt;msg = 来自兄弟组件</code></li></ul></li></ol><h4 id="4-vue组件间的传参方式"><a href="#4-vue组件间的传参方式" class="headerlink" title="4.vue组件间的传参方式"></a>4.vue组件间的传参方式</h4><ol><li><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex</a></p><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，<br>并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，<br>提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能</p></blockquote><ul><li>Vuex优缺点</li><li>优点<ol><li>解决了多层组件之间繁琐的事件传播。</li><li>解决了多组件依赖统同一状态的问题。</li><li>单向数据流</li><li>为Vue量身定做，学习成本不高</li></ol></li><li>缺点<ol><li>不能做数据持久化，刷新页面就要重制，要做数据持久化可以考虑使用localstorage。</li><li>增加额外的代码体积，简单的业务场景不建议使用</li></ol></li></ul></li></ol><ol start="2"><li><p>本地存储传值</p></li><li><p>路由传参 </p><ul><li><p>方案一<br>   getDescribe(id) {<br>   直接调用$router.push 实现携带参数的跳转</p><pre><code>   this.$router.push({   path: `/describe/${id}`,   })</code></pre><p>   }<br>   路由配置如下：</p><pre><code>{   path: &#39;/describe/:id&#39;,   name: &#39;Describe&#39;,   component: Describe</code></pre><p>   }</p></li><li><p>方案二 </p><pre><code>this.$router.push({ name: &#39;Describe&#39;, params(query): {      id: id }</code></pre><p>   })<br>   获取:<br>   this.$route.params(query).id</p></li></ul></li></ol><p><a href="https://blog.csdn.net/mf_717714/article/details/81945218?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-2" target="_blank" rel="noopener">路由传参params(query)区别</a></p><ul><li><p>方案三</p><pre><code> &lt;router-link :to=&quot;{path:&#39;/test&#39;,query: {name: id}}&quot;&gt;跳转&lt;/router-link&gt;</code></pre></li></ul><h4 id="5-router和-route有什么区别"><a href="#5-router和-route有什么区别" class="headerlink" title="5.$router和$route有什么区别"></a>5.$router和$route有什么区别</h4><blockquote><p>$route 是路由对象，负责解析url的hash值，主要用于获取几个属性（name,parmas,path,query），而 $router是路由实例对象，负责的是实现路由跳转功能。</p></blockquote><p>如何监听$route =&gt;  使用watch监听。$route(to){to.parmas.id}</p><h4 id="6-vue-router中hash模式与history模式的区别"><a href="#6-vue-router中hash模式与history模式的区别" class="headerlink" title="6. vue-router中hash模式与history模式的区别"></a>6. vue-router中hash模式与history模式的区别</h4><blockquote><p>vue-router有两种模式。一种是默认的hash模式，一种是history模式。<br>如何去除hash模式的# 在路由对象里写 mode:history</p></blockquote><p>   hash模式 原理是利用window监听hashchange事件，由hash改变的url都会被浏览器记录下来，浏览器的前进后退也可以对其控制，虽然没有请求服务器，但还是将页面和url一一关联起来了，这个就是hash模式，也是前端路由中，单页应用的标配。</p><p>   history模式，是利用H5新增的history interface中的history.pushState（） 和history.replaceState（） 来请求服务器（前端的url必须和实际向后端发起请求的url 一致）实现的，它会向服务器发送请求。 history模式在刷新和F5的时候会出现404错误，需要用nginx配置出错时</p><h4 id="7-vue杂项问题"><a href="#7-vue杂项问题" class="headerlink" title="7.vue杂项问题"></a>7.vue杂项问题</h4><ol><li>vue是单向绑定还是双向绑定？<br>vue是单向绑定的 ，  双向是指 view层和model数据层双向绑定，    而v-model只是双向绑定的一个语法糖。<br>组件和组件中是单向绑定的、</li><li><a href="https://www.jianshu.com/p/a7550c0e164f" target="_blank" rel="noopener">$nextTick是什么?</a><br>因为vue是异步更新的，$nextTick是用来知道什么时候DOM更新完成的</li><li><a href="https://www.cnblogs.com/Sherlock09/p/11023593.html" target="_blank" rel="noopener">vue-loader</a>是什么？<br>是解析和转换。vue文件的工具，作用是提取出可被浏览器识别的js代码</li><li>vue中<a href="https://www.jianshu.com/p/a6f741c7b500" target="_blank" rel="noopener"> keep-alive</a> 组件的作用<br><code>&lt;keep-alive&gt;</code>是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。<br>keep-alive：主要用于保留组件状态或避免重新渲染。<br>当二个组件被很频繁的调用的时候可以使用keep-alive标签进行缓存，这样页面就会从缓存中快速渲染，而不是重新渲染。</li><li><a href="https://segmentfault.com/a/1190000017752182?utm_source=tag-newest" target="_blank" rel="noopener"> vue-router如何响应 路由参数 的变化</a>？<br> 1.使用watch监听。  2. 使用beforeUpdate守卫</li><li><a href="https://www.cnblogs.com/shenjianping/p/11330126.html" target="_blank" rel="noopener">过滤器</a></li><li><a href="https://www.jianshu.com/p/088a7eb6de72" target="_blank" rel="noopener">Vue.mixin的作用（混入）</a><blockquote><p>将使用频率比较多的部分提取出来，定义一个对象可以包含任意组件选项。</p></blockquote></li></ol><p>　　 1. 使用时混入的对象会跟组件中的对象进行合并；<br>　　 2. 同名的钩子函数会合并成数组，先调用混入的钩子函数；<br>　　 3. 出现相同的属性或方法时会调用组件内的方法。</p><ol start="8"><li><p>router-link  高亮处理<br>1.使用类router-link-active<br>2.在路由中配置  linkActiveClass：‘类名’（类名为自定义样式）</p></li><li><p><a href="https://blog.csdn.net/qq_40958876/article/details/99822406?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">编程式导航</a><br>跳转：this.$router.push()  返回 :this.$router.back()  替换:this.$replace()    ===》  关于跳转和替换的区别在于 历史记录的问题， ：=》 跳转有历史记录，而替换没有。</p></li><li><p>/child  和child的区别<br>/child访问的路径是/child     而child访问的是  /parent/child</p></li><li><p>vue 左侧菜单展开隐藏重新渲染echars<br>加个监控=&gt; window.onresize</p></li><li><p>为什么vue中 data是个函数而不是个对象</p><blockquote><p>因为组件是可复用的vue实例。它有可能被多次复用，而组件中的data写成一个函数，数据以函数返回值的形式定义，这样每复用一次组件，就会返回一个新的data，类似于给每个组件实例创建了一个私有的数据空间，让各自组件维护自己的数据，互不影响。 而如果写成对象的形式，就使得所有组件都共用一份data，那么一个组件中改变就会造成所有的组件数据都会改变。</p></blockquote></li><li><p><a href="https://www.jianshu.com/p/52e6692639f5" target="_blank" rel="noopener">slot 插槽 </a></p><blockquote><p>作用是可以让父组件向子组件插入一些内容（包含html标签结构），并且也可以在父组件中拿到子组件的数据</p></blockquote><p>slot插槽有三种， 匿名插槽   具名插槽，和作用域插槽  </p><ol><li>匿名插槽 v-slot:default   只能有且只有一个</li><li>具名插槽  v-slot:名称    ，子组件使用slot标签插入时也要加上name属性</li><li>作用域插槽  v-slot：名字 = “数据名”  主要用于子组件数据被父组件获取。</li></ol></li><li><p>provice/inject 依赖注入<br>主要用于高阶插件/应用库提供用例，并不推荐在应用程序上使用， 。  它允许祖先组件向所有子孙组件注入依赖，<br>祖先组件使用provice声明变量，  子孙使用 inject注入依赖。</p></li><li><p>vue和jq的区别<br>vue和jq的区别在于控制反转，<br>jq是开发人员起主导作用，通过操作DOM,来进行数据修改<br>vue是框架起主导作用,  修改数据,vue会自己帮我们完成DOM操作</p></li><li><p><a href="https://www.cnblogs.com/jiajialove/p/11327945.html" target="_blank" rel="noopener">watch和computed 的区别</a></p></li></ol><ul><li>watch 一个数据响应多个数据</li><li>computed 一个数据受到多个数据的影响 有缓存<blockquote><p>在实现原理上watch和computed是差不多的，vue的data值在初始化阶段都会被挂载上watcher观察者模式，当数据改变的时候会先调用watcher观察者模式，然后调用计算属性，和监听属性。本质上来说没有多大区别</p></blockquote></li></ul><ol start="17"><li><a href="https://www.cnblogs.com/dianzan/p/12751087.html" target="_blank" rel="noopener">v-for和v-if不应该一起使用</a></li></ol><ul><li>原因：v-for比v-if优先，即每一次都需要遍历整个数组，影响速度。</li><li>解决: 在computed 里面使用,缓存v-show</li></ul><ol start="18"><li>spa 优缺点:<br><strong>优点:</strong><ol><li>良好的交互体验</li><li>良好的前后端工作分离模式</li><li>减轻服务器压力</li></ol><strong>缺点:</strong><ol><li>首屏加载慢</li><li>不利于SEO</li><li>不适合开发大型项目</li></ol></li><li>加载渲染过程<br><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</code></li><li>与React的区别　　</li></ol><ul><li><strong>相同点：</strong>　<ol><li>React采用特殊的JSX语法，Vue在组件开发中也推崇编写Vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用。</li><li>中心思想相同：一切都是组件，组件实例之间可以嵌套。</li><li>都提供合理的钩子函数，可以让开发者定制化地去处理需求。</li><li>都不内置列数Ajax，Route等功能的核心包，而是以插件的方式加载。</li><li>在组件开发中都支持mixins的特性。</li></ol></li><li>不同点：<ol><li>React依赖Virtual DOM，而Vue使用的是DOM模板，React采用的Virtual DOM会对渲染出来的结果做脏检查。</li><li>vue在模板中提供了指令，过滤器等，可以非常方便，开解的操作DOM</li></ol></li></ul><h3 id="六-前端性能优化及自身代码优化"><a href="#六-前端性能优化及自身代码优化" class="headerlink" title="六 前端性能优化及自身代码优化"></a>六 前端性能优化及自身代码优化</h3><ul><li><strong>前端性能优化：</strong> <ol><li>减少http请求次数 （可以合理设置缓存，资源压缩，比如精灵图，懒加载图片等）   </li><li>将样式文件引在前面，脚本文件引在最后。 不会造成阻塞其他资源加载。   </li><li>异步执行inline脚本  。因为浏览器在页面处理方面是单线程的，（多线程会出先分支增删同一元素的冲突问题）。   </li><li>避免重复的资源请求，减少不必要的http跳转</li></ol></li><li><strong>自身代码优化：</strong><ol><li>代码复用， </li><li>避免使用过多全局变量， </li><li>拆分函数避免函数过于臃肿，职责单一，</li><li>面向对象编程，对功能进行封装复用， </li><li>适当的注释，</li><li>内存管理。</li></ol></li></ul><blockquote><p>==&gt; 函数式编程，顾名思义，这种编程是以函数思维做为核心，在这种思维的角度去思考问题。<br> ==&gt;缺点 :所有的数据都是不可以改变的，严重占据运行资源，导致运行速度也不够快<br> ==&gt;面向对象编程：为了编写可以重用的代码导致许多无用代码的产生，并且许多人为了面向对象而面向对象导致代码给后期维护带来很多麻烦。<br>面向对象三大要素: 封装 继承 多态</p></blockquote><ul><li><p><strong>vue项目<code>性能优化</code>及<code>首屏性能优化</code></strong></p><ol><li>按需加载，  当前主流的ui框架都支持按需加载</li><li>服务端代码压缩   gzip</li><li>代码分块</li><li>路由组件懒加载 <code>const HelloWorld = ()=&gt;import(&quot;@/components/HelloWorld&quot;)</code></li><li>图片懒加载/服务端渲染（ssr）</li></ol><p><a href="https://www.jianshu.com/p/2c929f211d08" target="_blank" rel="noopener">进阶版首屏优化</a></p></li></ul><h3 id="七-webpack"><a href="#七-webpack" class="headerlink" title="七 webpack"></a>七 webpack</h3><h4 id="1-打包优化"><a href="#1-打包优化" class="headerlink" title="1. 打包优化"></a>1. 打包优化</h4><p><a href="https://segmentfault.com/a/1190000011138081?utm_source=tag-newest" target="_blank" rel="noopener">转:webpack打包优化解决方案</a></p><h4 id="2-配置生产测试环境"><a href="#2-配置生产测试环境" class="headerlink" title="2. 配置生产测试环境"></a>2. 配置生产测试环境</h4><p><a href="https://blog.csdn.net/xhjfor/article/details/80796801" target="_blank" rel="noopener">转:webpack实现开发、测试、生产等环境的打包切换</a></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>未完待续,持续更新中……</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零搭建前端组件库</title>
      <link href="/2020/03/28/cong-ling-da-jian-qian-duan-zu-jian-ku/"/>
      <url>/2020/03/28/cong-ling-da-jian-qian-duan-zu-jian-ku/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>在前端开发中可能会遇到将相同的功能模板集合成一个组件，供他人调用，这样可以减少重复造轮子，也可以节约人力、财力，更能够提高代码的可维护度；下面将通过详细的步骤教你如何构建一个 Vue 前端组件。。</p></blockquote><h2 id="1、在本机上安装好-NodeJs，并配置好环境变量"><a href="#1、在本机上安装好-NodeJs，并配置好环境变量" class="headerlink" title="1、在本机上安装好 NodeJs，并配置好环境变量"></a>1、在本机上安装好 NodeJs，并配置好环境变量</h2><ul><li><p><code>下载</code> : <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Nodejs地址</a></p><p>我这里是下载 64 位 Windows 安装包(.msi)，大家可以根据自己电脑系统选择相应的版本即可。</p><p><img src="1.png" alt></p></li><li><p>下载 NodeJs 后双击它，采用默认设置，一直点击下一步，直到 Finish 为止。需要说明的是，在安装 NodeJs 时，已经设置好了系统环境变量，此外 npm 工具也同时被安装好了，我们可以在 cmd 窗口中输入 node -v 命令和 npm -v 命令查看，若都安装成功了话，会看到如下的效果：</p></li></ul><p><img src="2.png" alt></p><h2 id="2、vue-项目安装-如已安装，可略过此步骤"><a href="#2、vue-项目安装-如已安装，可略过此步骤" class="headerlink" title="2、vue 项目安装(如已安装，可略过此步骤)"></a>2、vue 项目安装(如已安装，可略过此步骤)</h2><ul><li><p>创建一个 Vue 项目(使用默认配置安装就 OK)</p><pre class="line-numbers language-js"><code class="language-js">    vue create ui<span class="token operator">-</span>demo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装 babel-plugin-component</p><pre class="line-numbers language-js"><code class="language-js">    npm i babel<span class="token operator">-</span>plugin<span class="token operator">-</span>component <span class="token operator">-</span>D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><code>babel-plugin-component</code> 就是 <code>Element UI</code> 用来实现组件按需加载的一个 <code>babel</code> 插件。我们把它用到我们的组件库上，就不需要重新造一个轮子出来了.</p><ul><li><p>在项目的根目录下创建一个 .babelrc 的文件，配置可以参照下面的代码进行更改。</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token punctuation">{</span> <span class="token string">"plugins"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token punctuation">[</span>           <span class="token string">"component"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>           <span class="token string">"libraryName"</span><span class="token punctuation">:</span> <span class="token string">"ui-demo"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 组件库的名字，需要和 package.json 里的 name 相同 </span>          <span class="token string">"libDir"</span><span class="token punctuation">:</span> <span class="token string">"components"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 存放组件的文件夹，如果不想配置此项，默认文件夹的名字为 lib</span>    <span class="token punctuation">}</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建一个存放组件的文件夹 </p></li></ul><blockquote><p>既然我们刚刚已经配置了存放组件的文件夹，下一步肯定就是创建这么一个文件夹了。由于我配置了的文件夹名为 components，所以我们的文件夹名字就是 components。</p></blockquote><ul><li>上面的操作完成后，我们的项目目录就基本搭建好了，如下：</li><li>写组件终于到了写组件的时候了，在<code>components</code> 文件夹下新建一个 <code>Component1</code> 的文件夹来存放我们的第一个组件。</li><li><code>Component1</code> 文件夹里有一个<code>Component1.vue</code> 的文件和一个 <code>index.js</code> 文件。目录如下：<br>Component1 -&gt; Component1.vue 代码:<pre class="line-numbers language-js"><code class="language-js">    <span class="token operator">&lt;</span>template<span class="token operator">></span>     <span class="token operator">&lt;</span>h1 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"component1"</span><span class="token operator">></span>component1<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>     <span class="token operator">&lt;</span>script<span class="token operator">></span>     <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Component1'</span> <span class="token punctuation">}</span>     <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span>style<span class="token operator">></span>    <span class="token punctuation">.</span>component1 <span class="token punctuation">{</span> color<span class="token punctuation">:</span> green<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>Component1 -&gt; index.js代码：</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> Component1 <span class="token keyword">from</span> <span class="token string">'./Component1.vue'</span><span class="token punctuation">;</span>Component1<span class="token punctuation">.</span>install <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span>Component1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> Component1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span><span class="token keyword">default</span> Component1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>index.js 中的主要功能就是以插件的形式注册一个全局组件，不懂的小伙伴可以照猫画虎，微调一下就好了。<br>第二个组件代码就不发出来了，复制一份，给个 css 样式就好了。</p><p>在 components 文件夹根目录下创建一个 index.js 用来整合所有组件。<br>components -&gt; index.js 代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> Compontent1 <span class="token keyword">from</span> <span class="token string">'./Component1/index'</span><span class="token keyword">import</span> Compontent2 <span class="token keyword">from</span> <span class="token string">'./Component2/index'</span><span class="token keyword">const</span> components <span class="token operator">=</span> <span class="token punctuation">[</span>Compontent1<span class="token punctuation">,</span> Compontent2<span class="token punctuation">,</span> <span class="token punctuation">]</span><span class="token keyword">function</span> <span class="token function">install</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    components<span class="token punctuation">.</span>map <span class="token operator">=</span> <span class="token punctuation">(</span>component <span class="token operator">=</span> <span class="token operator">></span><span class="token punctuation">{</span>        Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span>component<span class="token punctuation">.</span>name<span class="token punctuation">,</span> component<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> window<span class="token punctuation">.</span>Vue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">install</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>Vue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span><span class="token keyword">default</span> <span class="token punctuation">{</span>        install<span class="token punctuation">,</span>        Compontent1<span class="token punctuation">,</span>        Compontent2<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>稍微提醒，需要把 install 也一起导出，观察不细心的可能会不注意就写漏了。</p></blockquote><h2 id="3、修改或添加-package-json-中的配置"><a href="#3、修改或添加-package-json-中的配置" class="headerlink" title="3、修改或添加 package.json 中的配置"></a>3、修改或添加 package.json 中的配置</h2><ul><li><code>script</code> 中添加一条命令：<pre class="line-numbers language-js"><code class="language-js">   <span class="token string">"lib"</span><span class="token punctuation">:</span> <span class="token string">"vue-cli-service build --target lib --name index --dest package components/index.js"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>最后面的 <code>components/index.js</code> 是我们存放组件文件夹根目录的<code>index.js</code> 文件，记得根据你的情况修改。这个命令执行后，会打包生成一个 <code>package</code> 的文件夹。</p><p>添加 <code>files</code> 白名单，打包上传哪些文件到 <code>npm</code> 上：</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token string">"files"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token string">"components"</span><span class="token punctuation">,</span>      <span class="token string">"package"</span>      <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>添加 <code>style</code>，设置样式路径：</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token string">"style"</span><span class="token punctuation">:</span> <span class="token string">"package/index.css"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>路径就是我们打包出来的 package 中的 index.css 文件。</p><ul><li>添加 main，设置入口：<pre class="line-numbers language-js"><code class="language-js"><span class="token string">"main"</span><span class="token punctuation">:</span> <span class="token string">"components/index.js"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>路径是存放组件的 components 文件夹下的 index.js 文件。<br>将 private 设置为 false：</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token string">"private"</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置此项目不是私有项目之后，才能发布好 npm 上。</p><p>下面的是完整的 package.json 文件配置：</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token punctuation">{</span>    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"ui-demo"</span><span class="token punctuation">,</span>    <span class="token string">"version"</span><span class="token punctuation">:</span> <span class="token string">"0.1.0"</span><span class="token punctuation">,</span>    <span class="token string">"private"</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token string">"main"</span><span class="token punctuation">:</span> <span class="token string">"components/index.js"</span><span class="token punctuation">,</span>    <span class="token string">"style"</span><span class="token punctuation">:</span> <span class="token string">"package/index.css"</span><span class="token punctuation">,</span>    <span class="token string">"files"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"components"</span><span class="token punctuation">,</span> <span class="token string">"package"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"serve"</span><span class="token punctuation">:</span> <span class="token string">"vue-cli-service serve"</span><span class="token punctuation">,</span>        <span class="token string">"build"</span><span class="token punctuation">:</span> <span class="token string">"vue-cli-service build"</span><span class="token punctuation">,</span>        <span class="token string">"lint"</span><span class="token punctuation">:</span> <span class="token string">"vue-cli-service lint"</span><span class="token punctuation">,</span>        <span class="token string">"lib"</span><span class="token punctuation">:</span> <span class="token string">"vue-cli-service build --target lib --name index --dest package components/index.js"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"dependencies"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"core-js"</span><span class="token punctuation">:</span> <span class="token string">"^2.6.5"</span><span class="token punctuation">,</span>        <span class="token string">"vue"</span><span class="token punctuation">:</span> <span class="token string">"^2.6.10"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"devDependencies"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"@vue/cli-plugin-babel"</span><span class="token punctuation">:</span> <span class="token string">"^3.7.0"</span><span class="token punctuation">,</span>        <span class="token string">"@vue/cli-plugin-eslint"</span><span class="token punctuation">:</span> <span class="token string">"^3.7.0"</span><span class="token punctuation">,</span>        <span class="token string">"@vue/cli-service"</span><span class="token punctuation">:</span> <span class="token string">"^3.7.0"</span><span class="token punctuation">,</span>        <span class="token string">"babel-eslint"</span><span class="token punctuation">:</span> <span class="token string">"^10.0.1"</span><span class="token punctuation">,</span>        <span class="token string">"babel-plugin-component"</span><span class="token punctuation">:</span> <span class="token string">"^1.1.1"</span><span class="token punctuation">,</span>        <span class="token string">"eslint"</span><span class="token punctuation">:</span> <span class="token string">"^5.16.0"</span><span class="token punctuation">,</span>        <span class="token string">"eslint-plugin-vue"</span><span class="token punctuation">:</span> <span class="token string">"^5.0.0"</span><span class="token punctuation">,</span>        <span class="token string">"vue-template-compiler"</span><span class="token punctuation">:</span> <span class="token string">"^2.5.21"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"eslintConfig"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"root"</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"env"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">"node"</span><span class="token punctuation">:</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token string">"extends"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"plugin:vue/essential"</span><span class="token punctuation">,</span> <span class="token string">"eslint:recommended"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token string">"rules"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token string">"parserOptions"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">"parser"</span><span class="token punctuation">:</span> <span class="token string">"babel-eslint"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"postcss"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"plugins"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">"autoprefixer"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"browserslist"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"> 1%"</span><span class="token punctuation">,</span> <span class="token string">"last 2 versions"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、打包我们的代码"><a href="#4、打包我们的代码" class="headerlink" title="4、打包我们的代码"></a>4、打包我们的代码</h2><p>在控制台执行 <code>npm run lib</code> 进行文件打包，打包完成后会多一个 <code>package</code> 文件夹。文件目录就变成如下的了：<br><img src="7.webp" alt></p><h2 id="5、发布-npm-公库"><a href="#5、发布-npm-公库" class="headerlink" title="5、发布 npm(公库)"></a>5、发布 npm(公库)</h2><pre class="line-numbers language-js"><code class="language-js">      <span class="token comment" spellcheck="true">// 这是登录，前提是你已经在 npm 注册了账号</span>      npm login      <span class="token comment" spellcheck="true">// 发布到 npm</span>      npm publish      <span class="token comment" spellcheck="true">// 安装库</span>      npm i ui<span class="token operator">-</span>demo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、发布-npm-私库"><a href="#6、发布-npm-私库" class="headerlink" title="6、发布 npm(私库)"></a>6、发布 npm(私库)</h2><p>首先需要在服务器上搭建一个私库,这里推荐一个:<a href="https://www.jianshu.com/p/d32ce7e9d4d8" target="_blank" rel="noopener">npm私服搭建—verdaccio方案及其最佳实践</a></p><p>建立好私库后,登录、打包跟上面步骤一样,发布时需要使用<code>nrm</code>命令 <code>nrm use xxx</code>(切换到私库地址),如图所示:<br><img src="7.png" alt></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 发布</span>  npm publish<span class="token comment" spellcheck="true">//  npm 安装</span>  npm i  ui<span class="token operator">-</span>demo  <span class="token operator">--</span>registry 私库地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>这样我们就可以使用我们自己的 UI 库了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见面试题总结基础篇</title>
      <link href="/2020/01/30/chang-jian-mian-shi-ti-zong-jie-ji-chu-pian/"/>
      <url>/2020/01/30/chang-jian-mian-shi-ti-zong-jie-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=525278524&auto=1&height=66"></iframe></div><p>闲来无事，随便写写 ……</p><h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>总结一下面试遇到的问题，为了方便自己查阅，也希望对小伙伴们有所帮助！</p></blockquote><h3 id="1-介绍上家公司项目"><a href="#1-介绍上家公司项目" class="headerlink" title="1.介绍上家公司项目"></a>1.介绍上家公司项目</h3><p>近期一直在做一个 xxx 中心的项目，xxx<br>页面缓存的坑。有个填写信息的页面，需要填写一部分信息，进入查新协<br>议页面，返回的时候，页面上填写的信息还需要留存。 解决办法：使用 vue 提<br>供的 keep-alive，来完成页面的缓存的</p><h3 id="2-待优化项目"><a href="#2-待优化项目" class="headerlink" title="2.待优化项目"></a>2.待优化项目</h3><p>1.首页白屏 – 骨架屏<br>2.页面更新版本缓存 — 将获取连接的 templateId 写在 Home 页面<br>3.常见的 8 种移动端界面布局方式包括 8 种：.<br>1、列表式布局. 2、宫格式布局. 3、仪表布局. 4、卡片布局<br>5、瀑布流布局. 6、Gallery 布局. 7、手风琴布局. 8、多面板布局<br>4.PC 端的布局方式 总共有 6 大 布局方式 ：<br>双飞翼、多栏、弹性、流式、瀑布流、响应式 布局</p><h3 id="3-Vue-和-React-的-区别"><a href="#3-Vue-和-React-的-区别" class="headerlink" title="3.Vue 和 React 的 区别"></a>3.Vue 和 React 的 区别</h3><p>1，react 整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数<br>传入，所以在 react 中，是单向数据流；<br>2，vue 的思想是响应式的，是基于是数据可变的，通过对每一个属性 Watcher<br>来监听，当属性变化的时候，响应式的更新对应的虚拟 dom。<br>3，vue 表单可以使用 v-model 支持双向绑定，相比于 react 来说开发更简单。<br>4，改变数据的方式不同。react 需要通过 setState<br>5，react 使用 jsx，有一定的上手成本，并且需要一整套工具链支持。vue<br>使用模版语法，完全脱离工具链。</p><h3 id="4-react-的优势"><a href="#4-react-的优势" class="headerlink" title="4.react 的优势"></a>4.react 的优势</h3><p>1.React 速度很快：它并不直接对 DOM 进行操作，引入了一个叫做虚拟 DOM 的概念，安插在 javascript 逻辑和实际的 DOM 之间，性能好。</p><ol start="2"><li>跨浏览器兼容：虚拟 DOM 帮助我们解决了跨浏览器问题，它为我们提供了 标准化的 API，甚至在 IE8 中都是没问题的。 </li><li>一切都是 component：代码更加模块化，重用代码更容易，可维护性高。 </li><li>单向数据流：Flux 是一个用于在 JavaScript 应用中创建单向数据层的架 构，它随着 React 视图库的开发而被 Facebook 概念化。 </li><li>同构、纯粹的 javascript：因为搜索引擎的爬虫程序依赖的是服务端响应 而不是 JavaScript 的执行，预渲染你的应用有助于搜索引擎优化。 </li><li>兼容性好：比如使用 RequireJS 来加载和打包，而 Browserify 和 Webpack 适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。</li></ol><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>未完待续,持续更新中……</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见面试题集合</title>
      <link href="/2020/01/30/chang-jian-mian-shi-ti-ji-he/"/>
      <url>/2020/01/30/chang-jian-mian-shi-ti-ji-he/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=525278524&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>总结一下面试遇到的问题，为了方便自己查阅，也希望对小伙伴们有所帮助！</p></blockquote><h3 id="一-HTML"><a href="#一-HTML" class="headerlink" title="一 HTML"></a>一 HTML</h3><ul><li>HTML 语义化就是让页面内容结构化，它有如下优点</li></ul><ul><li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</li><li>有利于 SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li><li>方便其他设备解析，如盲人阅读器根据语义渲染网页</li><li>有利于开发和维护，语义化更具可读性，代码更好维护，与 CSS3 关系更和谐</li></ul><p>如：</p><pre><code>&lt;header&gt;代表头部&lt;nav&gt;代表超链接区域&lt;main&gt;定义文档主要内容&lt;article&gt;可以表示文章、博客等内容&lt;aside&gt;通常表示侧边栏或嵌入内容&lt;footer&gt;代表尾部</code></pre><ul><li>HTML5 新标签</li></ul><p><code>有&lt;header&gt;、&lt;footer&gt;、&lt;aside&gt;、&lt;nav&gt;、&lt;video&gt;、&lt;audio&gt;、&lt;canvas&gt;等...</code></p><h3 id="二-CSS"><a href="#二-CSS" class="headerlink" title="二 CSS"></a>二 CSS</h3><ul><li><p>盒子模型<br>盒模型分为标准盒模型和怪异盒模型(IE 模型)</p><ul><li>标准盒模型 :在标准的盒子模型中，width 指 content 部分的宽度</li><li>IE 盒模型: 在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度</li></ul></li><li><p>rem 与 em 的区别</p></li></ul><blockquote><p>rem 是根据根的 font-size 变化，而 em 是根据父级的 font-size 变化</p></blockquote><ul><li><p>CSS 选择器<br>通配符：*<br>ID 选择器：#ID<br>类选择器：.class<br>元素选择器：p、a 等<br>后代选择器：p span、div a 等<br>伪类选择器：a:hover 等<br>属性选择器：input[type=”text”] 等</p><blockquote><p>权重 !important -&gt; 行内样式 -&gt; #id -&gt; .class -&gt; 元素和伪元素 -&gt; * -&gt; 继承 -&gt; 默认</p></blockquote></li><li><p>CSS 新特性<br>transition：过渡<br>transform：旋转、缩放、移动或者倾斜<br>animation：动画<br>gradient：渐变<br>shadow：阴影<br>border-radius：圆角</p></li><li><p>css 命名长短 优缺点<br>性能分为下载性能(速度)和渲染性能，大家认为：</p></li></ul><ol><li>下载性能可能是短命名略胜一筹，因为文件会稍小些；</li><li>渲染性能则是长命名好些，因为 CSS 中通常短命名我们用类似.box .hd {}定义样式，而长命名直接是.box-hd {}，pagespeed 认为选择器长度会影响渲染性能。<br>(注：其实平时工作中这两点都会被忽略。gzip 可以进一步减少第一个问题的差距，而由此引发的渲染性能也是微乎其微)</li></ol><p>然后大家就可维护性进行了讨论，这次支持长命名的人较多。</p><ol><li><p>长命名给人较为可靠的感觉；</p></li><li><p>长命名较短命名发生冲突的几率低很多；</p></li><li><p>可复用的内容通过短命名定义，无可争议；<br>…<br>最后是使用场景，玉伯借用 YAHOO 首页的例子牵头，大家讨论，总结如下：(主要依据可维护性)</p></li><li><p>框架级样式用短命名，比如盒模型、栅格；</p></li><li><p>通用样式用短命名，比如.hidden、.clearfix；</p></li><li><p>应用级样式用长命名，比如淘江湖项目的通用样式都加上“sns”前缀(有.sns-avatar、.sns-box 等)；</p></li><li><p>页面级样式用长命名，比如类目模块，可能包含 category-hd、category-bd、category-bd-tips 等；</p></li><li><p>嵌入式应用用长命名，因为可能会被嵌入到任何复杂环境中，比如开源编辑器、Google 的各种应用(map, adsence, gmail…)</p></li></ol><ul><li><p>如何垂直水平居中一个 div</p><ul><li>div 绝对定位水平垂直居中【Transforms 变形】</li><li>flex display:flex;<br>justify-content:center;<br>align-items:center;</li><li>将父盒子设置为 table-cell 元素，可以使用 text-align:center 和 vertical-align:middle 实现水平、垂直居中。</li><li>比较完美的解决方案是利用三层结构模拟父子结构</li></ul></li><li><p>less /scss 优点:</p></li></ul><ol><li>支持嵌套</li><li>支持变量定义</li><li>支持“模板函数”（自己定义的名称。。。），比如有些 CSS 需要做兼容前缀的话，你可以这样使用一个模板函数定义一下，调用的时候传入正常值就可以了。会自动生成前缀的 CSS</li></ol><ul><li><p>多行元素的文本省略号</p><pre><code>overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical</code></pre></li><li><p>flex 布局实现 div 均分自动换行<br>flex-wrap: wrap</p></li></ul><h3 id="三-JavaScript"><a href="#三-JavaScript" class="headerlink" title="三 JavaScript"></a>三 JavaScript</h3><p><strong>JS 的几条基本规范</strong></p><blockquote><p>1、不要在同一行声明多个变量<br>2、请使用===/！==来比较 true/false 或者数值<br>3、使用对象字面量替代 new Array 这种形式<br>4、不要使用全局变量<br>5、Switch 语句必须带有 default 分支<br>6、函数不应该有时候有返回值，有时候没有返回值<br>7、For 循环必须使用大括号<br>8、IF 语句必须使用大括号<br>9、for-in 循环中的变量 应该使用 var 关键字明确限定作用域，从而避免作用域污染</p></blockquote><h4 id="1-JS-的基本数据类型与复杂数据类型"><a href="#1-JS-的基本数据类型与复杂数据类型" class="headerlink" title="1.JS 的基本数据类型与复杂数据类型"></a>1.JS 的基本数据类型与复杂数据类型</h4><ul><li><p>基本数据类型存储在栈中，引用数据类型存储在堆中，引用地址存放在栈内，</p></li><li><p>将基本数据存储在栈中是因为它们占据的空间是固定的，更有利于迅速查询变量的值，</p></li><li><p>==&gt;为什么引用数据类型不放在栈中, :=&gt;由于引用数据类型大小不固定，如果存放在栈中会降低变量的搜索效率(栈内存主要是根据程序逻辑明确申请的内存，所以也会变相降低程序逻辑处理效率。)</p></li><li><p>引用数据类型大小衡量通过占用内存的大小， 在进行比较的时候比较的是引用地址。</p></li><li><p>基本数据类型有哪些?</p></li></ul><ul><li>六种 <code>number  string  boolean   undefind  null   es6新增的symbol</code> ,</li></ul><ul><li>复杂数据类型有哪些?</li></ul><ul><li><code>object,  Array,function</code></li></ul><ul><li>什么是 symbol?</li></ul><blockquote><p>一般问到了基本数据类型种类,你说了 symbol 的话,肯定会问 symbol, :=&gt; symbol 不能使用 new,它生成的也是原始数据类型的值, 它生成的数据都是独一无二的.(就算 symbol 里的变量值相同,那也是两个数据值. symbol.for 和 symbol 的区别在于 symbol.for 会先查找有没有这个 key 值,有则直接返回,没有才会创建.)</p></blockquote><blockquote><p>一般问到基本数据类型,就会问检测复杂数据类型的方法</p></blockquote><ul><li>基本数据类型可以用 typeof 检测,对复杂数据类型都是返回 object,但是 fucntion 是特例,会返回 function.</li><li>判断复杂数据类型可以用 instandof,(instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上)</li><li>还可以借用 object 原型上的 tostring 方法,从后往前截取大概 8 位.</li></ul><h4 id="2-数组操作"><a href="#2-数组操作" class="headerlink" title="2.数组操作"></a>2.数组操作</h4><pre><code>map: 遍历数组，返回回调返回值组成的新数组forEach: 无法break，可以用try/catch中throw new Error来停止filter: 过滤some: 有一项返回true，则整体为trueevery: 有一项返回false，则整体为falsejoin: 通过指定连接符生成字符串push / pop: 末尾推入和弹出，改变原数组， 返回推入/弹出项【有误】unshift / shift: 头部推入和弹出，改变原数组，返回操作项【有误】sort(fn) / reverse: 排序与反转，改变原数组concat: 连接数组，不影响原数组， 浅拷贝slice(start, end): 返回截断后的新数组，不改变原数组splice(start, number, value...): 返回删除元素组成的数组，value 为插入项，改变原数组indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值，cur 为当前值(从第二项开始)</code></pre><h4 id="3-JS-有哪些内置对象"><a href="#3-JS-有哪些内置对象" class="headerlink" title="3.JS 有哪些内置对象"></a>3.JS 有哪些内置对象</h4><pre><code>Object是JavaScript中所有对象的父对象数据封装对象：Object、Array、Boolean、Number和String其他对象：Function、Arguments、Math、Date、RegExp、Error</code></pre><h4 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h4><p><strong>什么是闭包</strong></p><blockquote><p>函数 A 里面包含了 函数 B，而 函数 B 里面使用了 函数 A 的变量，那么 函数 B 被称为闭包。(闭包就是能够读取其他函数内部变量的函数)</p></blockquote><pre><code>function A() {var a = 1;function B() {    console.log(a);}return B();}</code></pre><p><strong>闭包的特征</strong></p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收制回收</li></ul><p><strong>对闭包的理解</strong></p><blockquote><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在 js 中，函数即闭包，只有函数才会产生作用域的概念</p></blockquote><p><strong>闭包的优缺点</strong></p><ul><li>优点: 能够实现封装和缓存等</li><li>缺点: 就是消耗内存、不正当使用会造成<a href="https://blog.csdn.net/weixin_41989325/article/details/102808390" target="_blank" rel="noopener">内存泄露</a>的问题</li></ul><h4 id="5-JS-作用域及作用域链"><a href="#5-JS-作用域及作用域链" class="headerlink" title="5.JS 作用域及作用域链"></a>5.JS 作用域及作用域链</h4><blockquote><p>在 JavaScript 中，作用域分为 <code>全局作用域</code> 和 <code>函数作用域</code></p></blockquote><ul><li>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值,但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。<br><img src="zyy.jpg" alt></li></ul><h4 id="6-原型和原型链"><a href="#6-原型和原型链" class="headerlink" title="6.原型和原型链"></a>6.原型和原型链</h4><p><strong>概念</strong></p><blockquote><p>每个对象都会在其内部初始化一个属性，就是 prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype，于是就这样一直找下去</p></blockquote><p><strong>完整版原型链</strong></p><p><a href="https://blog.csdn.net/u011313703/article/details/78343108" target="_blank" rel="noopener">完整原型链详细图解（构造函数、原型、实例化对象）</a><br><img src="yxl.jpg" alt></p><h4 id="7-组件化和模块化"><a href="#7-组件化和模块化" class="headerlink" title="7.组件化和模块化"></a>7.组件化和模块化</h4><ul><li>组件化优点: 专一、可配置性、标准性、复用性、可维护性</li><li>模块化优点: 避免变量污染、命名冲突、提高代码复用率、提高了可维护性、方便依赖关系管理</li></ul><h4 id="8-图片的预加载和懒加载"><a href="#8-图片的预加载和懒加载" class="headerlink" title="8.图片的预加载和懒加载"></a>8.图片的预加载和懒加载</h4><ul><li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染</li><li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数</li></ul><h4 id="9-实例化-new-与不-new-的区别"><a href="#9-实例化-new-与不-new-的区别" class="headerlink" title="9.实例化 new 与不 new 的区别"></a>9.实例化 new 与不 new 的区别</h4><blockquote><p>简单来说，就是， new 是通过调用构造函数 Function 来创建函数 ，没有 return 会返回一个对象,不 new 只是调用函数把返回值赋值变量。 没有 return 就返回 undefind</p></blockquote><p>null 和 undefind 的区别 :=&gt; null 用来表示尚未存在的对象, undefind 表示还没有赋值. null 转数值为 0, undefind 转数值为 nan.</p><h4 id="10-什么是-promise"><a href="#10-什么是-promise" class="headerlink" title="10.什么是 promise"></a>10.什么是 promise</h4><blockquote><p>一句话概括 promise : Promise 对象用于异步操作,他表示一个尚未完成切预计在未来会完成的异步操作.</p></blockquote><p><strong>promise 是什么?</strong></p><ul><li>promise 是 es6 提供的一种解决回调地狱的方案,它是一个容器,内部存放着某个异步操作的结果,并且提供统一的 api 进行操作,</li><li>它本身有<code>all,resolve,pending,reject,</code> 原型上有 then,catch 方法, <code>缺点</code>在于,一旦建立,就无法取消</li></ul><p><strong>回调地狱解决方案</strong></p><ul><li>promise</li><li>async/await</li><li>generator</li></ul><h4 id="11-对-This-对象的理解"><a href="#11-对-This-对象的理解" class="headerlink" title="11.对 This 对象的理解"></a>11.对 This 对象的理解</h4><ul><li>普通函数的 this 指向大致分为几种:</li></ul><ul><li>指向 window 的 -&gt;普通函数调用和定时器，</li><li>指向实例化对象的 -&gt;构造函数，</li><li>指向事件处理对象的 -&gt;事件函数。</li><li>箭头函数是 es6 新增的特性，它不能用作构造函数，也没有自己的 this,argument,super 或 new.target.它只会从自己的作用域链的上一层继承 this，也就是沿用外一层的 this 指向。</li></ul><ul><li>定时器中的 this 是指向 window 的,那么如果对定时器的 function 改造成箭头函数的话, 它的指向是什么? :=&gt; 沿用作用域上一层的 this,</li><li>那么怎么去固定定时器中的 this :=&gt;古老的方法: var that = this 工作中常用的方法 .bind(this) ( 参见贪吃蛇中绑定 this 的方法)</li></ul><h4 id="12-浅拷贝和深拷贝的区别"><a href="#12-浅拷贝和深拷贝的区别" class="headerlink" title="12.浅拷贝和深拷贝的区别"></a>12.浅拷贝和深拷贝的区别</h4><blockquote><p>简单点来说，就是假设 B 复制了 A，当修改 A 时，看 B 是否会发生变化，如果 B 也跟着变了，说明这是浅拷贝，拿人手短，如果 B 没变，那就是深拷贝，自食其力赋值。</p></blockquote><p>在引用类型中，只是赋值了指针， 并没有创建对象空间,而浅拷贝和深拷贝都会创建一个新对象只是说浅拷贝的对象是引用类数据的第一层引用 ，拷贝第一层级，指针依然指向引用数据，引用数据内部改变，浅拷贝对象也会发生改变。深拷贝是完全创建一个新对象，拷贝所有层级，复制内部所有结构。两者互不影响.</p><ul><li>怎么完成一个浅拷贝</li></ul><ul><li>用 es6 的 spread 操作符 …obj</li></ul><ul><li>怎么用简单的方法实现一个深拷贝</li></ul><ul><li><p>用 json.stringify 转字符串,然后 json.parse 转对象, 但是 function 的话,在转换过程中会丢失那个 function(就是声明类型,面试的时候不要解释) .</p></li><li><p>递归</p><pre><code> var deepCopy = (obj) =&gt; {     var ret = {}     for (var key in obj) {         var value = obj[key]         ret[key] = typeof value === &#39;object&#39; ? deepCopy(value) : value     }     return ret }</code></pre></li><li><p>通过 jQuery 的 extend 方法实现深拷贝</p></li><li><p>Object.assign()拷贝</p></li><li><p>lodash 函数库实现深拷贝 -&gt;lodash 很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝</p></li></ul><h4 id="12-es5-和-es6-的区别"><a href="#12-es5-和-es6-的区别" class="headerlink" title="12.es5 和 es6 的区别"></a>12.es5 和 es6 的区别</h4><ol><li>箭头函数</li><li>字符串插值 ：字符串插值允许使用`` 插入字符串 ${}可以解析变量=&gt;模板字符串。</li><li>let const ：</li><li>类定义和继承： es6 引入了对类 class ， 构造函数 constructor ,和 extend 的语言支持 class 可以理解为是构造函数的另一种写法。类本身指向的就是构造函数。类中所有的方法都是定义在 prototype 上的， 没有变量提升。</li><li>for-of ： 可以创建一个循环遍历可迭代对象的循环</li><li>promise： 解决回调地狱的方案</li><li>模块的导入与导出： import export default</li><li>拓展运算符</li><li>解构赋值 =&gt; 用于对对象或数组快速取值 let [] =[]，等式两边属性一一对应，找不到的为 undefind.</li><li>from 可以将对象转成数组</li></ol><h3 id="四-杂项"><a href="#四-杂项" class="headerlink" title="四 杂项"></a>四 杂项</h3><h4 id="1-数组操作"><a href="#1-数组操作" class="headerlink" title="1.数组操作"></a>1.数组操作</h4><ol><li>forEach()返回值是 undefined，不可以链式调用。</li><li>map()返回一个新数组，原数组不会改变。</li><li>flat()默认只会拉平一层，flat（n）拉平 n 层，Infinity 无限次,flat()会跳过空格,返回新数组不改变原数组</li><li>数组去重，3 种方法</li></ol><ul><li>遍历加 indexof 去重。</li><li>for 循环嵌套 splice 去重，</li><li>es6 new Set 去重（原理是通过 map 实现的）</li></ul><ol start="5"><li>字符串截取的方法</li></ol><ul><li>slice（开始索引，结束索引）</li><li>substring(开始索引，结束索引，包头不包尾)，</li><li>substr(开始索引，结束索引)</li><li>数组的 splice(下标， 删除个数，目标元素)</li></ul><h4 id="2-抖动与防抖"><a href="#2-抖动与防抖" class="headerlink" title="2.抖动与防抖"></a>2.抖动与防抖</h4><p><strong>函数防抖</strong></p><blockquote><p>函数防抖是通过设置定时器，判断，当持续触发事件时，一定时间内没有再触发事件，事件处理函数才会执行一次，如果设定的延时到来之前又触发了事件，那么就重新开始延时.<br>作用: 作用在于限制浏览器发送请求的次数，减少服务器压力，</p></blockquote><p><strong>函数节流</strong></p><blockquote><p>函数节流是通过设置定时器加时间戳的模式来控制一定时间内只触发一次函数，原理是判断是否达到给定的时间来触发函数。</p></blockquote><p><code>区别</code>:两者的区别在于函数节流无论事件触发的多频繁，都会保证在规定时间内触发一次函数， 而函数防抖只是在最后一次事件后才触发一次函数。</p><h4 id="3-跨域解决方案"><a href="#3-跨域解决方案" class="headerlink" title="3.跨域解决方案"></a>3.跨域解决方案</h4><p><a href="https://juejin.im/entry/59b8fb276fb9a00a42474a6f" target="_blank" rel="noopener">转前端常见跨域解决方案（全）</a></p><ol><li>jsonp<blockquote><p>原理:主要是利用 script 标签的 src 属性不受同源策略影响，向后台发送 get 请求，并通过回调函数由服务器返回数据，实现跨域，先创建一个唯一的回调函数名，挂载到 window 属性上，然后创建一个 script 标签， 把 src 属性赋值 url，然后通过请求之后执行挂载回调获取数据，再将回调删除，再将 script 删除。 就完成了一个 jsonp 的封装。</p></blockquote></li><li>cors(后端处理)</li><li>nginx 反向代理(通过 add_header 处理添加一些响应头信息)</li></ol><h4 id="4-get-和-post-区别"><a href="#4-get-和-post-区别" class="headerlink" title="4.get 和 post 区别"></a>4.get 和 post 区别</h4><ul><li>get 和 post 请求的区别在于， get 请求需要将参数以？拼接在 url 后面，而 post 不需要。</li><li>post 请求需要设置一个请求头 content-type application x-www-form-urlencode,get 使用默认请求头</li><li>post 请求参数以&amp;拼接放入请求体中，上传给服务器。而 get 请求体中不传参或 null,</li><li>get 请求相较于 post 请求，安全性低。</li><li>get 请求对数据大小有 4k 的限制，而 post 没有明显限制</li></ul><p><code>put和post的区别</code> : put 指定了资源在服务器的位置,而 post 没有 , put 一般用于对资源的创建于修改.</p><h4 id="5-http-状态码"><a href="#5-http-状态码" class="headerlink" title="5.http 状态码"></a>5.http 状态码</h4><blockquote><p>常见的状态码 200 请求成功， 302： 重定向 304： 文件未修改 400：请求语法错误，401：未授权 404： 找不到资源，405：访问不被允许 500 服务器错误。</p></blockquote><h4 id="6-浏览器的渲染原理？"><a href="#6-浏览器的渲染原理？" class="headerlink" title="6.浏览器的渲染原理？"></a>6.浏览器的渲染原理？</h4><p>解析 html 以构建 dom 树 -&gt; 构建 render 树 -&gt; 布局 render 树 -&gt; 绘制 render 树</p><h4 id="7-当输入地址，按下回车的时候，页面发生了什么？"><a href="#7-当输入地址，按下回车的时候，页面发生了什么？" class="headerlink" title="7.当输入地址，按下回车的时候，页面发生了什么？"></a>7.当输入地址，按下回车的时候，页面发生了什么？</h4><blockquote><p>进行域名解析， 先查看浏览器自身的 DNS 缓存， 然后查看操作系统本身的 DNS 缓存， 在查找本地 host,最后再到 DNS 服务器。域名解析完成后，会 发起 TCP 的三次握手，建立 TCP 连接后发起 http 请求，服务器响应请求，浏览器获得 html 代码。之后浏览器解析代码，并将资源缓存。最后进行渲染。</p></blockquote><h4 id="8-媒体查询写法"><a href="#8-媒体查询写法" class="headerlink" title="8.媒体查询写法:"></a>8.媒体查询写法:</h4><p><code>@media screen and (max-width:480px){.ads {display:none;}}</code></p><h4 id="9-事件委托"><a href="#9-事件委托" class="headerlink" title="9.事件委托"></a>9.事件委托</h4><blockquote><p>语法：element.addEventListener(event, function, useCapture)；</p></blockquote><ol><li>event:必须。字符串，指定事件名。</li><li>不加’on’，如 click function:必须。指定要事件触发时执行的函数。</li><li>useCapture：可选。布尔值，指定事件是否在捕获或冒泡阶段执行(true-事件句柄在捕获阶段执行；false-默认。事件句柄在冒泡阶段执行)。</li></ol><p><code>移除事件监听</code>：element.removeEventListener(event, function,useCapture) 匿名函数无法移出</p><h4 id="10-浏览器缓存"><a href="#10-浏览器缓存" class="headerlink" title="10.浏览器缓存"></a>10.浏览器缓存</h4><p><a href="https://juejin.im/post/5c417993f265da61285a6075" target="_blank" rel="noopener">转:浏览器缓存</a></p><h4 id="11-重排-回流-和重绘是什么？"><a href="#11-重排-回流-和重绘是什么？" class="headerlink" title="11.重排(回流)和重绘是什么？"></a>11.重排(回流)和重绘是什么？</h4><p>1、回流：当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改 变时，浏览器重新渲染部分或全部文档的过程称为回流。每个页面至少需要一 次回流，就是在页面第一次加载的时候。<br>2、重绘：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、 background-color、visibility 等），这些属性只是影响元素的外观，风格，而不 会影响布局的，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重 绘。</p><blockquote><p>回流必将引起重绘，而重绘不一定会引起回流。 因为：如果一个元素引发了回流，它就影响了父级以及兄弟节点的位置，它们 都要重新渲染了，所以回流必定引发重绘。</p></blockquote><ul><li>触发重排和重绘：<br>• 页面首次渲染<br>• 浏览器窗口大小发生改变<br>• 元素尺寸或位置发生改变<br>• 元素内容变化（文字数量或图片大小等等）<br>• 元素字体大小变化<br>• 添加或者删除可见的 DOM 元素</li></ul><h3 id="五-VUE"><a href="#五-VUE" class="headerlink" title="五 VUE"></a>五 VUE</h3><h4 id="1-vue-源码原理"><a href="#1-vue-源码原理" class="headerlink" title="1.vue 源码原理"></a>1.vue 源码原理</h4><blockquote><p><a href="https://cn.vuejs.org/v2/guide/instance.html?" target="_blank" rel="noopener">vue</a>的原理：主要是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。它是通过 observer,compile ,watcher 三个模块来实现的。observer 的核心是在数据变化时通过 object.definePrototype(/)设置 setter 和 getter，来通知 watcher，watcher 是 observer 和 compile 之间通信的桥梁，主要是调用 update 方法来触发 compile 中的回调，compile(使用 document fragment 操作节点)解析模版指令替换数据，并且为操作节点绑定更新函数，从而更新视图。</p></blockquote><h4 id="2-vue-的生命周期"><a href="#2-vue-的生命周期" class="headerlink" title="2. vue 的生命周期"></a>2. vue 的生命周期</h4><blockquote><p>vue 的生命周期分为八个阶段,创建前创建后, 挂载前和挂载后, 更新前更新后, 销毁前销毁后.</p></blockquote><ul><li>创建阶段为 beforecreate ,create</li><li>挂载阶段为 beforemount 和 mounted</li><li>更新阶段 为 beforeupdate 和 update</li><li>销毁阶段为 beforedestroy 和 destroy</li></ul><p><strong>问题</strong></p><ol><li>创建阶段和挂载阶段有什么区别, create 和 mounted :=&gt; create 阶段不能操作 DOM 元素,因为此时 el 还没有挂载, 而 mounted 可以,</li><li>父组件的 create 阶段先执行还是子组件的 create 阶段先执行 :=&gt; 父组件的 create 先执行, 但是子组件的 mounted 阶段又比父组件的 mounted 先执行</li><li>个人理解: 在页面渲染的时候, 首先应该渲染父组件,所以先执行父组件的 create, 而父组件里通常是有子组件的,那么这个时候,因为父组件本身的完整内容是包含子组件的,所以,可以想象 , 如果同时挂载多个子组件的话,那么,肯定要等到子组件渲染完成后, 父组件才能完整的挂载 el 完成. 因为 子组件是父组件的一部分,要渲染完成父组件,那么部分的组件肯定先比父组件完成挂载.</li></ol><h4 id="3-vue-中子组件传值给父组件-的三种方式"><a href="#3-vue-中子组件传值给父组件-的三种方式" class="headerlink" title="3.vue 中子组件传值给父组件 的三种方式"></a>3.vue 中子组件传值给父组件 的三种方式</h4><ol><li>props 配合$emit 父组件中必须要有 .sync 修饰符 ，它的作用是当一个子组件改变一个 prop 的值的时候，这个变化会同步到父组件当中所绑定。</li><li>先在父组件 methods 中创建一个方法， 然后在子组件用自定义事件触发这个方法进行传值。</li><li>v-model 配合 input 。（不推荐）</li></ol><ul><li>===&gt;一般问完组件通信 :=&gt; 父传子:父组件声明变量,子组件使用 props 声明接收,<br>父:<code>&lt;child :msg=&quot;message&quot;&gt;&lt;/child&gt;</code> 子:<code>&lt;div&gt;&lt;/div&gt;</code></li><li>===&gt; 子传父的方式. :=&gt; 先在父组件 methods 中创建一个方法<code>@msgFunc</code>， 然后在子组件用自定义事件触发这个 <code>this.$emit(&#39;msgFunc&#39;)</code>;方法进行传值。</li><li>===&gt;非父子 : <code>Bus.$emit(&#39;on&#39;, &#39;来自兄弟组件&#39;)</code> -&gt; <code>Bus.$on(&#39;on&#39;, (msg) =&gt; {  this.message = msg }) =&gt;msg = 来自兄弟组件</code></li></ul><h4 id="4-vue-组件间的传参方式"><a href="#4-vue-组件间的传参方式" class="headerlink" title="4.vue 组件间的传参方式"></a>4.vue 组件间的传参方式</h4><ol><li><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex</a><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，<br>并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，<br>提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能</p></blockquote></li></ol><ul><li>Vuex 优缺点<ul><li>优点</li></ul><ol><li>解决了多层组件之间繁琐的事件传播。</li><li>解决了多组件依赖统同一状态的问题。</li><li>单向数据流</li><li>为 Vue 量身定做，学习成本不高</li></ol><ul><li>缺点</li></ul><ol><li>不能做数据持久化，刷新页面就要重制，要做数据持久化可以考虑使用 localstorage。</li><li>增加额外的代码体积，简单的业务场景不建议使用</li></ol></li></ul><ol start="2"><li>本地存储传值</li><li>路由传参</li></ol><ul><li><p>方案一<br>getDescribe(id) {<br>直接调用$router.push 实现携带参数的跳转</p><pre><code>      this.$router.push({</code></pre><p>path: <code>/describe/${id}</code>,<br>})<br>}<br>路由配置如下：<br>{<br>path: ‘/describe/:id’,<br>name: ‘Describe’,<br>component: Describe<br>}</p></li><li><p>方案二<br>this.$router.push({</p><pre><code>    name: &#39;Describe&#39;,    params(query): {         id: id    }  })  获取:  this.$route.params(query).id</code></pre></li></ul><p><a href="https://blog.csdn.net/mf_717714/article/details/81945218?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-2" target="_blank" rel="noopener">路由传参 params(query)区别</a></p><ul><li><p>方案三</p><pre><code> &lt;router-link :to=&quot;{path:&#39;/test&#39;,query: {name: id}}&quot;&gt;跳转&lt;/router-link&gt;</code></pre></li></ul><h4 id="5-router和-route-有什么区别"><a href="#5-router和-route-有什么区别" class="headerlink" title="5.$router和$route 有什么区别"></a>5.$router和$route 有什么区别</h4><blockquote><p>$route 是路由对象，负责解析 url 的 hash 值，主要用于获取几个属性（name,parmas,path,query），而 $router 是路由实例对象，负责的是实现路由跳转功能。</p></blockquote><p>如何监听$route =&gt;  使用watch监听。$route(to){to.parmas.id}</p><h4 id="6-vue-router-中-hash-模式与-history-模式的区别"><a href="#6-vue-router-中-hash-模式与-history-模式的区别" class="headerlink" title="6. vue-router 中 hash 模式与 history 模式的区别"></a>6. vue-router 中 hash 模式与 history 模式的区别</h4><blockquote><p>vue-router 有两种模式。一种是默认的 hash 模式，一种是 history 模式。<br>如何去除 hash 模式的# 在路由对象里写 mode:history</p></blockquote><p>hash 模式 原理是利用 window 监听 hashchange 事件，由 hash 改变的 url 都会被浏览器记录下来，浏览器的前进后退也可以对其控制，虽然没有请求服务器，但还是将页面和 url 一一关联起来了，这个就是 hash 模式，也是前端路由中，单页应用的标配。</p><p>history 模式，是利用 H5 新增的 history interface 中的 history.pushState（） 和 history.replaceState（） 来请求服务器（前端的 url 必须和实际向后端发起请求的 url 一致）实现的，它会向服务器发送请求。 history 模式在刷新和 F5 的时候会出现 404 错误，需要用 nginx 配置出错时</p><h4 id="7-vue-杂项问题"><a href="#7-vue-杂项问题" class="headerlink" title="7.vue 杂项问题"></a>7.vue 杂项问题</h4><ol><li><p>vue 是单向绑定还是双向绑定？<br>vue 是单向绑定的 ， 双向是指 view 层和 model 数据层双向绑定， 而 v-model 只是双向绑定的一个语法糖。<br>组件和组件中是单向绑定的、</p></li><li><p><a href="https://www.jianshu.com/p/a7550c0e164f" target="_blank" rel="noopener">$nextTick 是什么?</a><br>因为 vue 是异步更新的，$nextTick 是用来知道什么时候 DOM 更新完成的</p></li><li><p><a href="https://www.cnblogs.com/Sherlock09/p/11023593.html" target="_blank" rel="noopener">vue-loader</a>是什么？<br>是解析和转换。vue 文件的工具，作用是提取出可被浏览器识别的 js 代码</p></li><li><p>vue 中<a href="https://www.jianshu.com/p/a6f741c7b500" target="_blank" rel="noopener"> keep-alive</a> 组件的作用<br><code>&lt;keep-alive&gt;</code>是 Vue 的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。<br>keep-alive：主要用于保留组件状态或避免重新渲染。<br>当二个组件被很频繁的调用的时候可以使用 keep-alive 标签进行缓存，这样页面就会从缓存中快速渲染，而不是重新渲染。 5.<a href="https://segmentfault.com/a/1190000017752182?utm_source=tag-newest" target="_blank" rel="noopener"> vue-router 如何响应 路由参数 的变化</a>？ 1.使用 watch 监听。 2. 使用 beforeUpdate 守卫</p></li><li><p><a href="https://www.cnblogs.com/shenjianping/p/11330126.html" target="_blank" rel="noopener">过滤器</a></p></li><li><p><a href="https://www.jianshu.com/p/088a7eb6de72" target="_blank" rel="noopener">Vue.mixin 的作用（混入）</a></p><blockquote><p>将使用频率比较多的部分提取出来，定义一个对象可以包含任意组件选项。</p></blockquote></li><li><p>使用时混入的对象会跟组件中的对象进行合并；<br>　　 2. 同名的钩子函数会合并成数组，先调用混入的钩子函数；<br>　　 3. 出现相同的属性或方法时会调用组件内的方法。</p></li><li><p>router-link 高亮处理 1.使用类 router-link-active<br>2.在路由中配置 linkActiveClass：‘类名’（类名为自定义样式）</p></li><li><p><a href="https://blog.csdn.net/qq_40958876/article/details/99822406?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">编程式导航</a><br>跳转：this.$router.push()  返回 :this.$router.back() 替换:this.$replace() ===》 关于跳转和替换的区别在于 历史记录的问题， ：=》 跳转有历史记录，而替换没有。</p></li><li><p>/child 和 child 的区别<br>/child 访问的路径是/child 而 child 访问的是 /parent/child</p></li><li><p>vue 左侧菜单展开隐藏重新渲染 echars<br>加个监控=&gt; window.onresize</p></li><li><p>为什么 vue 中 data 是个函数而不是个对象</p><blockquote><p>因为组件是可复用的 vue 实例。它有可能被多次复用，而组件中的 data 写成一个函数，数据以函数返回值的形式定义，这样每复用一次组件，就会返回一个新的 data，类似于给每个组件实例创建了一个私有的数据空间，让各自组件维护自己的数据，互不影响。 而如果写成对象的形式，就使得所有组件都共用一份 data，那么一个组件中改变就会造成所有的组件数据都会改变。</p></blockquote></li><li><p><a href="https://www.jianshu.com/p/52e6692639f5" target="_blank" rel="noopener">slot 插槽 </a></p><blockquote><p>作用是可以让父组件向子组件插入一些内容（包含 html 标签结构），并且也可以在父组件中拿到子组件的数据</p></blockquote></li></ol><p>slot 插槽有三种， 匿名插槽 具名插槽，和作用域插槽</p><ol><li>匿名插槽 v-slot:default 只能有且只有一个</li><li>具名插槽 v-slot:名称 ，子组件使用 slot 标签插入时也要加上 name 属性</li><li>作用域插槽 v-slot：名字 = “数据名” 主要用于子组件数据被父组件获取。</li><li>provice/inject 依赖注入<br>主要用于高阶插件/应用库提供用例，并不推荐在应用程序上使用， 。 它允许祖先组件向所有子孙组件注入依赖，<br>祖先组件使用 provice 声明变量， 子孙使用 inject 注入依赖。</li><li>vue 和 jq 的区别<br>vue 和 jq 的区别在于控制反转，<br>jq 是开发人员起主导作用，通过操作 DOM,来进行数据修改<br>vue 是框架起主导作用, 修改数据,vue 会自己帮我们完成 DOM 操作</li><li><a href="https://www.cnblogs.com/jiajialove/p/11327945.html" target="_blank" rel="noopener">watch 和 computed 的区别</a></li></ol><ul><li>watch 一个数据响应多个数据</li><li>computed 一个数据受到多个数据的影响 有缓存<blockquote><p>在实现原理上 watch 和 computed 是差不多的，vue 的 data 值在初始化阶段都会被挂载上 watcher 观察者模式，当数据改变的时候会先调用 watcher 观察者模式，然后调用计算属性，和监听属性。本质上来说没有多大区别</p></blockquote></li></ul><ol start="17"><li><a href="https://www.cnblogs.com/dianzan/p/12751087.html" target="_blank" rel="noopener">v-for 和 v-if 不应该一起使用</a></li></ol><ul><li>原因：v-for 比 v-if 优先，即每一次都需要遍历整个数组，影响速度。</li><li>解决: 在 computed 里面使用,缓存 v-show</li></ul><ol start="18"><li><p>spa 优缺点:<br><strong>优点:</strong></p><ol><li>良好的交互体验</li><li>良好的前后端工作分离模式 3.减轻服务器压力<br><strong>缺点:</strong></li><li>首屏加载慢</li><li>不利于 SEO</li><li>不适合开发大型项目</li></ol></li><li><p>加载渲染过程</p></li></ol><p><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</code></p><ol start="20"><li>与 React 的区别</li></ol><ul><li><strong>相同点：</strong><ol><li>React 采用特殊的 JSX 语法，Vue 在组件开发中也推崇编写 Vue 特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用。</li><li>中心思想相同：一切都是组件，组件实例之间可以嵌套。</li><li>都提供合理的钩子函数，可以让开发者定制化地去处理需求。</li><li>都不内置列数 Ajax，Route 等功能的核心包，而是以插件的方式加载。</li><li>在组件开发中都支持 mixins 的特性。</li></ol></li><li>不同点：<ol><li>React 依赖 Virtual DOM，而 Vue 使用的是 DOM 模板，React 采用的 Virtual DOM 会对渲染出来的结果做脏检查。</li><li>vue 在模板中提供了指令，过滤器等，可以非常方便，开解的操作 DOM</li></ol></li></ul><h4 id="8-细节"><a href="#8-细节" class="headerlink" title="8.细节"></a>8.细节</h4><h5 id="1-接口请求一般放在-mounted-中，但需要注意的是服务端渲染时不支持-mounted，-需要放到-created-中"><a href="#1-接口请求一般放在-mounted-中，但需要注意的是服务端渲染时不支持-mounted，-需要放到-created-中" class="headerlink" title="1. 接口请求一般放在 mounted 中，但需要注意的是服务端渲染时不支持 mounted， 需要放到 created 中"></a>1. 接口请求一般放在 mounted 中，但需要注意的是服务端渲染时不支持 mounted， 需要放到 created 中</h5><h5 id="2-性能优化："><a href="#2-性能优化：" class="headerlink" title="2. 性能优化："></a>2. 性能优化：</h5><pre><code>1、首屏加载优化 2、路由懒加载 3、开启服务器 Gzip4、启动 CDN 加速 5、代码层面优化 6、Webpack 对图片进行压缩7、避免内存泄漏 8、减少 ES6 转为 ES5 的冗余代码</code></pre><h5 id="3-简述-cookie-和-localStorage-以及-sessionStorage-的区别。"><a href="#3-简述-cookie-和-localStorage-以及-sessionStorage-的区别。" class="headerlink" title="3. 简述 cookie 和 localStorage 以及 sessionStorage 的区别。"></a>3. 简述 cookie 和 localStorage 以及 sessionStorage 的区别。</h5><p>关于 <strong>cookie、sessionStorage、localStorage</strong> 三者的区别主要有以下几点：</p><ul><li>存储大小：cookie 数据大小不能超过 4k，sessionStorage 和 localStorage 虽然也 有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大</li><li>有效时间：localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除 数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除；cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭 数据与服务器之间的交互方式，</li><li>cookie 的数据会自动的传递到服务器，服务器端 也可以写 cookie 到客户端；sessionStorage 和 localStorage 不会自动把数据发给 服务器，仅在本地保存</li></ul><h5 id="4-说一下-微信小程序-与-Vue-的区别"><a href="#4-说一下-微信小程序-与-Vue-的区别" class="headerlink" title="4. 说一下 微信小程序 与 Vue 的区别"></a>4. 说一下 微信小程序 与 Vue 的区别</h5><ul><li>1、生命周期： 小程序的钩子函数要简单得多 。vue 的钩子函数在跳转新页面时，钩子函数都会触发， 但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。 在页面加载请求数据时，两者钩子的使用有些类似，vue 一般会在 created 或者 mounted 中请求数据，而在小程序，会在 onLoad 或者 onShow 中请求数据。</li><li>2、数据绑定： vue 动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>img <span class="token punctuation">:</span>src<span class="token operator">=</span><span class="token string">"imgSrc"</span><span class="token operator">/</span><span class="token operator">></span>小程序 绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为 被认为是字符串  <span class="token operator">&lt;</span>image src<span class="token operator">=</span><span class="token string">"{{imgSrc}}"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>image<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>3、列表循环</li><li>4、显示与隐藏元素 vue 中，使用 v-if 和 v-show 控制元素的显示和隐藏 小程序中，使用 wx-if 和 hidden 控制元素的显示和隐藏</li><li>5、事件处理 vue：使用 v-on:event 绑定事件，或者使用@event 绑定事件 小程序中，全用 bindtap(bind+event)，或者 catchtap(catch+event)绑定事件</li><li>6、数据的双向绑定 在 vue 中,只需要再表单元素上加上 v-model,然后再绑定 data 中对应的一个值，当表 单元素内容发生变化时，data 中对应的值也会相应改变 。 当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过 this.setData({key:value})来将表单上的值赋值给 data 中的对应值 。</li><li>7、绑定事件传参 在 vue 中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为 形参传入就可以了 在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到 元素上的 data-属性上，然后在方法中，通过 e.currentTarget.dataset.*的方式获取</li><li>8、父子组件通信 父组件向子组件传递数据，只需要在子组件通过 v-bind 传入一个值，在子组件中，通 过 props 接收，即可完成数据的传递 父组件向子组件通信和 vue 类似，但是小程序没有通过 v-bind，而是直接将值赋值给 一个变量 在子组件 properties 中，接收传递的值</li></ul><h5 id="5-computed-和-watcher-的区别？watch-实现原理？watch-有几种写-法？"><a href="#5-computed-和-watcher-的区别？watch-实现原理？watch-有几种写-法？" class="headerlink" title="5. computed 和 watcher 的区别？watch 实现原理？watch 有几种写 法？"></a>5. computed 和 watcher 的区别？watch 实现原理？watch 有几种写 法？</h5><blockquote><p>使用场景：computed—-当一个属性受多个属性影响的时候，<br>使用 computed——-购物车商品结算。watch—-当一条数据影响多条 数据的时候，<br>使用 watch——-搜索框</p></blockquote><ul><li>计算属性 computed :</li></ul><ol><li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li><li>不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化<br>3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓 存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算 得到的值</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个 多对一或者一对一，一般用 computed</li><li>如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值 就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法， 当数据变化时，调用 set 方法。</li></ol><ul><li>侦听属性 watch：</li></ul><ol><li>不支持缓存，数据变，直接会触发相应的操作；</li><li>watch 支持异步； 3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前 的值；</li><li>当一个属性发生变化时，需要执行对应的操作；一对多；</li><li>监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当 数据变化时，触发其他操作，函数有两个参数， immediate：组件加载立即触发回调函数执行， deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如 数组中的对象内容的改变，注意监听数组的变动不需要这么做。<br>注意：deep 无法监听到数组的变动和对象的新增，参考 vue 数组变异,只有以 响应式的方式触发才会被监听到。<blockquote><p>watch 工作原理: watch 在一开始初始化的时候，会读取一遍监听的数据的值，此时那个数据就 收集到 watch 的 watcher 了然后你给 watch 设置的 handler，watch 会放入 watcher 的更新函数中，当数据改变时，通知 watch 的 watcher 进行更新，于 是你设置的 handler 就被调用了。</p></blockquote></li></ol><h5 id="6-对-keep-alive-的了解？"><a href="#6-对-keep-alive-的了解？" class="headerlink" title="6.对 keep-alive 的了解？"></a>6.对 keep-alive 的了解？</h5><p>keep-alive 是 vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新 渲染</p><h5 id="7-Vue-中一句话就能回答的面试题？"><a href="#7-Vue-中一句话就能回答的面试题？" class="headerlink" title="7.Vue 中一句话就能回答的面试题？"></a>7.Vue 中一句话就能回答的面试题？</h5><p>1、css 只在当前组件起作用</p><pre class="line-numbers language-js"><code class="language-js">答：在 style 标签中写入 scoped 即可。例如 <span class="token operator">&lt;</span>style scoped<span class="token operator">></span><span class="token operator">&lt;</span>style<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、v-if 和 v-show 的区别？<br>答：v-if 按照条件是否渲染，v-show 是 display 的 block 或 none<br>3、$route 和 $router 的区别？<br>答：$route 是路由信息对象，包括 path,params,hash,query,fullPath,matched,name 等路由信息参数。 $router 是路由实例对象，包括了路由的跳转方法，钩子函数等。<br>4、vue.js 的两个核心是什么？<br>答：数据驱动，组件系统<br>5、vue 几种常用的指令？</p><pre class="line-numbers language-js"><code class="language-js">答：v<span class="token operator">-</span><span class="token keyword">for</span><span class="token punctuation">,</span> v<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">,</span> v<span class="token operator">-</span><span class="token keyword">else</span><span class="token punctuation">,</span> v<span class="token operator">-</span>bind<span class="token punctuation">,</span> v<span class="token operator">-</span>on<span class="token punctuation">,</span> v<span class="token operator">-</span>show<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6、v-on 可以绑定多个方法吗？<br>答：可以<br>7、vue 中 key 值的作用？<br>答：key 的作用主要是为了高效的更新虚拟 DOM<br>8、什么是 vue 的计算属性？<br>答：computed,适用于复杂数据处理，便于维护</p><h5 id="8-computed-和-watch-区别"><a href="#8-computed-和-watch-区别" class="headerlink" title="8.computed 和 watch 区别"></a>8.computed 和 watch 区别</h5><p>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓 存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。<br>所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，<br>对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。<br>另外 computerd 和 watch` 还都支持对象的写法，这种方式知道的人并不 多。</p><h5 id="9-Vue-的路由实现：hash-模式-和-history-模式"><a href="#9-Vue-的路由实现：hash-模式-和-history-模式" class="headerlink" title="9.Vue 的路由实现：hash 模式 和 history 模式"></a>9.Vue 的路由实现：hash 模式 和 history 模式</h5><p>hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash，用 window.location.hash 读取。<br>特点：hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，对服务端安全无用，hash 不会重加 载页面。<br>history 模式：history 采用 HTML5 的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及 popState 事件的监听到状态变更,刷新的时候会出现 404</p><blockquote><p>hash 模式和 history 模式有什么区别？ 1、地址栏展示不同 hash 模式地址栏有# 2、history 在服务器端有配置，如 果不配置，一刷新就会出现 404，hash 模式不用配置。 3、所监听的事件也 不一样 hash 监听 hashchange 事件 history 监听 popstate 事件 4、hash 模 式不会刷新页面，history 模式会刷新页面</p></blockquote><h5 id="10-vue-项目中的性能优化"><a href="#10-vue-项目中的性能优化" class="headerlink" title="10. vue 项目中的性能优化"></a>10. vue 项目中的性能优化</h5><p>1.不要在模板里面写过多表达式 2.循环调用子组件时添加 key 3.频繁切换的使用 v-show，不频繁切换的使用 v-if 4.尽量少用 float，可以用 flex 布局 5.按需加载，可以用 require 或者 import()按需加载需要的组件 6.路由懒加载</p><h5 id="11-下-vue3-和-vue2-有啥区别，性能为啥能提升"><a href="#11-下-vue3-和-vue2-有啥区别，性能为啥能提升" class="headerlink" title="11.下 vue3 和 vue2 有啥区别，性能为啥能提升"></a>11.下 vue3 和 vue2 有啥区别，性能为啥能提升</h5><p>1、使用了 proxy 替代 Object.defineProperty 2、压缩包体积更小 3、目录结构有一些改变</p><ol><li>重构响应式系统，使用 Proxy 替换 Object.defineProperty， 使用 Proxy 优势： •可直接监听数组类型的数据变化 •监听的目标为对象本身，不需要像 Object.defineProperty 一样遍历每个属性， 有一定的性能提升 •可拦截 apply、ownKeys、has 等 13 种方法，而 Object.defineProperty 不行 •直接实现对象属性的新增/删除</li><li>新增 Composition API，更好的逻辑复用和代码组织</li><li>重构 Virtual DOM •模板编译时的优化，将一些静态节点编译成常量 •slot 优化，将 slot 编译为 lazy 函数，将 slot 的渲染的决定权交给子组件 •模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</li><li>代码结构调整，更便于 Tree shaking，使得体积更小</li><li>使用 Typescript 替换 Flow</li></ol><h4 id="12-彻底理解-vue-中-render-函数与-template-的区别？"><a href="#12-彻底理解-vue-中-render-函数与-template-的区别？" class="headerlink" title="12. 彻底理解 vue 中 render 函数与 template 的区别？"></a>12. 彻底理解 vue 中 render 函数与 template 的区别？</h4><p>vue 中的 template 用来创建 html,有的时候需要用 js 来创建 html，这个时候需 要使用 render 函数<br>相同之处： render 函数跟 remplate 一样都是创建 html 模板<br>不同之处： template 逻辑简单，render 适合复杂逻辑 template 灵活性低，render 灵活性高 template 性能低，render 性能高 render 的优先级高于 template</p><h4 id="13-watch-与-computed-的使用场景"><a href="#13-watch-与-computed-的使用场景" class="headerlink" title="13 watch 与 computed 的使用场景"></a>13 watch 与 computed 的使用场景</h4><p>watch：网络请求，模糊查询，浏览器自适应，监控路由对象<br>computed：购物车结算， 过滤某些商品数据</p><h4 id="14-如何检测路由参数的变化？"><a href="#14-如何检测路由参数的变化？" class="headerlink" title="14.如何检测路由参数的变化？"></a>14.如何检测路由参数的变化？</h4><p>通过属性监听来实现或者 beforeRouterUpdate()</p><h4 id="15-什么是路由守卫？路由的钩子函数有哪些？分别说出使用-场景？"><a href="#15-什么是路由守卫？路由的钩子函数有哪些？分别说出使用-场景？" class="headerlink" title="15 什么是路由守卫？路由的钩子函数有哪些？分别说出使用 场景？"></a>15 什么是路由守卫？路由的钩子函数有哪些？分别说出使用 场景？</h4><p>路由守卫就是路由跳转前后的做的一些验证 钩子函数：<br>beforeRouteEnter 使用场景：登录验证<br>beforeRouteUpdate 使用场景：路由更新的时候<br>beforeRouteLeave 使用场景：路由离开的时候</p><h4 id="16-什么是全局守卫？"><a href="#16-什么是全局守卫？" class="headerlink" title="16 什么是全局守卫？"></a>16 什么是全局守卫？</h4><p>beforeEach：全局守卫，验证用户是否登录</p><h4 id="17-vue-中路由传参的方式有哪几种？"><a href="#17-vue-中路由传参的方式有哪几种？" class="headerlink" title="17 vue 中路由传参的方式有哪几种？"></a>17 vue 中路由传参的方式有哪几种？</h4><p>1、动态路由传参数 2、query 传参 3、路由解耦</p><h4 id="18-vuex-中怎么异步请求的？"><a href="#18-vuex-中怎么异步请求的？" class="headerlink" title="18 vuex 中怎么异步请求的？"></a>18 vuex 中怎么异步请求的？</h4><p>vuex 中的异步方法，例如请求都要在 actions 中声明，通过解构出 commit 参数， 再将请求返回的数据通过 commit 提交到 mutations 中声明的方法进行修改 state 中的数据</p><h4 id="19-什么时候使用-vuex-更好一些"><a href="#19-什么时候使用-vuex-更好一些" class="headerlink" title="19 什么时候使用 vuex 更好一些"></a>19 什么时候使用 vuex 更好一些</h4><p>1、当一个组件需要多次派发事件时 2、跨组件共享数据、跨页面共享数据 – 购物车的数据共享，登入注册</p><h4 id="20-vue-中-router-和-route-的区别"><a href="#20-vue-中-router-和-route-的区别" class="headerlink" title="20 vue 中$router 和$route 的区别"></a>20 vue 中$router 和$route 的区别</h4><ul><li>this.$route：当前激活的路由的信息对象。每个对象都是局部的，可以获取当前 路由的 path, name, params, query 等属性。</li><li>this.$router：全局的 router 实例。通过 vue 根实例中注入 router 实例，然 后再注入到每个子组件，从而让整个应用都有路由功能。其中包含了很多属性和 对象（比如 history 对象），任何页面也都可以调用其 push(), replace(), go() 等 方法。</li></ul><h4 id="21-什么是防抖和节流，"><a href="#21-什么是防抖和节流，" class="headerlink" title="21 什么是防抖和节流，"></a>21 什么是防抖和节流，</h4><p>它们的区别 防抖是控制次数，节流是控制频率</p><blockquote><p>防抖： 在持续触发事件之后，一段时间没有再次触发该事件，事件函数才会执行一次。 防抖解决：每次触发事件时都取消之前的延时调用方法<br>节流： 在持续触发事件时，每隔指定时间触发一次事件处理函数。 节流解决：每次触发事件前都判断当前是否有等待执行的延时函数</p></blockquote><h4 id="22-常用的数组方法："><a href="#22-常用的数组方法：" class="headerlink" title="22 常用的数组方法："></a>22 常用的数组方法：</h4><p>pop() 尾部删除 push() 尾部添加 shift() 头部删除 unshift()头部添加 array.concat() 连接数组 array.join() 将数组连接起来变成一个字符串 array.reverse() 反转数组 array.slice() 切割数组 array.splice() 截取数组 array.sort() 对数组进行排序 array.toString() 将数组转换成一个字符串</p><h4 id="23-节点的方法"><a href="#23-节点的方法" class="headerlink" title="23 节点的方法"></a>23 节点的方法</h4><p>appendChild() 添加节点 removeChild 删除节点 insertBefore 插入节点 replaceChild 替换节点</p><h4 id="24-async、await-优缺点"><a href="#24-async、await-优缺点" class="headerlink" title="24 async、await 优缺点"></a>24 async、await 优缺点</h4><p>async 和 await 相比直接使用 Promise 来说，<br>优势在于处理 then 的调用链，能够更清晰准确的写出代码。<br>缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后 的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p><h4 id="25-解决跨域问题的方式？"><a href="#25-解决跨域问题的方式？" class="headerlink" title="25 解决跨域问题的方式？"></a>25 解决跨域问题的方式？</h4><p>1、JSONP 使用简单且兼容性不错，但是只限于 get 请求。利用 src 不受同源策 略的影响 =&gt; 利用 script 标签会把所有内容当作 JS 代码来执行 =&gt; 我们就 绕开了浏览器同源策略的影响<br>2、CORS(跨域资源共享) 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。<br>3、服务器代理(常用) 切换到 nginx 服务器, 使用 nginx 服务器进行代理配 置 -&gt; 配置好以后, 请求的时候只要请求代理标识符就可以了</p><h4 id="26-、break，continue，return"><a href="#26-、break，continue，return" class="headerlink" title="26 、break，continue，return"></a>26 、break，continue，return</h4><p>三者区别 break break 用于完全结束一个循环，跳出循环体。</p><blockquote><p>continue continue 的功能和 break 有点类似，区别是 continue 只是中止本次循环，接着 开始下一次循环。而 break 则是完全中止循环。 return 与 continue 和 break 不同的是，return 直接结束整个方法，不管这个 return 处 于多少层循环之内。</p></blockquote><h4 id="27-重绘和回流-什么是重绘？"><a href="#27-重绘和回流-什么是重绘？" class="headerlink" title="27 重绘和回流 什么是重绘？"></a>27 重绘和回流 什么是重绘？</h4><p>由于几何属或样式发生改变不影响布局而需要重新渲染的过程，就叫重绘。<br>什么是回流？ 由于布局发生改变需要重建就叫做回流<br>什么原因会导致回流 添加或者删除可见的 DOM 元素； 元素位置改变； 元素尺寸改变——边距、填充、边框、宽度和高度 页面渲染初始化； 浏览器窗口尺寸改变——resize 事件发生时；<br>回流必将引起重绘，而重绘不一定会引起回流。</p><h4 id="28-事件"><a href="#28-事件" class="headerlink" title="28 事件"></a>28 事件</h4><p>事件委托是什么?<br>利用事件冒泡的原理，让自己所触发的事件，让它的父元素代替执行<br>事件冒泡是什么？<br>当一个元素接收到事件的时候 会把他接收到的事件传给自己的父级，一直到 window</p><h4 id="29-BOM-对象有哪些，列举-window-对象？"><a href="#29-BOM-对象有哪些，列举-window-对象？" class="headerlink" title="29 BOM 对象有哪些，列举 window 对象？"></a>29 BOM 对象有哪些，列举 window 对象？</h4><p>window 对象，document 对象，location 对象，navigator 对象，screen 对象， history 对象</p><h4 id="30-说一下-bind-apply-call-的区别？"><a href="#30-说一下-bind-apply-call-的区别？" class="headerlink" title="30 说一下 bind,apply,call 的区别？"></a>30 说一下 bind,apply,call 的区别？</h4><p>1 每个函数都包含两个非继承而来的方法 call（）和 apply（）。call（）和 apply （）都可以改变 this 的指向。<br>2 相同点：call（）和 apply（）的第一个参数都是 this 值，<br>3 区别：call（）的第二、三参数可以是任意类型，而 apply（）的第二参数必须 是数组或 arguments 对象。<br>bind 方法跟 call 方法一样</p><h4 id="31-promise-的三种状态？"><a href="#31-promise-的三种状态？" class="headerlink" title="31 promise 的三种状态？"></a>31 promise 的三种状态？</h4><p>1、初始化状态：pending<br>2、当调用 resolve 成功的状态：pengding=&gt;fulfilled<br>3、当调用 reject 失败的状态：pending=&gt;rejected</p><h4 id="32-new-操作符具体干了什么？"><a href="#32-new-操作符具体干了什么？" class="headerlink" title="32 new 操作符具体干了什么？"></a>32 new 操作符具体干了什么？</h4><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型<br>2、属性和方法被加入到 this 引用的对象中<br>3、新创建的对象由 this 所引用，并且最后隐士的返回 this</p><h4 id="33-url-页面渲染"><a href="#33-url-页面渲染" class="headerlink" title="33 url 页面渲染"></a>33 url 页面渲染</h4><ol><li>DNS 解析</li><li>HTTP 三次握手 -&gt; TCP/IP 连接</li><li>浏览器发送请求</li><li>服务器返回请求的文件 (html)</li><li>浏览器渲染</li></ol><h4 id="34-最大最小宽高与正常宽高执行优先级"><a href="#34-最大最小宽高与正常宽高执行优先级" class="headerlink" title="34 最大最小宽高与正常宽高执行优先级"></a>34 最大最小宽高与正常宽高执行优先级</h4><p>min-width 优先级高于 max-width</p><h4 id="35-float-position-display-优先级"><a href="#35-float-position-display-优先级" class="headerlink" title="35 float position display 优先级"></a>35 float position display 优先级</h4><p>可以看成 postion 的优先级最高，float 其次 display 的最低</p><h4 id="36-display-visibility-区别"><a href="#36-display-visibility-区别" class="headerlink" title="36 display visibility 区别"></a>36 display visibility 区别</h4><p>display 隐藏但不挤占原来的空间 visibility 隐藏但是占据原来的空间</p><h4 id="37-一个页面从输入-URL-到页面加载显示完成，这个过程中都-发生了什么？"><a href="#37-一个页面从输入-URL-到页面加载显示完成，这个过程中都-发生了什么？" class="headerlink" title="37 一个页面从输入 URL 到页面加载显示完成，这个过程中都 发生了什么？"></a>37 一个页面从输入 URL 到页面加载显示完成，这个过程中都 发生了什么？</h4><blockquote><p>过程：浏览器输入域名-&gt;浏览器查询 dns 是否有缓存-&gt;DNS 查询到域名-&gt;TCP/IP 链接（三次握手）-&gt;建立连接-&gt;浏览器发出请求-&gt;服务器响应（1.2.3.4）-&gt;浏 览器会先获得响应头然后在获得响应体</p></blockquote><h4 id="38-前端如何进行登录身份的判断"><a href="#38-前端如何进行登录身份的判断" class="headerlink" title="38 前端如何进行登录身份的判断"></a>38 前端如何进行登录身份的判断</h4><p>前台发送登录请求 后台返回 token，前台得到后台返回的 token，将其写入到 localStorage 中，后续请求中都携带 token 后台判断 token 是否过期，如果过 期就对前台的请求响应过期标识或者状态码 前台得到过期标识后，清除 localStorage 中的 token，然后重定向到 login 路由</p><h4 id="39-简述一下你对-web-性能优化的方案？"><a href="#39-简述一下你对-web-性能优化的方案？" class="headerlink" title="39 简述一下你对 web 性能优化的方案？"></a>39 简述一下你对 web 性能优化的方案？</h4><p>1、减少 http 请求<br> 2、使用浏览器缓存<br> 3、使用压缩<br> 4、将脚本放在底部<br> 5、 使用外部的 js 和 css<br> 6、精简代码 </p><h4 id="40-什么是-ts"><a href="#40-什么是-ts" class="headerlink" title="40 什么是 ts"></a>40 什么是 ts</h4><blockquote><p>TypeScript，简称 ts，是微软开发的一种静态的编程语言，它是 JavaScript 的超集。<br>那么它有什么特别之处呢?<br>简单来说，js 有的 ts 都有，所有js 代码都可以在 ts 里面运行。<br>ts 支持类型支持，ts =  type +JavaScript。</p></blockquote><h4 id="41-ts-和-js-有什么区别呢？"><a href="#41-ts-和-js-有什么区别呢？" class="headerlink" title="41 ts 和 js 有什么区别呢？"></a>41 ts 和 js 有什么区别呢？</h4><p>JavaScript 属于动态编程语言，而ts 属于静态编程语言。<br>js：边解释边执行，错误只有在运行的时候才能发现<br>ts：先编译再执行，在写的时候就会发现错误了（ts不能直接执行，需要先编译成 js ）</p><h3 id="六-REACT"><a href="#六-REACT" class="headerlink" title="六 REACT"></a>六 REACT</h3><h4 id="1、-请列举-react-生命周期函数。"><a href="#1、-请列举-react-生命周期函数。" class="headerlink" title="1、 请列举 react 生命周期函数。"></a>1、 请列举 react 生命周期函数。</h4><blockquote><p>挂载：constructor –&gt; getDerivedStateFromProps –&gt; render –&gt; componentDidMount<br>更新： New props、setState() –&gt; getDerivedStateFromProps –&gt; shouldComponentUpdate –&gt; render –&gt; getSnapshotBeforeUpdate –&gt; componentDidUpdate forceUpdate() –&gt; getDerivedStateFromProps –&gt; render –&gt; getSnapshotBeforeUpdate –&gt; componentDidUpdate<br>卸载： componentWillUnmount</p></blockquote><ul><li><p>第一阶段：装载阶段<br>3 constructor() render() componentDidMount()</p></li><li><p>第二阶段：更新阶段<br>2 [shouldComponentUpdate()] render() componentDidUpdate()</p></li><li><p>第三阶段：卸载阶段<br>1 componentWillUnmount()</p></li><li><p>constructor 生命周期：<br>(1)当 react 组件实例化时，是第一个运行的生命周期；<br>(2)在这个生命周期中，不能使用 this.setState()；<br>(3)在这个生命周期中，不能使用副作用(调接口、dom 操作、定时器、长连接等)；<br>(4)不能把 props 和 state 交叉赋值；</p></li><li><p>componentDidMount 生命周期：<br>(1)相当于是 vue 中的 mounted；<br>(2)它表示 DOM 结构在浏览器中渲染已完成；<br>(3)在这里可以使用任何的副作用；</p></li><li><p>shouldComponentUpdate(nextProps,nextState)生命周期：<br>(1)相当于一个开关，如果返回 true 则更新机制正常执行，如果为 false 则更新机制停 止<br>(2)在 vue 中是没有的；<br>(3)存在的意义：可以用于性能优化，但是不常用，最新的解决方案是使用 PureComponent；<br>(4)理论上，这个生命周期的作用，用于精细地控制声明式变量的更新问题，如果变化的 声明式变量参与了视图渲染则返回 true，如果被变化的声明式变量没有直接或间接参与视图 渲染，则返回 false；</p></li><li><p>componentDidUpdate 生命周期：<br>(1)相当于 vue 中的 updated()；<br>(2)它表示 DOM 结构渲染更新已完成，只发生在更新阶段；<br>(3)在这里，可以执行大多数的副作用，但是不建议；<br>(4)在这里，可以使用 this.setState()，但是要有终止条件判断。</p></li><li><p>componentWillUnmount 生命周期：<br>(1)一般在这里清除定时器、长连接等其他占用内存的构造器；</p></li><li><p>1、 componentWillMount 在渲染前调用,在客户端也在服务端。</p></li><li><p>2、 componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应 的 DOM 结构，可以通过 this.getDOMNode()来进行访问。 如果你想和其他 JavaScript 框架一起使用，可以在这个方法中调用 setTimeout, setInterval 或者发送 AJAX 请求等 操作(防止异步操作阻塞 UI)。</p></li><li><p>3、 componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个 方法在初始化 render 时不会被调用。</p></li><li><p>4、 shouldComponentUpdate 返回一个布尔值。在组件接收到新的 props 或者 state 时被 调用。在初始化时或者使用 forceUpdate 时不被调用。</p></li><li><p>5、 可以在你确认不需要更新组件时使用。</p></li><li><p>6、 componentWillUpdate 在组件接收到新的 props 或者 state 但还没有 render 时被调用。 在初始化时不会被调用。</p></li><li><p>7、 componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。</p></li><li><p>8、 componentWillUnmount 在组件从 DOM 中移除之前立刻被调用。</p></li></ul><h4 id="2-react-中不同组件之间如何做到数据交互？"><a href="#2-react-中不同组件之间如何做到数据交互？" class="headerlink" title="2. react 中不同组件之间如何做到数据交互？"></a>2. react 中不同组件之间如何做到数据交互？</h4><ol><li>父组件向子组件通信：使用 props</li><li>子组件向父组件通信：使用 props 回调</li><li>跨级组件间通信：中间组件层次传递 props，使用 context 对象</li><li>非嵌套组件间通信：使用事件订阅</li></ol><h4 id="3-说一下-Redux-Redux-三大原则"><a href="#3-说一下-Redux-Redux-三大原则" class="headerlink" title="3. 说一下 Redux Redux 三大原则"></a>3. 说一下 Redux Redux 三大原则</h4><p>1.单一数据源： 整个应用的 state 被储存在一棵对象结构中，并且这个对象结构只存在于唯一 一个 store 中<br>2.State 是只读的： redux 中的 state 只读的不可以直接修改 3.使用纯函数(reducer)来执行修改 state 为了修改了 state 数据，redux 定义了一个 reducer 函数来完成 state 数据的修改， reducer 会接收先前的 state 和 action，并返回新的 state</p><blockquote><p>Redux 是一个用于管理 JavaScript 应用程序状态的库。它的工作流程主要包括以下步骤：<br>1、Action 创建：当用户与应用程序交互时（例如点击按钮），会触发一个 Action。Action 是一个描述了发生了什么的普通 JavaScript 对象。<br>2、Dispatch Action：Action 通过 store.dispatch() 方法发送。<br>3、Reducer 处理：Reducer 是一个纯函数，它接收当前的 state 和一个 action，然后返回一个新的 state。<br>4、Store 更新：Store 保存了应用程序的整个 state 树。当一个新的 state 被 reducer 返回后，store 会更新，然后新的 state 会被传递给 UI。</p></blockquote><h4 id="4-React-中-refs-的作用是什么？"><a href="#4-React-中-refs-的作用是什么？" class="headerlink" title="4. React 中 refs 的作用是什么？"></a>4. React 中 refs 的作用是什么？</h4><p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句 柄 可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句 柄，该值会作为回调函数的第一个参数返回</p><h4 id="5-setState-和-replaceState-的区别"><a href="#5-setState-和-replaceState-的区别" class="headerlink" title="5. setState 和 replaceState 的区别"></a>5. setState 和 replaceState 的区别</h4><ul><li>setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖， 不会减少 原来的状态</li><li>replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一 个对象，如果新状态属性减少，那么 state 中就没有这个状态了</li></ul><h4 id="6-调用-super-props-的目的是什么"><a href="#6-调用-super-props-的目的是什么" class="headerlink" title="6. 调用 super(props) 的目的是什么"></a>6. 调用 super(props) 的目的是什么</h4><p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。<br>传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</p><h4 id="7-态-state-和属性-props-之间有何区别"><a href="#7-态-state-和属性-props-之间有何区别" class="headerlink" title="7. 态(state)和属性(props)之间有何区别"></a>7. 态(state)和属性(props)之间有何区别</h4><p>State 是一种数据结构，用于组件挂载时所需数据的默认值。 State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结 果。<br>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并 且就子组件而言，props 是不可变的(immutable)。</p><h4 id="8-Axios-写在哪个生命周期"><a href="#8-Axios-写在哪个生命周期" class="headerlink" title="8. Axios 写在哪个生命周期"></a>8. Axios 写在哪个生命周期</h4><p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会 在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一 次。</p><h4 id="9-React-组件之间的传值"><a href="#9-React-组件之间的传值" class="headerlink" title="9. React 组件之间的传值"></a>9. React 组件之间的传值</h4><ul><li>1.向下传值–父组件向子组件传值 父组件通过 props 传递一个不是方法的数据， 给子组件；</li><li>2.向上传值–子组件向父组件传值 父组件通过 props 向子组件传入一个方法，子 组件在通过调用该方法，并将数据以参数的形式传给父组件，父组件可以在该方 法中对传入的数据进行处理；</li><li>按传值方法分：props，ref，context，updater，redux</li></ul><h4 id="10-React-组件通信如何实现"><a href="#10-React-组件通信如何实现" class="headerlink" title="10. React 组件通信如何实现"></a>10. React 组件通信如何实现</h4><blockquote><p>react 本身:<br>(1)props——父组件向子组件通过 props 传参<br>(2)实例方法——在父组件中可以用 refs 引用子组件，之后就可以调用子 组件的实例方法了<br>(3)回调函数——用于子组件向父组件通信，子组件调用 props 传递过来的 方法<br>(4)状态提升——两个子组件可以通过父组件定义的参数进行传参<br>(5)Context 上下文——一般用作全局主题<br>(6)Render Props——渲染的细节由父组件控制<br>状态管理: (1) mobx/redux/dva——通过在 view 中触发 action，改变 state，进而 改变其他组件的 view</p></blockquote><h4 id="11-说说-React-的路由是什么？"><a href="#11-说说-React-的路由是什么？" class="headerlink" title="11. 说说 React 的路由是什么？"></a>11. 说说 React 的路由是什么？</h4><blockquote><p>路由分为前端路由和后端路由，后端路由是服务器根据用户发起的请求而返回不同 内容，前端路由是客户端根据不同的 URL 去切换组件；在 web 应用前端开发中，路由系统是 最核心的部分，当页面的 URL 发生改变时，页面的显示结果可以根据 URL 的变化而变化，但 是页面不会刷新。 react 生态中路由通常是使用 react-router 来进行配置，其主要构成为：<br>（1）Router——对应路由的两种模式，包括<browsersrouter>与<hashrouter>；<br>（2）route matching 组件——控制路径对应的显示组件，可以进行同步加载和异步加载， <route>；<br>（3）navigation 组件——用做路由切换和跳转，<link>； BrowserRouter 与 HashRouter 的区别：<br>（1）底层原理不一样：BrowserRouter 使用的是 H5 的 history API，不兼容 IE9 及以下 版本；HashRouter 使用的是 URL 的哈希值；<br>（2）path 表现形式不一样：BrowserRouter 的路径中没有#,例如： localhost:3000/demo/test；HashRouter 的路径包含#,例如： localhost:3000/#/demo/test；<br>（3）刷新后对路由 state 参数的影响：BrowserRouter 没有任何影响，因为 state 保存在 history 对象中；HashRouter 刷新后会导致路由 state 参数的丢失；</route></hashrouter></browsersrouter></p></blockquote><h4 id="12-React-有哪些性能优化的手段？"><a href="#12-React-有哪些性能优化的手段？" class="headerlink" title="12. React 有哪些性能优化的手段？"></a>12. React 有哪些性能优化的手段？</h4><ul><li>1、 使用纯组件；</li><li>2、使用 React.memo 进行组件记忆，对于相同的输入，不重复执行；</li><li>3、如果是类组件，使用 shouldComponentUpdate 生命周期事件，可以利用此事件来 决定何时需要重新渲染组件；</li><li>4、路由懒加载；</li><li>5、使用 React Fragments 避免额外标记；</li><li>6、不要使用内联函数定义</li><li>7、避免在 Willxxx 系列的生命周期中进行异步请求，操作 dom 等；</li><li>8、如果是类组件，事件函数在 Constructor 中绑定 bind 改变 this 指向；</li><li>9、避免使用内联样式属性； 10、优化 React 中的条件渲染；</li><li>11、不要在 render 方法中导出数据；</li><li>12、列表渲染的时候加 key；</li><li>13、在函数组件中使用 useCallback 和 useMemo 来进行组件优化，依赖没有变化的话， 不重复执行； 14、类组件中使用 immutable 对象；</li></ul><h4 id="13-React-hooks-用过吗，为什么要用"><a href="#13-React-hooks-用过吗，为什么要用" class="headerlink" title="13. React hooks 用过吗，为什么要用"></a>13. React hooks 用过吗，为什么要用</h4><blockquote><p>Hooks 是 React 在 16.8 版本中出的一个新功能，本质是一种函数，可以实现组件 逻辑复用，Hook 使你在无需修改组件结构的情况下复用状态逻辑，Hook 将组件中相互关联 的部分拆分成更小的函数，组件树层级变浅。组件逻辑耦合度低，组件颗粒度小，从而从整 体上实现性能优化让我们在函数式组件中使用类组件中的状态、生命周期等功能，hooks 的 名字都是以 use 开头。</p></blockquote><p><strong>react：</strong></p><ul><li>1、useState——创建状态 接收一个参数作为初始值；返回一个数组，第一个值为状态，第二个值为 改变状态的函数</li><li>2、useEffect——副作用（数据获取、dom 操作影响页面——在渲染结束之后执行 (1)第一个参数为函数，第二个参数为依赖列表，只有依赖更新时才会执 行函数；返回一个函数，当页面刷新的时候先执行返回函数再执行参数函数 (2)如果不接受第二个参数，那么在第一次渲染完成之后和每次更新渲染 页面的时候，都会调用 useEffect 的回调函数</li><li>3、useRef 返回一个可变的 ref 对象，此索引在整个生命周期中保持不变。可以用来获取元素 或组件的实例，用来做输入框的聚焦或者动画的触发。</li><li>4、useMemo——优化函数组件中的功能函数——在渲染期间执行 （1）接收一个函数作为参数，同样接收第二个参数作为依赖列表，返回值可以是任 何，函数、对象等都可以 （2）这种优化有助于避免在每次渲染时都进行高开销的计算，仅会在某个依赖项改 变时才重新计算</li><li>5、useContext——获取上下文注入的值 (1)接受一个 context 对象，并返回该对象&lt;MyContext.Provider&gt; 元 素的 value 值； const value = useContext(MyContext)；</li><li>6、useLayoutEffect——有 DOM 操作的副作用——在 DOM 更新之后执行 和 useEffet 类似，但是执行时机不同，useLayoutEffect 在 DOM 更新之 后执行，useEffect 在 render 渲染结束后执行，也就是说 useLayoutEffect 比 useEffect 先执行，这是因为 DOM 更新之后，渲染才结束或者渲染还会结束</li><li>7、useCallback——与 useMemo 类似 useMemo 与 useCallback 相同，接收一个函数作为参数，也同样接收第 二个参数作为依赖列表；useCallback 是对传过来的回调函数优化，返回的是一个函数</li></ul><p><strong>react-router:</strong></p><blockquote><p>被 route 包裹的组件，可以直接使用 props 进行路由相关操作，但是没有被 route 包裹的组件只能用 withRouter 高阶组件修饰或者使用 hooks 进行操作</p></blockquote><ul><li>1、useHistory——跳转路由</li><li>2、useLocation——得到 url 对象</li><li>3、useParams——得到 url 上的参数<br><strong>react-redux:</strong></li><li>1、useSelector——共享状态——从 redux 的 store 中提取数据</li><li>2、useDispatch——共享状态——返回 redux 的 store 中对 dispatch 的引用</li></ul><h4 id="14-聊聊-Redux-和-Vuex-的设计思想-Redux-设计和使用的三大原则："><a href="#14-聊聊-Redux-和-Vuex-的设计思想-Redux-设计和使用的三大原则：" class="headerlink" title="14 聊聊 Redux 和 Vuex 的设计思想 Redux 设计和使用的三大原则："></a>14 聊聊 Redux 和 Vuex 的设计思想 Redux 设计和使用的三大原则：</h4><ul><li>（1）单一的数据源：整个应用的 state 被储存在唯一一个 store 中；</li><li>（2）状态是只读的：Store.state 不能直接修改（只读），必须调用 dispatch(action) =&gt; store.reducer =&gt; return newState；action 是一个对象，有 type（操作类型）和 payload（新值）属性；</li><li>（3）状态修改均由纯函数完成：在 Redux 中，通过纯函数 reducer 来确定状态的改 变，因为 reducer 是纯函数，所以相同的输入，一定会得到相同的输出，同时也不支持异步； 返回值是一个全新的 state；<br>vuex 由 State + Muatations(commit) + Actions(dispatch) 组成：</li><li>（1）全局只有一个 Store 实例（单一数据源）；</li><li>（2）Mutations 必须是同步事务，不同步修改的话，会很难调试，不知道改变什么时 候发生，也很难确定先后顺序，A、B 两个 mutation，调用顺序可能是 A -&gt; B，但是最终改 变 State 的结果可能是 B -&gt; A；</li><li>（3）Actions 负责处理异步事务，然后在异步回调中触发一个或多个 mutations， 也可以在业务代码中处理异步事务，然后在回调中同样操作；</li><li>（4）模块化通过 module 方式来处理，这个跟 Redux-combineReducer 类似，在应 用中可以通过 namespaceHelper 来简化使用；</li></ul><h4 id="15-组件绑定和-js-原生绑定事件哪个先执行？"><a href="#15-组件绑定和-js-原生绑定事件哪个先执行？" class="headerlink" title="15 组件绑定和 js 原生绑定事件哪个先执行？"></a>15 组件绑定和 js 原生绑定事件哪个先执行？</h4><p>// 先执行 js 原生绑定事件，再执行合成事件，因为合成事件是发生在冒泡阶段</p><h4 id="16-A-组件嵌套-B-组件，生命周期执行顺序"><a href="#16-A-组件嵌套-B-组件，生命周期执行顺序" class="headerlink" title="16 A 组件嵌套 B 组件，生命周期执行顺序"></a>16 A 组件嵌套 B 组件，生命周期执行顺序</h4><blockquote><p>父组件创建阶段的生命周期钩子函数 constructor<br>父组件创建阶段的生命周期钩子函数 render<br>子组件创建阶段的生命周期钩子函数 constructor<br>子组件创建阶段的生命周期钩子函数 render<br>子组件创建阶段的生命周期钩子函数 componentDidMount<br>父组件创建阶段的生命周期钩子函数 componentDidMount</p></blockquote><h4 id="17-列举重新渲染-render-的情况"><a href="#17-列举重新渲染-render-的情况" class="headerlink" title="17 列举重新渲染 render 的情况"></a>17 列举重新渲染 render 的情况</h4><p>this.setState()<br>this.forceUpdate()<br>// 接受到新的 props<br>// 通过状态管理，mobx、redux 等<br>// 改变上下文</p><h4 id="18-React-按需加载"><a href="#18-React-按需加载" class="headerlink" title="18 React 按需加载"></a>18 React 按需加载</h4><p>// 1、使用 React.lazy， 但是 React.lazy 技术还不支持服务端渲染</p><blockquote><p>const OtherComponent = React.lazy(() =&gt; import(‘./OtherComponent’))<br>// 2、使用 Loadable Components 这个库<br>import loadable from ‘@loadable/component’ const OtherComponent = loadable(() =&gt; import(‘./OtherComponent’))</p></blockquote><h4 id="19-渲染一个-react-组件的过程"><a href="#19-渲染一个-react-组件的过程" class="headerlink" title="19 渲染一个 react 组件的过程"></a>19 渲染一个 react 组件的过程</h4><p>1、babel 编译、<br>2、生成 element、<br>3、生成真实节点(初次渲染)、<br>4、生命周期</p><blockquote><p>componentDidMount -&gt; ….</p></blockquote><h4 id="20-useEffect-和-useLayoutEffect-的区别"><a href="#20-useEffect-和-useLayoutEffect-的区别" class="headerlink" title="20 useEffect 和 useLayoutEffect 的区别"></a>20 useEffect 和 useLayoutEffect 的区别</h4><p>useLayoutEffect 在 js 线程执行完毕即 dom 更新之 后立即执行，而 useEffect 是在渲染结束后才执行，也就是说 useLayoutEffect 比 useEffect 先执行。</p><h4 id="21-hooks-的使用有什么注意事项"><a href="#21-hooks-的使用有什么注意事项" class="headerlink" title="21 hooks 的使用有什么注意事项"></a>21 hooks 的使用有什么注意事项</h4><p>（1）只能在 React 函数式组件或自定义 Hook 中使用 Hook。<br>（2）不要在循环，条件或嵌套函数中调用 Hook，必须始终在 React 函数的顶层使 用 Hook。这是因为 React 需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函 数。一旦在循环或条件分支语句中调用 Hook，就容易导致调用顺序的不一致性，从而产生难 以预料到的后果。</p><h4 id="22-讲讲什么是-JSX-？"><a href="#22-讲讲什么是-JSX-？" class="headerlink" title="22 讲讲什么是 JSX ？"></a>22 讲讲什么是 JSX ？</h4><p>JSX 全称为 JavaScript XML，是 react 中的一种语法糖，可以让我们在 js 代码中 脱离字符串直接编写 html 代码；本身不能被浏览器读取，必须使用@babel/preset-react 和 webpack 等工具将其转换为传统的 JS。<br>主要有以下特点：<br>（1）类 XML 语法容易接受，结构清晰；<br>（2）增强 JS 语义；<br>（3）抽象程度高，屏蔽 DOM 操作，跨平台；<br>（4）代码模块化；</p><h4 id="23-什么是-React-Context"><a href="#23-什么是-React-Context" class="headerlink" title="23 什么是 React Context"></a>23 什么是 React Context</h4><p>What<br>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数 据传递的功能<br>Why<br>某些全局属性，通过父子 props 传递太过繁琐，Context 提供了一种组件之间 共享此类值的方式，而不必显式的通过组件树逐层传递 props<br>When<br>共享那些对于一个组件树而言是全局的数据，例如当前认证的用户、主题或者 首选语言等<br>Where<br>Context 应用场景在于很多不同层级的组件访问同样的数据，这样也使得组件的 复用性变差。 如果你只是想避免层层传递一些属性，组件组合有时候是一个比 Context 更好的 方案，也就是直接传递组件 所以一个技术方案的选定需要针对不同的场景具体分析，采取合适的方案</p><h4 id="24-React-组件间信息传递-Answer"><a href="#24-React-组件间信息传递-Answer" class="headerlink" title="24 React 组件间信息传递 Answer"></a>24 React 组件间信息传递 Answer</h4><ul><li>1.（父组件）向（子组件）传递信息 : porps 传值</li><li>2.（父组件）向更深层的（子组件） 进行传递信息 : context</li><li>3.（子组件）向（父组件）传递信息：callback</li><li>4.没有任何嵌套关系的组件之间传值（比如：兄弟组件之间传值）: 利用共同父组 件 context 通信、自定义事件</li><li>5.利用 react-redux 进行组件之间的状态信息共享 : 组件间状态信息共享：redux、 flux、mobx 等</li></ul><h3 id="七-前端性能优化及自身代码优化"><a href="#七-前端性能优化及自身代码优化" class="headerlink" title="七 前端性能优化及自身代码优化"></a>七 前端性能优化及自身代码优化</h3><ul><li><strong>前端性能优化：</strong></li></ul><ol><li>减少 http 请求次数 （可以合理设置缓存，资源压缩，比如精灵图，懒加载图片等）</li><li>将样式文件引在前面，脚本文件引在最后。 不会造成阻塞其他资源加载。</li><li>异步执行 inline 脚本 。因为浏览器在页面处理方面是单线程的，（多线程会出先分支增删同一元素的冲突问题）。</li><li>避免重复的资源请求，减少不必要的 http 跳转</li></ol><ul><li><strong>自身代码优化：</strong></li></ul><ol><li>代码复用，</li><li>避免使用过多全局变量，</li><li>拆分函数避免函数过于臃肿，职责单一，</li><li>面向对象编程，对功能进行封装复用，</li><li>适当的注释，</li><li>内存管理。</li></ol><blockquote><p>==&gt; 函数式编程，顾名思义，这种编程是以函数思维做为核心，在这种思维的角度去思考问题。<br>==&gt;缺点 :所有的数据都是不可以改变的，严重占据运行资源，导致运行速度也不够快<br>==&gt;面向对象编程：为了编写可以重用的代码导致许多无用代码的产生，并且许多人为了面向对象而面向对象导致代码给后期维护带来很多麻烦。<br>面向对象三大要素: 封装 继承 多态</p></blockquote><ul><li><p><strong>vue 项目<code>性能优化</code>及<code>首屏性能优化</code></strong></p><ol><li>按需加载， 当前主流的 ui 框架都支持按需加载</li><li>服务端代码压缩 gzip</li><li>代码分块</li><li>路由组件懒加载 <code>const HelloWorld = ()=&gt;import(&quot;@/components/HelloWorld&quot;)</code></li><li>图片懒加载/服务端渲染（ssr）</li></ol><p><a href="https://www.jianshu.com/p/2c929f211d08" target="_blank" rel="noopener">进阶版首屏优化</a></p></li></ul><h3 id="八-webpack"><a href="#八-webpack" class="headerlink" title="八 webpack"></a>八 webpack</h3><h4 id="1-打包优化"><a href="#1-打包优化" class="headerlink" title="1. 打包优化"></a>1. 打包优化</h4><p><a href="https://segmentfault.com/a/1190000011138081?utm_source=tag-newest" target="_blank" rel="noopener">转:webpack 打包优化解决方案</a></p><h4 id="2-配置生产测试环境"><a href="#2-配置生产测试环境" class="headerlink" title="2. 配置生产测试环境"></a>2. 配置生产测试环境</h4><p><a href="https://blog.csdn.net/xhjfor/article/details/80796801" target="_blank" rel="noopener">转:webpack 实现开发、测试、生产等环境的打包切换</a></p><h4 id="3-webpack-五个核心概念？"><a href="#3-webpack-五个核心概念？" class="headerlink" title="3.webpack 五个核心概念？"></a>3.webpack 五个核心概念？</h4><ul><li>ntry 入口 本项目应该使用哪个模块，来作为构建其内部依赖图的开始（指定打包入口文件）</li><li>output 输出 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist</li><li>loader loader 让 webpack 能够去处理那些非 js 文件(webpack 自身只理解 js)</li><li>plugins 插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一 直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的 任务。</li><li>mode 模式 通过选择 development 或 production 之中的一个，来设置 mode 参数，你 可以启用相应模式下的 webpack 内置的优化</li></ul><h3 id="九-小程序"><a href="#九-小程序" class="headerlink" title="九 小程序"></a>九 小程序</h3><h4 id="1-请谈谈-wxml-与标准的-html-的异同？"><a href="#1-请谈谈-wxml-与标准的-html-的异同？" class="headerlink" title="1. 请谈谈 wxml 与标准的 html 的异同？"></a>1. 请谈谈 wxml 与标准的 html 的异同？</h4><pre class="line-numbers language-js"><code class="language-js"> 都是用来描述页面的结构；都由标签、属性等构成；标签名字不一样，且小程序标签更少，单一标签更多；多了一些 wx<span class="token punctuation">:</span><span class="token keyword">if</span> 这样的属性以及 <span class="token operator">**</span><span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">**</span>这样的表达式WXML 仅能在微信小程序开发者工具中预览，而 HTML 可以在浏览器内 预览组件封装不同， WXML 对组件进行了重新封装，小程序运行在 JS Core 内，没有 DOM 树和 window 对象，小程序中无法 使用 window 对象和 document 对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-请谈谈-WXSS-和-CSS-的异同？"><a href="#2-请谈谈-WXSS-和-CSS-的异同？" class="headerlink" title="2. 请谈谈 WXSS 和 CSS 的异同？"></a>2. 请谈谈 WXSS 和 CSS 的异同？</h4><p>都是用来描述页面的样子；<br>WXSS 具有 CSS 大部分的特性，也做了一些扩充和修改；<br>WXSS 新增了尺寸单位，WXSS 在底层支持新的尺寸单位 rpx；<br>WXSS 仅支持部分 CSS 选择器；<br>WXSS 提供全局样式与局部样式<br>WXSS 不支持 window 和 dom 文档流</p><h4 id="3-请谈谈小程序的双向绑定和-vue-的异同？"><a href="#3-请谈谈小程序的双向绑定和-vue-的异同？" class="headerlink" title="3.请谈谈小程序的双向绑定和 vue 的异同？"></a>3.请谈谈小程序的双向绑定和 vue 的异同？</h4><p>大体相同，但小程序直接 this.data 的属性是不可以同步到视图的，必须调用 this.setData() 方法！ 1.双向绑定：vue 默认支持双向绑定，微信小程序需要借助 data。 2.取值：vue 中，通过 this.reason 取值。小程序中，通过 this.data.reason 取值。 3.定义方法：小程序使用 在 app.js 中定义即可，vue 的方法通过写在 method 中进行定 义。</p><h4 id="4-请谈谈小程序的生命周期函数？"><a href="#4-请谈谈小程序的生命周期函数？" class="headerlink" title="4.请谈谈小程序的生命周期函数？"></a>4.请谈谈小程序的生命周期函数？</h4><p>onLoad() 页面加载时触发，只会调用一次，可获取当前页面路径中的参 数。<br>onShow() 页面显示/切入前台时触发，一般用来发送数据请求；<br>onReady() 页面初次渲染完成时触发, 只会调用一次，代表页面已可和视 图层进行交互。<br>onHide() 页面隐藏/切入后台时触发, 如底部 tab 切换到其他页面或小 程序切入后台等。<br>onUnload() 页面卸载时触发，如 redirectTo 或 navigateBack 到其他页面 时。<br>onPullDownRefresh() 下拉刷新的钩子函数 用户下拉刷新时会自动走到 这个函数中<br>onReachBottom() 上翻到底的钩子函数</p><h4 id="5-小程序关联微信公众号如何确定用户的唯一性？"><a href="#5-小程序关联微信公众号如何确定用户的唯一性？" class="headerlink" title="5. 小程序关联微信公众号如何确定用户的唯一性？"></a>5. 小程序关联微信公众号如何确定用户的唯一性？</h4><p>使用 wx.getUserInfo 方法 withCredentials 为 true 时，可获取 encryptedData， 里面有 union_id.后端需要进行对称解密</p><h4 id="6-使用-webview-直接加载要注意哪些事项？"><a href="#6-使用-webview-直接加载要注意哪些事项？" class="headerlink" title="6. 使用 webview 直接加载要注意哪些事项？"></a>6. 使用 webview 直接加载要注意哪些事项？</h4><ol><li>必须要在小程序后台使用管理员添加业务域名；</li><li>h5 页面跳转至小程序的脚步必须是 1.3.1 以上；</li><li>微信分享只可以是小程序的主名称，如要自定义分享内容，需小程序版本 在 1.7.1 以上；</li><li>h5 的支付不可以是微信公众号的 appid，必须是小程序的 appid，而且用 户的 openid 也必须是用户和小程序的</li></ol><h4 id="7-简述五个路由的区别"><a href="#7-简述五个路由的区别" class="headerlink" title="7. 简述五个路由的区别"></a>7. 简述五个路由的区别</h4><p>wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页 面<br>wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面<br>wx.switchTab()：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面<br>wx.navigateBack()关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层<br>wx.reLaunch()：关闭所有页面，打开到应用内的某个页面</p><h4 id="8-微信小程序与-H5-的区别？"><a href="#8-微信小程序与-H5-的区别？" class="headerlink" title="8.微信小程序与 H5 的区别？"></a>8.微信小程序与 H5 的区别？</h4><ol><li>运行环境不同（小程序在微信运行，h5 在浏览器运行）；</li><li>开发成本不同（h5 需要兼容不同的浏览器）；</li><li>获取系统权限不同（系统级权限可以和小程序无缝衔接）；</li><li>应用在生产环境的运行流畅度（h5 需不断对项目优化来提高用户体验）；</li></ol><h4 id="9-如何实现登录数据的持久化"><a href="#9-如何实现登录数据的持久化" class="headerlink" title="9.如何实现登录数据的持久化 ?"></a>9.如何实现登录数据的持久化 ?</h4><p>可以通过 wx.setStorageSync(‘键名’, 对应的值)来进行数据持久化</p><h4 id="10-微信小程序如何进行双向绑定"><a href="#10-微信小程序如何进行双向绑定" class="headerlink" title="10. 微信小程序如何进行双向绑定"></a>10. 微信小程序如何进行双向绑定</h4><ol><li>通过 bind-tap 点击事件 向 app.js 定义的方法中获取回执</li><li>设置 data 的值 实现双向绑定</li></ol><h4 id="业务难点"><a href="#业务难点" class="headerlink" title="业务难点"></a>业务难点</h4><h4 id="支付环节，那么微信支付的-流程是否可以简单说-一下？"><a href="#支付环节，那么微信支付的-流程是否可以简单说-一下？" class="headerlink" title="支付环节，那么微信支付的 流程是否可以简单说 一下？"></a>支付环节，那么微信支付的 流程是否可以简单说 一下？</h4><p>临时凭证 获取 wxid<br>生成 repayid<br>json，返回给小程序，小程序调支付窗口。<br>支持成功提示 + POST 回调。</p><h3 id="十-git-命令"><a href="#十-git-命令" class="headerlink" title="十 git 命令"></a>十 git 命令</h3><p>git config。配置 Git 的相关参数。Git 一共有 3 个配置文件：1.仓库级的配置文件： 在仓库的 …<br>git clone。从远程仓库克隆一个版本库到本地。# 默认在当前目录下创建和版本库名 相同的文件夹并 …<br>git init。初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。 # 初始化本地仓 …<br>git status。查看本地仓库的状态。# 查看本地仓库的状态 $ git status # 以简短模 式查看本地仓库的</p><blockquote><p>git init # 初始化本地代码仓<br>git add . # 添加本地代码<br>git commit -m “add local source” # 提交本地代码<br>git pull origin master # 下载远程代码<br>git merge master # 合并 master 分支<br>git push -u origin master # 上传代码</p></blockquote><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>未完待续,持续更新中……</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 年的思考总结</title>
      <link href="/2019/12/30/nian-mo-zong-jie/"/>
      <url>/2019/12/30/nian-mo-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><!-- # 自我介绍首先依照国际惯例来个自我介绍，参加工作两年。来掘金一年多了，刚开始的时候觉得这平台不错，文章质量过硬，而且人气很高；经常在搜索引擎搜素不到的知识点，在掘金能够找到对应的博客。再来讲讲我的工作，作为一个前端，我的技术栈是 vue、css3 、canvas、gis、react-native 以及会点 react。 --><h1 id="2019-年成长之路"><a href="#2019-年成长之路" class="headerlink" title="2019 年成长之路"></a>2019 年成长之路</h1><blockquote><p>2019 年对于整个互联网行业来说是十分坎坷的一年，从年头开始整个行业就被各种的倒闭、欠薪以及裁员等负面消息所笼盖，被称之为互联网寒冬。</p></blockquote><p>作为一名小前端，为了不被寒冬冻僵，2019 年我在努力地为自己穿上防寒外套。做了下面几个方面进行了学习和研究：</p><h1 id="React-Native"><a href="#React-Native" class="headerlink" title="React-Native()"></a>React-Native()</h1><p>从 2019 年 9 月份开始到现在,断断续续做了几个月。我们做的是一款环保类型的内部使用 APP,主要检测业务空气、水环境等等业务,说到这里不得不说下 RN 的优劣:</p><h2 id="RN-的优势"><a href="#RN-的优势" class="headerlink" title="RN 的优势"></a>RN 的优势</h2><ul><li><p>调试方便<br>ipa 安装好之后，就不需要频繁编译了，只需要 reload 一下，把 js 代码从云服务器下载下来就可以呈现改变代码后的效果。而且 RN 支持 hotReload，在调试界面的时候非常方便，修改代码之后保存，界面就自动跟着变化，这一点在调试的时候实在很爽，不过有时候有点慢，需要 reload。chrome 在线调试也挺不错，可以打断点，看日志。虽然没有 xcode 或者 Android Studio 那么浑然一体，但是作为脚本语言的调试工具，也是很厉害了。</p></li><li><p>css-layout 布局<br>这对于前端程序员来说，降低了不少学习成本，也大大减少了代码量。但是对于 iOS 或者安卓开发者来说，刚开始接触的时候，得接受一些思想上的转变。</p></li><li><p>跨平台<br>大多数代码，只需要写一套，安卓和 iOS 就都可以运行了，游戏逻辑和数据。界面上一部分有一些平台区分，毕竟是从 react 包装上来的。刚开始学 iOS 的时候，就想象着，要是有一种跨平台的开发形式就很 6 了，没想到过了几年就有了。跨平台理论上是可以减少开发成本的，减少开发人员数量，但是实际效果并不然，后面说。</p></li><li><p>热更新<br>这可能也是大多数公司选择使用 RN 的主要原因。频繁的 app 升级会让用户很烦，而且苹果的审核真是很麻烦。现在很多大型 app 都使用了 RN，毕竟繁多的业务迭代，每次都通过 APP 审核，也算是噩梦啊。</p></li></ul><h2 id="RN-的不完善"><a href="#RN-的不完善" class="headerlink" title="RN 的不完善"></a>RN 的不完善</h2><p>容我吐槽一下，不完善的地方实在太多了，和原生开发体验来比，堪称天壤之别。RN 现在的最新版本是 0.46，我们工程中用的是 0.42，毕竟还没上 1.0 呢。<br>去掉主观情感，下面列举一下部分不完善的点：</p><ul><li><p>开发体验一般。<br>虽然 js 语法很灵活，但毕竟是脚本语言，调试起来还是不方便，不好查错。我们用的表现较好的 vscode 编辑器，就这都感觉各种跳转很不方便，动不动就得全局搜索，可能是 xcode 用习惯了吧。脚本语言的编写也会慢慢习惯吧。</p></li><li><p>文档很粗略<br>官网上的文档，就只是简单介绍用法和各个控件的属性，对细节的描述很少。当你遇到难解决的问题或者踩到坑了，上面基本找不到答案。</p></li><li><p>两个平台还没有完全统一<br>很多控件都是 iOS 专属，或者安卓专属。还有同一些控件，在不同平台上表现差异很大。</p></li><li><p>控件不完善<br>这个其实挺多的，最基本的 ListView，功能缺失，坑很多。Text 不支持富文本，动画，手势，ScrollView 等等等等。不能一一列举。作为聊天软件，富文本功能必须实现啊，用于 emoji 表情和文字的混合显示。被迫自己搞了一套实现方案，现在还有点小 bug。具体实现方案参考<a href="http://blog.csdn.net/gang544043963/article/details/70245850" target="_blank" rel="noopener">http://blog.csdn.net/gang544043963/article/details/70245850</a></p></li></ul><h1 id="React-ps-平时工作不用-闲暇研究…"><a href="#React-ps-平时工作不用-闲暇研究…" class="headerlink" title="React ( ps:平时工作不用,闲暇研究… )"></a>React ( ps:平时工作不用,闲暇研究… )</h1><p>前端三大主流框架:React、Vue、Angular。</p><h3 id="一、vue-js"><a href="#一、vue-js" class="headerlink" title="一、vue.js"></a>一、vue.js</h3><ul><li><p>优点：更轻量，单页面，简单易学</p></li><li><p>缺点：不支持 IE8</p></li></ul><h3 id="二、Angular"><a href="#二、Angular" class="headerlink" title="二、Angular"></a>二、Angular</h3><ul><li><p>优点：模块化功能强大、自定义 directive 非常灵活、双向数据绑定，依赖注入</p></li><li><p>缺点：比较笨重，学习成本高，不兼容 IE6/7</p></li></ul><h3 id="三、react"><a href="#三、react" class="headerlink" title="三、react"></a>三、react</h3><ul><li><p>优点：速度快、跨浏览器兼容、单向数据流、兼容性好</p></li><li><p>缺点：并不是一个完整的框架，需要加上 ReactRouter 和 Flux 才能完成。</p></li></ul><h1 id="陆续更新中…"><a href="#陆续更新中…" class="headerlink" title="陆续更新中…"></a>陆续更新中…</h1><h1 id="2020-展望"><a href="#2020-展望" class="headerlink" title="2020 展望"></a>2020 展望</h1>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React小技巧汇总</title>
      <link href="/2019/11/06/react-zong-jie/"/>
      <url>/2019/11/06/react-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1347529350&auto=1&height=66"></iframe></div><p>自学 <code>React.js</code> 一段时间了，把使用过程遇到的小坑和小技巧记录下来，希望能够帮助到其他人。此文章是长篇大论你只有耐得住寂寞，禁得住诱惑才会有所成长……</p><h1 id="React-小技巧汇总"><a href="#React-小技巧汇总" class="headerlink" title="React 小技巧汇总"></a>React 小技巧汇总</h1><hr><h2 id="一、工具篇"><a href="#一、工具篇" class="headerlink" title="一、工具篇"></a>一、工具篇</h2><h3 id="1-显示-html"><a href="#1-显示-html" class="headerlink" title="1.显示 html"></a>1.显示 html</h3><pre><code>  &lt;div dangerouslySetInnerHTML={{ __html: LANG.auth_register_tips1 }}/&gt;</code></pre><h3 id="2-常用组件"><a href="#2-常用组件" class="headerlink" title="2.常用组件"></a>2.常用组件</h3><ul><li><code>axios</code>(http 请求模块，可用于前端任何场景，很强大)=&gt;<a href="https://www.jianshu.com/p/79816fa9c54f" target="_blank" rel="noopener">封装 axios</a></li><li><code>echarts-for-react</code>(可视化图表，别人基于 react 对 echarts 的封装，足够用了)=&gt;<a href="https://www.jianshu.com/p/f6c1c4618c22" target="_blank" rel="noopener">echarts-for-react</a></li><li><code>recharts</code>(另一个基于 react 封装的图表)=&gt;<a href="https://recharts.cosx.org/recharts" target="_blank" rel="noopener">官网</a></li><li><code>nprogress</code>(顶部加载条，蛮好用)</li><li><code>react-draft-wysiwyg</code>(别人基于 react 的富文本封装，如果找到其他更好的可以替换)</li><li><code>react-draggable</code>(拖拽模块，找了个简单版的)</li><li><code>screenfull</code>(全屏插件)</li><li><code>photoswipe</code>(图片弹层查看插件，不依赖 jQuery，还是蛮好用)</li><li><code>animate.css</code>(css 动画库)</li><li><code>redux Web</code> 应用是一个状态机，视图与状态是一一对应的.所有的状态，保存在一个对象里面</li><li><code>redux-logger</code> 日志</li><li><code>Reselect</code> 记忆组件</li><li><code>redux-thunk</code> 为了解决异步 action 的问题</li><li><code>redux-saga</code> 为了解决异步 action 的问题</li><li><code>react-router-redux</code> 保持路由与应用状态(state)同步</li><li><code>react-router-dom</code>路由基本组件 1).<a href="https://www.jianshu.com/p/8954e9fb0c7e" target="_blank" rel="noopener">在 React 中使用 react-router-dom 路由</a> 2).<a href="https://www.jianshu.com/p/19ef80d2e122" target="_blank" rel="noopener">react-router-dom 及组件生命周期</a></li></ul><h3 id="3-react-devtools-调试工具"><a href="#3-react-devtools-调试工具" class="headerlink" title="3.react-devtools 调试工具"></a>3.react-devtools 调试工具</h3><p><a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">工具地址</a>:<a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">https://github.com/facebook/react-devtools</a></p><p>或者 直接谷歌应用商店搜索<code>react-devtools</code>进行安装.</p><h2 id="二、组件通讯篇"><a href="#二、组件通讯篇" class="headerlink" title="二、组件通讯篇"></a>二、组件通讯篇</h2><p><img src="1.jpg" alt></p><p><strong>需要组件之进行通信的几种情况</strong></p><ul><li>redux 架构</li><li>父组件向子组件 —— props</li><li>子组件向父组件 —— props.funciton 接收参数</li><li>利用事件机制</li></ul><h3 id="1-父组件向子组件通信"><a href="#1-父组件向子组件通信" class="headerlink" title="1. 父组件向子组件通信"></a>1. 父组件向子组件通信</h3><p>React 数据流动是单向的,父组件向子组件通信也是最常见的;父组件通过 props 向子组件传递需要的信息</p><h3 id="2-子组件向父组件通信"><a href="#2-子组件向父组件通信" class="headerlink" title="2. 子组件向父组件通信"></a>2. 子组件向父组件通信</h3><ul><li>利用回调函数</li><li>利用自定义事件机制</li></ul><p><strong>子组件改变父组件的 state</strong></p><pre><code>  // 一般改变state值的一种方式  const { data } = this.state;  this.setState({ data: {...data, key: 1 } });  // 另外一种可以通过callback的方式改变state的值  this.setState(({ data }) =&gt; ({ data: {...data, key: 1 } }));  // 还可以  this.setState((state, props) =&gt; {  return { counter: state.counter + props.step };  });</code></pre><h3 id="3-跨级组件通信"><a href="#3-跨级组件通信" class="headerlink" title="3. 跨级组件通信"></a>3. 跨级组件通信</h3><ul><li>层层组件传递 props<blockquote><p>例如 A 组件和 B 组件之间要进行通信,先找到 A 和 B 公共的父组件,A 先向 C 组件通信,C 组件通过 props 和 B 组件通信,此时 C 组件起的就是中间件的作用</p></blockquote></li><li>使用 context<br>下面例子中的组件关系: ListItem 是 List 的子组件,List 是 app 的子组件</li></ul><p>ListItem.js</p><pre><code>  import React, { Component } from &#39;react&#39;;  import PropTypes from &#39;prop-types&#39;;  class ListItem extends Component {  // 子组件声明自己要使用context  static contextTypes = {        color: PropTypes.string,  }  static propTypes = {        value: PropTypes.string,  }  render() {        const { value } = this.props;        return (              &lt;li style={{ background: this.context.color }}&gt;              &lt;span&gt;{value}&lt;/span&gt;              &lt;/li&gt;        );  }  }  export default ListItem;</code></pre><p>List.js</p><pre><code>  import ListItem from &#39;./ListItem&#39;;  class List extends Component {  // 父组件声明自己支持context  static childContextTypes = {        color: PropTypes.string,  }  static propTypes = {        list: PropTypes.array,  }  // 提供一个函数,用来返回相应的context对象  getChildContext() {        return {              color: &#39;red&#39;,        };  }  render() {        const { list } = this.props;        return (              &lt;div&gt;              &lt;ul&gt;                    {                          list.map((entry, index) =&gt;                          &lt;ListItem key={`list-${index}`} value={entry.text} /&gt;,                    )                    }              &lt;/ul&gt;              &lt;/div&gt;        );  }  }  export default List;</code></pre><p>App.js</p><pre><code>  import React, { Component } from &#39;react&#39;;  import List from &#39;./components/List&#39;;  const list = [  {        text: &#39;题目一&#39;,  },  {        text: &#39;题目二&#39;,  },  ];  export default class App extends Component {  render() {        return (              &lt;div&gt;              &lt;List                    list={list}              /&gt;              &lt;/div&gt;        );  }  }</code></pre><h3 id="4-没有嵌套关系的组件通信"><a href="#4-没有嵌套关系的组件通信" class="headerlink" title="4. 没有嵌套关系的组件通信"></a>4. 没有嵌套关系的组件通信</h3><!-- + 使用自定义事件机制>在componentDidMount事件中,如果组件挂载完成,再订阅事件;在组件卸载的时候,在componentWillUnmount事件中取消事件的订阅;以常用的发布/订阅模式举例,借用Node.js Events模块的浏览器版实现 --><ul><li>组件间通信之 onRef 方法</li></ul><blockquote><p>组件间通信除了 props 外还有 onRef 方法，不过 React 官方文档建议不要过度依赖 ref。本文使用 onRef 语境为在表单录入时提取公共组件，在提交时分别获取表单信息。</p></blockquote><p>下面 demo 中点击父组件按钮可以获取子组件全部信息，包括状态和方法，可以看下 demo 中控制台打印。</p><pre><code>  // 父组件  class Parent extends React.Component {  testRef=(ref)=&gt;{  this.child = ref  console.log(ref) // -&gt; 获取整个Child元素  }  handleClick=()=&gt;{  alert(this.child.state.info) // -&gt; 通过this.child可以拿到child所有状态和方法  }  render() {  return &lt;div&gt;        &lt;Child onRef={this.testRef} /&gt;        &lt;button onClick={this.handleClick}&gt;父组件按钮&lt;/button&gt;  &lt;/div&gt;  }  }  // 子组件  class Child extends React.Component {  constructor(props) {  super(props)  this.state = {        info:&#39;快点击子组件按钮哈哈哈&#39;  }  }  componentDidMount(){  this.props.onRef(this)  console.log(this) // -&gt;将child传递给this.props.onRef()方法  }  handleChildClick=()=&gt;{  this.setState({info:&#39;通过父组件按钮获取到子组件信息啦啦啦&#39;})  }  render(){  return &lt;button onClick={this.handleChildClick}&gt;子组件按钮&lt;/button&gt;  }  }</code></pre><p><code>原理</code>：当在子组件中调用 onRef 函数时，正在调用从父组件传递的函数。this.props.onRef（this）这里的参数指向子组件本身，父组件接收该引用作为第一个参数：onRef = {ref =&gt;（this.child = ref）}然后它使用 this.child 保存引用。之后，可以在父组件内访问整个子组件实例，并且可以调用子组件函数。</p><h2 id="三、路由篇"><a href="#三、路由篇" class="headerlink" title="三、路由篇"></a>三、路由篇</h2><blockquote><p>使用 React 构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在 React 中，常用的有两个包可以实现这个需求，那就是 react-router 和 react-router-dom。本文主要针对 react-router-dom 进行说明。</p></blockquote><h3 id="1、React-Router-中有三类组件"><a href="#1、React-Router-中有三类组件" class="headerlink" title="1、React Router 中有三类组件:"></a>1、React Router 中有三类组件:</h3><ul><li>router 组件（BrowserRouter，HashRouter）</li><li>route matching 组件（Route，Switch）</li><li>navigation 组件（Link）</li></ul><blockquote><p>基于 React Router 的 web 应用，根组件应该是一个 router 组件（BrowserRouter，HashRouter）。 项目中，react-router-dom 提供了和两种路由。两种路由都会创建一个 history 对象。如果我们的应用有服务器响应 web 的请求，我们通常使用<browserrouter>组件; 如果使用静态文件服务器，则我们应该使用<hashrouter>组件</hashrouter></browserrouter></p></blockquote><h3 id="2、HashRouter-和-BrowserRouter"><a href="#2、HashRouter-和-BrowserRouter" class="headerlink" title="2、HashRouter 和 BrowserRouter"></a>2、HashRouter 和 BrowserRouter</h3><p>其实就是路由的 hash 和 history 两种模式（要是不了解这两种模式之间的区别那就需要去恶补下啦）</p><p>并且这两个组件是路由的容器，<code>必须在最外层</code>—&gt;内部是 <code>Route</code></p><pre><code>  // hash模式  ReactDom.render(  &lt;HashRouter&gt;        &lt;Route path=&quot;/&quot; component={Home}/&gt;  &lt;/HashRouter&gt;  )  // history模式  ReactDom.render(  &lt;BrowserRouter&gt;        &lt;Route path=&quot;/&quot; component={Home}/&gt;  &lt;/BrowserRouter&gt;  )</code></pre><p><strong>下面说说 HashRouter 和 BrowserRouter 上的参数</strong></p><ul><li>basename 路由的基础链接，用来部署到非根目录下，比如你需要将项目部署到 <a href="http://www.xxxx.com/web" target="_blank" rel="noopener">www.xxxx.com/web</a> 下，则设置 basename=”/web”</li><li>getUserConfirmation 用来拦截 Prompt 组件，并且决定是否跳转</li><li>forceRefresh 用来设置是否强制浏览器整体刷新，默认值为 false</li><li>keLength 用来设置 location.key 的长度，默认是 6，可以自定义</li></ul><h3 id="3、Route"><a href="#3、Route" class="headerlink" title="3、Route"></a>3、Route</h3><p>Route 是路由的一个原材料，它是控制路径对应显示的组件</p><p>Route 的参数:</p><ul><li>path 跳转的路径</li><li>component 对应路径显示的组件</li><li>render 可以自己写 render 函数返回具体的 dom，而不需要去设置 component</li><li>location 传递 route 对象，和当前的 route 对象对比，如果匹配则跳转</li><li>exact 匹配规则，true 的时候则精确匹配。</li></ul><h3 id="4、Router"><a href="#4、Router" class="headerlink" title="4、Router"></a>4、Router</h3><p>低级路由，适用于任何路由组件，主要和 redux 深度集成，使用必须配合 history 对象</p><p>使用 Router 路由的目的是和状态管理库如 redux 中的 history 同步对接</p><pre><code>  &lt;Router history={history}&gt;  ...  &lt;/Router&gt;</code></pre><h3 id="5、Link-和-NavLink"><a href="#5、Link-和-NavLink" class="headerlink" title="5、Link 和 NavLink"></a>5、Link 和 NavLink</h3><p>两者都是跳转路由，NavLink 的参数更多些<br><strong>Link 的 api</strong></p><ul><li><p>to 有两种写法，表示跳转到哪个路由</p></li><li><p>字符串写法</p>  <link to="/a"></li><li><p>对象写法</p><pre><code>&lt;Link to={{      pathname: '/courses',      search: '?sort=name',      hash: '#the-hash',      state: { fromDashboard: true }      }}/&gt;</code></pre></li><li><p>replace 就是将 push 改成 replace</p></li><li><p>innerRef 访问 Link 标签的 dom</p></li></ul><p><strong>NavLink 的 api</strong></p><ul><li><p>Link 的所有 api</p></li><li><p>activeClassName 路由激活的时候设置的类名</p></li><li><p>activeStyle 路由激活设置的样式</p></li><li><p>exact 参考 Route，符合这个条件才会激活 active 类</p></li><li><p>strict 参考 Route，符合这个条件才会激活 active 类</p></li><li><p>isActive 接收一个回调函数，active 状态变化的时候回触发，返回 false 则中断跳转</p><pre><code>const oddEvent = (match, location) =&gt; {console.log(match,location)if (!match) {return false}console.log(match.id)return true}&lt;NavLink isActive={oddEvent} to=&quot;/a/123&quot;&gt;组件一&lt;/NavLink&gt;</code></pre></li></ul><ul><li><p>location 接收一个 location 对象，当 url 满足这个对象的条件才会跳转</p><pre><code>&lt;NavLink to=&quot;/a/123&quot; location={{ key:"mb5wu3", pathname:"/a/123" }}/&gt;</code></pre></li></ul><h3 id="6、Redirect"><a href="#6、Redirect" class="headerlink" title="6、Redirect"></a>6、Redirect</h3><p>Redirect 重定向很简单，我们直接看代码即可</p><pre><code>  // 基本的重定向  &lt;Redirect to=&quot;/somewhere/else&quot; /&gt;  // 对象形式  &lt;Redirect  to={{      pathname: "/login",      search: "?utm=your+face",      state: { referrer: currentLocation }      }}  /&gt;  // 采用push生成新的记录  &lt;Redirect push to=&quot;/somewhere/else&quot; /&gt;  // 配合Switch组件使用，form表示重定向之前的路径，如果匹配则重定向，不匹配则不重定向  &lt;Switch&gt;  &lt;Redirect from=&#39;/old-path&#39; to=&#39;/new-path&#39;/&gt;  &lt;Route path=&#39;/new-path&#39; component={Place}/&gt;  &lt;/Switch&gt;</code></pre><h3 id="7、Switch"><a href="#7、Switch" class="headerlink" title="7、Switch"></a>7、Switch</h3><p>路由切换，只会匹配第一个路由，可以想象成 tab 栏</p><p>Switch 内部只能包含 Route、Redirect、Router</p><pre><code>  &lt;Switch&gt;  &lt;Route exact path=&quot;/&quot; component={Home}/&gt;  &lt;Route path=&quot;/about&quot; component={About}/&gt;  &lt;Route path=&quot;/:user&quot; component={User}/&gt;  &lt;Route component={NoMatch}/&gt;  &lt;/Switch&gt;</code></pre><h3 id="8、withRouter"><a href="#8、withRouter" class="headerlink" title="8、withRouter"></a>8、withRouter</h3><p>当一个非路由组件也想访问到当前路由的 match,location,history 对象，那么 withRouter 将是一个非常好的选择，可以理解为将一个组件包裹成路由组件</p><pre><code>  import { withRouter } from &#39;react-router-dom&#39;  const MyComponent = (props) =&gt; {  const { match, location, history } = this.props  return (        &lt;div&gt;{props.location.pathname}&lt;/div&gt;  )  }  const FirstTest = withRouter(MyComponent);</code></pre><h3 id="9、history-对象"><a href="#9、history-对象" class="headerlink" title="9、history 对象"></a>9、history 对象</h3><p>用过 vue 的都知道，vue-router 有组件形式的导航，也有编程式导航，那 react-router 怎么使用 api 来控制前进后退和刷新呢？这就需要我们来说明下<code>history</code>对象的作用了其实在每个路由组件中我们可以使用<code>this.props.history</code>获取到<code>history</code>对象，也可以使用 withRouter 包裹组件获取，在 history 中封装了 push，replace，go 等方法，具体内容如下</p><pre><code>  History {  length: number;  action: Action;  location: Location;  push(path: Path, state?: LocationState): void; // 调用push前进到一个地址,可以接受一个state对象，就是自定义的路由数据  push(location: LocationDescriptorObject): void; // 接受一个location的描述对象  replace(path: Path, state?: LocationState): void; // 用页面替换当前的路径，不可再goBack  replace(location: LocationDescriptorObject): void; // 同上  go(n: number): void; // 往前走多少也页面  goBack(): void; // 返回一个页面  goForward(): void; // 前进一个页面  block(prompt?: boolean | string | TransitionPromptHook): UnregisterCallback;  listen(listener: LocationListener): UnregisterCallback;  createHref(location: LocationDescriptorObject): Href;  }</code></pre><p>这样我们想使用 api 来操作前进后退就可以调用 history 中的方法啦</p><p>其次也可通过暗转 history 库来实现，具体案例如下</p><pre><code>  import { BrowserRouter } from &#39;react-router-dom&#39;;  const history = require(&#39;history&#39;).createBrowserHistory();  /**  * forceRefresh: bool  * 作用：当浏览器不支持 HTML5 的 history API 时强制刷新页面。  */  const supportsHistory = &#39;pushState&#39; in window.history;  &lt;BrowserRouter        history={history}        basename=&quot;/&quot;        forceRefresh={!supportsHistory}        &gt;        {/* 路由入口 */}        ......  &lt;/BrowserRouter&gt;</code></pre><h3 id="10、-React-router-页面跳转的三种方式"><a href="#10、-React-router-页面跳转的三种方式" class="headerlink" title="10、 React-router 页面跳转的三种方式"></a>10、 React-router 页面跳转的三种方式</h3><p><a href="https://blog.csdn.net/Vue2018/article/details/100564775" target="_blank" rel="noopener">React-router 页面跳转的三种方式</a>:<a href="https://blog.csdn.net/Vue2018/article/details/100564775" target="_blank" rel="noopener">https://blog.csdn.net/Vue2018/article/details/100564775</a></p><h2 id="四、性能篇"><a href="#四、性能篇" class="headerlink" title="四、性能篇"></a>四、性能篇</h2><h3 id="1、react-组件的性能优化（渲染角度优化）"><a href="#1、react-组件的性能优化（渲染角度优化）" class="headerlink" title="1、react 组件的性能优化（渲染角度优化）"></a>1、react 组件的性能优化（渲染角度优化）</h3><h4 id="1、react-性能查看工具"><a href="#1、react-性能查看工具" class="headerlink" title="1、react 性能查看工具"></a>1、react 性能查看工具</h4><blockquote><p>再讲性能优化之前，我们需要先来了解一下如何查看 react 加载组件时所耗费的时间的工具，在 react 16 版本之前我们可以使用 React Perf 来查看。react16 版本之前，我们可以使用 react-addons-perf 工具来查看，而在最新的 16 版本，我们只需要在 url 后加上?react_pref。</p></blockquote><p>首先来了解一下<a href="https://reactjs.org/docs/perf.html" target="_blank" rel="noopener">react-addons-perf</a></p><p><code>react-addons-perf</code>这是 <code>React</code> 官方推出的一个性能工具包，可以打印出组件渲染的时间、次数、浪费时间等。</p><p>简单说几个 api，具体用法可参考<a href="https://reactjs.org/docs/perf.html" target="_blank" rel="noopener">官网</a>：</p><ul><li>Perf.start() 开始记录</li><li>Perf.stop() 结束记录</li><li>Perf.printInclusive() 查看所有设计到的组件 render</li><li>Perf.printWasted() 查看不需要的浪费组件 render</li></ul><p>大家可以在 chorme 中先安装 React Perf 扩展，然后在入口文件或者 redux 的 store.js 中加入相应的代码即可：<br><img src="2.jpg" alt></p><p>再来了解一下，在最新的 React16 版本中，在<code>url</code>后加上<code>?react_pref</code>，就可以在 chrome 浏览器的<code>performance</code>，我们可以查看<code>User Timeing</code>来查看组件的加载时间。点击 record 开始记录，注意记录时长不要超过 20s，否则可能导致 chrome 挂起。</p><p><img src="3.jpg" alt><br>大图<br><img src="4.jpg" alt></p><h4 id="2、单个-react-组件性能优化"><a href="#2、单个-react-组件性能优化" class="headerlink" title="2、单个 react 组件性能优化"></a>2、单个 react 组件性能优化</h4><ul><li>1、render 里面尽量减少新建变量和 bind 函数，传递参数是尽量减少传递参数的数量。</li></ul><blockquote><p>首先我们先思考一个问题，比如我要实现一个点击按钮使相应的 num 增加 1，我们有哪一些方法。<br>大家应该都能想到，无非就是三种，如下图：</p></blockquote><p><img src="5.jpg" alt></p><ul><li><p>第一种是在<code>构造函数</code>中绑定 this，</p></li><li><p>第二种是在 render()函数里面绑定 this，</p></li><li><p>第三种就是使用箭头函数，都能实现上述方法；<br>但是哪一种方法的性能最好，是我们要考虑的问题。应该大家都知道答案：<br><code>第一种的性能最好</code>。因为第一种，构造函数每一次渲染的时候<code>只会执行一遍</code>；<br>而第二种方法，在每次 render()的时候都会重新执行一遍函数；<br>第三种方法的话，每一次 render()的时候，都会生成一个新的箭头函数，即使两个箭头函数的内容是一样的。</p></li><li><p>2、定制 shouldComponentUpdate 函数</p></li></ul><blockquote><p>shouldComponentUpdate 是决定 react 组件什么时候能够不重新渲染的函数，但是这个函数默认的实现方式就是简单的返回一个 true。也就是说，默认每次更新的时候都要调用所用的生命周期函数，包括 render 函数，重新渲染。<br>我们来看一下下面的一个例子</p></blockquote><p><img src="6.jpg" alt></p><p>我们写两个组件，App 和 Demo 组件，并写两个方法，一个改变 App 中的 num 的值，一个是改变 title，我们在 Demo 的 render 中打印 render 函数。我们可以看到以下的效果：</p><p><img src="7.jpg" alt></p><p>我们可以清晰的看到虽然 demo 组件里的 title 值没有改变，但是还是 render 了。</p><p>为了解决这个问题，我们可以对 demo 组件进行如下的修改：</p><p><img src="8.jpg" alt></p><p>只有当 demo 的 title 值发生改变的时候，我们才去 render，我们可以看一下效果：</p><p><img src="9.jpg" alt></p><p>以上只是一个特别简单的一个对于 shouldComponentUpdate 的定制。在最新的 react 中，react 给我们提供了 React.PureComponent，官方也在早期提供了名为 react-addons-pure-render-mixin 插件来重新实现 shouldComponentUpdate 生命周期方法。<br><img src="10.jpg" alt></p><p>通过上述的方法的效果也是和我们定制 shouldComponentUpdate 的效果是一致的。但是我们要注意的是，这里的 PureRender 是浅比较的，因为深比较的场景是相当昂贵的。所以我们要注意我们在 1.1 中说到的一些注意点：不要直接为 props 设置对象或者数组、不要将方法直接绑定在元素上，因为其实函数也是对象</p><h3 id="2、redux-性能优化：reselect（数据获取时优化-待研究）"><a href="#2、redux-性能优化：reselect（数据获取时优化-待研究）" class="headerlink" title="2、redux 性能优化：reselect（数据获取时优化 待研究）"></a>2、redux 性能优化：reselect（数据获取时优化 待研究）</h3><p><a href="https://www.jianshu.com/p/1fcef4c892ba?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation" target="_blank" rel="noopener">react-redux 性能优化之 reselect</a></p><h3 id="3-1、分隔代码"><a href="#3-1、分隔代码" class="headerlink" title="3-1、分隔代码"></a>3-1、分隔代码</h3><h4 id="1、动态加载"><a href="#1、动态加载" class="headerlink" title="1、动态加载"></a>1、动态加载</h4><p>ES6 标准引入了 import 以方便我们静态加载模块。形式如：</p><pre><code>  import xxx from xxx.</code></pre><p>尽管 import 对于我们加载模块很有帮助，但是静态加载模块的方式一定程度上限制了我们来实现异步模块加载。不过，目前动态加载模块的 import()语法已处于提案阶段，并且 webpack 已将他引入并使用。import()提供了基于 Promise 的 API，因此，import()的返回值是一个完成状态或拒绝状态的 Promise 对象。形式如：</p><pre><code>  import(/* webpackChunkName: &#39;module&#39;*/ &quot;module&quot;)  .then(() =&gt; {        //todo  })  .catch(_ =&gt; console.log(&#39;It is an error&#39;))</code></pre><p>webpack 在编译时，识别到动态加载的 import 语法，则 webpack 会为当前动态加载的模块创建一个单独的 bundle。如果你使用的是官方的 Create-react-app 脚手架或 React 的服务端渲染框架 Next.js，那么可以直接使用动态 import 语法。如果你的脚手架是你自己配置的 webpack，那么你需要按照官方指南来设置，请移步[1]。</p><h4 id="2、动态加载-React-组件"><a href="#2、动态加载-React-组件" class="headerlink" title="2、动态加载 React 组件"></a>2、动态加载 React 组件</h4><p>当前最为流行的一种方法是使用 React-loadable [2]库提供的懒加载 React 组件。它利用 import()语法，使用 Promise 语法加载 React 组件。同时，React-loadable 支持 React 的服务端渲染。 通常，我们以如下方式实现组件：</p><pre><code>  import LazyComponet from &#39;LazyComponent&#39;;  export default function DemoComponent() {  return (        &lt;div&gt;              &lt;p&gt;demo component&lt;/p&gt;              &lt;AComponent /&gt;        &lt;/div&gt;  )  }</code></pre><p>在上面的例子中，假设 LazyComponet 在 DemoComponent 渲染时我们并不展示。但是因为我们使用 import 语法将 LazyComponet 导入，所以在编译时会将 LazyComponet 的代码与 DemoComponent 的代码打包到同一个 bundle 里面。 但是，这并不是我们想要的。所以我们可以通过使用 React-loadable 来懒加载 LazyComponet ，同时将 LazyComponet 的代码单独打包到一个 bundle 里面。我们可以看一下官网提供的例子：</p><pre><code>  import Loadable from &#39;react-loadable&#39;;  import Loading from &#39;./my-loading-component&#39;;  const LoadableComponent = Loadable({  loader: () =&gt; import(&#39;./my-component&#39;),  loading: Loading,  });  export default class App extends React.Component {  render() {  return &lt;LoadableComponent/&gt;;  }  }</code></pre><p>从例子中我们可以看到，react-loadable 使用动态 import()方法，并将导入的组件分配给 loader 属性。同时，react-loadable 提供了一个 loading 属性，以设置在加载组件时将展示的组件。</p><h4 id="3、高阶组件（HOC）"><a href="#3、高阶组件（HOC）" class="headerlink" title="3、高阶组件（HOC）"></a>3、高阶组件（HOC）</h4><p>高阶函数，可以传入函数作为参数的函数，如 map,sort,reduce。高阶组件包装了另一个组件的组件。</p><p>属性代理 （Props Proxy）<br>反向继承 （Inheritance Inversion）</p><h4 id="4、无状态组件"><a href="#4、无状态组件" class="headerlink" title="4、无状态组件"></a>4、无状态组件</h4><p>使用无状态组件，只从父组件接收 props，可以提高组件的渲染性能</p><pre><code>  const HelloWorld = (props) =&gt; &lt;div&gt;{props.name}&lt;/div&gt;ReactDOM.render(&lt;HelloWorld name=&quot;HelloWorld&quot; /&gt;,App)</code></pre><h4 id="5、componentWillReceiveProps-中取-props-的值"><a href="#5、componentWillReceiveProps-中取-props-的值" class="headerlink" title="5、componentWillReceiveProps 中取 props 的值"></a>5、componentWillReceiveProps 中取 props 的值</h4><p>注意应该取 nextProps,而不是 this.props</p><h4 id="6、bind-绑定函数"><a href="#6、bind-绑定函数" class="headerlink" title="6、bind 绑定函数"></a>6、bind 绑定函数</h4><p>利用 bind 绑定函数，是默认有 event 这个参数的，只是这个参数在给定参数之后</p><pre><code>  handleClockClick (id, e) {        console.log(id,e)        }  &lt;button onClick={this.handleClockClick.bind(this, 2)}&gt;Clock&lt;/button&gt;</code></pre><h4 id="7、ES6-类中，函数-this-不默认指向-对象"><a href="#7、ES6-类中，函数-this-不默认指向-对象" class="headerlink" title="7、ES6 类中，函数 this 不默认指向 对象"></a>7、ES6 类中，函数 this 不默认指向 对象</h4><ul><li><p>this.getDomNode 已经在低版本被移除了，现在设置 ref=xxx，然后使用 this.refs.xxx 访问 DOM 元素</p></li><li><p><code>ref</code> 可以赋值两种类型，一种是字符串，一种是函数, 字符串只能用在类组件，DOM 元素使用函数，纯函数组件不能使用 ref。旧版本 DOM 元素虽然可以使用 ref，但是 React 已不推荐。</p><pre><code>ref=&quot;test&quot; // this.refs.test 访问ref={test =&gt; this.test = test} // this.test 访问</code></pre></li></ul><h4 id="8、当只写属性名时，默认值为-true"><a href="#8、当只写属性名时，默认值为-true" class="headerlink" title="8、当只写属性名时，默认值为 true"></a>8、当只写属性名时，默认值为 true</h4><pre><code>  &lt;MyComponent isStock/&gt;// isStock 默认为 true</code></pre><h4 id="9、在-IE11-以下使用-React16"><a href="#9、在-IE11-以下使用-React16" class="headerlink" title="9、在 IE11 以下使用 React16"></a>9、在 IE11 以下使用 React16</h4><p>React16 依赖集合类型 Map 和 Set，在未提供原生支持的浏览器，需要使用一个 polyfill,例如 core-js 和 babel-polyfill<br>使用 core-js 支持</p><pre><code>  import &#39;core-js/es6/map&#39;;import &#39;core-js/es6/set&#39;;  import React from &#39;react&#39;;  import ReactDOM from &#39;react-dom&#39;;  ReactDOM.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;,document.getElementById(&#39;root&#39;));</code></pre><h3 id="3-2、分隔代码"><a href="#3-2、分隔代码" class="headerlink" title="3-2、分隔代码"></a>3-2、分隔代码</h3><h4 id="1、componentDidMount-请求服务器数据"><a href="#1、componentDidMount-请求服务器数据" class="headerlink" title="1、componentDidMount 请求服务器数据"></a>1、componentDidMount 请求服务器数据</h4><p>在 componentDidMount 请求服务器数据并利用 setState 时应注意，在组件卸载 componentWillUnmount 应该把去求去掉</p><h4 id="2、利用-es6-rest-参数（形式为…变量名）传递可变数量的-props"><a href="#2、利用-es6-rest-参数（形式为…变量名）传递可变数量的-props" class="headerlink" title="2、利用 es6 rest 参数（形式为…变量名）传递可变数量的 props"></a>2、利用 es6 rest 参数（形式为…变量名）传递可变数量的 props</h4><pre><code>  // 定义子组件  const Demo = ({ prop1, prop2, ...restProps }) =&gt; (  &lt;div&gt;{ restProps.text}&lt;/div&gt;  )  // 父组件使用Demo  &lt;Demo prop1={xxx} prop2={xxx} text={xxx}/&gt;</code></pre><h4 id="3、setState-的其他用法"><a href="#3、setState-的其他用法" class="headerlink" title="3、setState 的其他用法"></a>3、setState 的其他用法</h4><pre><code>  // 一般改变state值的一种方式  const { data } = this.state;  this.setState({ data: {...data, key: 1 } });  // 另外一种可以通过callback的方式改变state的值  this.setState(({ data }) =&gt; ({ data: {...data, key: 1 } }));  // 还可以  this.setState((state, props) =&gt; {  return { counter: state.counter + props.step };  });</code></pre><h4 id="4、React-性能优化"><a href="#4、React-性能优化" class="headerlink" title="4、React 性能优化"></a>4、React 性能优化</h4><p>// React 性能优化有很多种方式，<br>// 那常见的一种就是在生命周期函数 shouldComponentUpdate 里面判断<br>// 某些值或属性来控制组件是否重新再次渲染。<br>// 判断一般的字符串，数字或者基础的对象，数组都还是比较好处理<br>// 那嵌套的对象或者数组就比较麻烦了，对于这种<br>// 推荐使用 lodash(或者其他的类似库)的 isEqual 对嵌套数组或对象进行判断<br>shouldComponentUpdate(nextProps, nextState) {<br>if (_.isEqual(nextState.columns, this.state.columns)) return false;<br>return true;<br>}</p><h4 id="5、React-进阶提高-技巧篇（28-个视频）链接"><a href="#5、React-进阶提高-技巧篇（28-个视频）链接" class="headerlink" title="5、React 进阶提高 - 技巧篇（28 个视频）链接"></a>5、React 进阶提高 - 技巧篇（28 个视频）链接</h4><p>介绍 React 的一些进阶知识点，一些开发上的实践技巧，一些工具库等。</p><p><a href="www.qiuzhi99.com/">视频更新地址：</a><a href="http://www.qiuzhi99.com/" target="_blank" rel="noopener">www.qiuzhi99.com/</a></p><h2 id="五、学习资料"><a href="#五、学习资料" class="headerlink" title="五、学习资料"></a>五、学习资料</h2><p><a href="doc.react-china.org">翻译后的官方文档，学技术一定要多看几遍文档</a>: doc.react-china.org<br><a href="https://www.reactjscn.com/" target="_blank" rel="noopener">react官网</a>:<a href="https://www.reactjscn.com/" target="_blank" rel="noopener">https://www.reactjscn.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE中使用echarts配合canvas绘制图例下载</title>
      <link href="/2019/10/24/vue-zhong-shi-yong-echarts-pei-he-canvas-hui-zhi-tu-li/"/>
      <url>/2019/10/24/vue-zhong-shi-yong-echarts-pei-he-canvas-hui-zhi-tu-li/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="VUE中使用echarts配合canvas绘制图例"><a href="#VUE中使用echarts配合canvas绘制图例" class="headerlink" title="VUE中使用echarts配合canvas绘制图例"></a>VUE中使用echarts配合canvas绘制图例</h1><hr><h2 id="什么是canvas"><a href="#什么是canvas" class="headerlink" title="什么是canvas?"></a>什么是<a href="https://www.runoob.com/html/html5-canvas.html" target="_blank" rel="noopener">canvas</a>?</h2><p>HTML5 <code>&lt;canvas&gt;</code> 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.<br><code>&lt;canvas&gt;</code> 标签只是图形容器，您必须使用脚本来绘制图形。<br>你可以通过多种方法使用 canvas 绘制路径,盒、圆、字符以及添加图像。</p><h2 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h2><p>  <strong>html</strong></p><pre><code>&lt;img src=&quot;../../../static/img/xx.png&quot; id=&quot;zhinanzhen&quot; alt=&quot;指南针&quot; class=&quot;NS&quot; v-if=&quot;NSShow&quot; &gt;&lt;img src=&quot;../../../static/img/xx.png&quot; id=&quot;bilichi&quot; alt class=&quot;blc&quot; v-if=&quot;NSShow&quot; /&gt;</code></pre><p>  <strong>js</strong></p><pre><code>    //点击下载    downloadImg() {    let canvas = document.getElementsByTagName(&#39;canvas&#39;)[0]; // 获取地图元素    let tempcanvas = document.createElement(&#39;canvas&#39;);  // 创建地图元素    tempcanvas.width = 700;    tempcanvas.height = canvas.height;    // tempcanvas.style.backgroundColor = &#39;#fff&#39;    let ctx = tempcanvas.getContext(&#39;2d&#39;);     ctx.drawImage(canvas, (canvas.width - 700) / 2, 0, 700, canvas.height, 0, 0, 700, canvas.height);    //context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);    let img1 = document.getElementById(&quot;zhinanzhen&quot;);     img1.setAttribute(&#39;crossOrigin&#39;, &#39;anonymous&#39;); // 图片跨域    ctx.drawImage(img1, 550, 100, 82, 82)    //ctx.drawImage(img1, 左右, 上下, 长, 宽)    let img2 = document.getElementById(&quot;bilichi&quot;);    img2.setAttribute(&#39;crossOrigin&#39;, &#39;anonymous&#39;);    ctx.drawImage(img2, 50, canvas.height - 32, 165, 32)    let url = tempcanvas.toDataURL(&quot;image/png&quot;); // 生成图片 第二个参数0-1 默认0.94    // let url=tempcanvas.toDataURL(&quot;image/jpeg&quot;, 1.0);    var oA = document.createElement(&quot;a&quot;);    oA.download = &#39;&#39;;// 设置下载的文件名，默认是&#39;下载&#39;    oA.href = url;    document.body.appendChild(oA);    oA.click();    oA.remove(); // 下载之后把创建的元素删除     }     // 绘制底图     drawMap() {    let _this = this    this.$echarts.registerMap(&#39;maps&#39;, china);    mapcontainerPro ? mapcontainerPro.dispose() : &#39;&#39;    mapcontainerPro = this.$echarts.init(document.getElementById(&#39;mapcontainerPro&#39;));    mapcontainerPro.setOption({         title: [{        text: this.imgTitle,        left: &#39;center&#39;,        top: &#39;3%&#39;,        textStyle: {          color: &#39;black&#39;,          fontSize: 16        }      }, {        text: this.unit,        left: &#39;34%&#39;,        bottom: &#39;22%&#39;,        textStyle: {          fontSize: 16,          fontWeight: &#39;bold&#39;        }      }],      tooltip: {        show: true,        formatter: &#39;{b0}: {c0}&#39;      },      toolbox: {        show: false,        feature: {          dataView: {},          // saveAsImage: {          //   show: true,          //   excludeComponents: [&#39;toolbox&#39;],          //   pixelRatio: 2          // }        }      },      color: [&#39;#5B9CD6&#39;],      visualMap: {            // 图例        pieces: this.pieces,        inverse: false,       // 图例排序        orient: &#39;vertical&#39;, //图例方向        left: &#39;34%&#39;,        top: &#39;78%&#39;,        // min: 0,//最小        // max: this.range4,//最大        // splitNumber: 4,//共分5层        color: this.vColor,//颜色从高到低依次渐变        textStyle: {          fontSize: 16          // color: &#39;#00000&#39;,          //text:&#39;9jfhfhn&#39;        },      },      series: [        {          name: &#39;全国地图&#39;,          type: &#39;map&#39;,          aspectScale: 0.9, //地图长宽比          zoom: 1.1, //缩放比例          top: &#39;15%&#39;,          left: &#39;center&#39;,          label: {            normal: {              fontSize: 12            }          },          map: &#39;maps&#39;, // 自定义扩展图表类型          symbolSize: function (val) {            return val[2] / 10;          },          // label:{          //   show:true,          //   fontSize:12,          //   offset:[30,40]          // },          itemStyle: {            normal: {              label: {                show: true,                fontWeight: &quot;bolder&quot;,                fontSize: 12              },              areaColor: &#39;blue&#39;,              borderColor: &#39;black&#39;,              borderWidth: 0            },            emphasis: { label: { show: true } },          },          data: this.showData        }      ]    });  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js搭建本地服务模拟数据</title>
      <link href="/2019/10/18/node.js-da-jian-ben-di-fu-wu-mo-ni-shu-ju/"/>
      <url>/2019/10/18/node.js-da-jian-ben-di-fu-wu-mo-ni-shu-ju/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="Node-js搭建本地服务模拟数据"><a href="#Node-js搭建本地服务模拟数据" class="headerlink" title="Node.js搭建本地服务模拟数据"></a>Node.js搭建本地服务模拟数据</h1><hr><h2 id="1-首先下载安装好Nodejs"><a href="#1-首先下载安装好Nodejs" class="headerlink" title="1. 首先下载安装好Nodejs"></a>1. 首先下载安装好Nodejs</h2><p><code>下载</code> : <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Nodejs地址</a></p><h2 id="2-安装好了，打开cmd窗口，输入命令：npm-v-检验nodejs是否安装成功，如果出现以下界面则说明安装成功了"><a href="#2-安装好了，打开cmd窗口，输入命令：npm-v-检验nodejs是否安装成功，如果出现以下界面则说明安装成功了" class="headerlink" title="2. 安装好了，打开cmd窗口，输入命令：npm -v 检验nodejs是否安装成功，如果出现以下界面则说明安装成功了"></a>2. 安装好了，打开cmd窗口，输入命令：npm -v 检验nodejs是否安装成功，如果出现以下界面则说明安装成功了</h2><p><img src="3.jpg" alt></p><h2 id="3-输入命令-npm-install-http-server-g（在全局安装本地服务器）"><a href="#3-输入命令-npm-install-http-server-g（在全局安装本地服务器）" class="headerlink" title="3. 输入命令 npm install http-server -g（在全局安装本地服务器）"></a>3. 输入命令 npm install http-server -g（在全局安装本地服务器）</h2><p><img src="5.jpg" alt></p><h2 id="4-切换到你项目所在的路径"><a href="#4-切换到你项目所在的路径" class="headerlink" title="4. 切换到你项目所在的路径"></a>4. 切换到你项目所在的路径</h2><p><img src="66.jpg" alt></p><h2 id="5-命令行输入http-server-即可在此文件夹下打开服务器"><a href="#5-命令行输入http-server-即可在此文件夹下打开服务器" class="headerlink" title="5. 命令行输入http-server 即可在此文件夹下打开服务器"></a>5. 命令行输入http-server 即可在此文件夹下打开服务器</h2><p><img src="6.jpg" alt><br>域名和端口号是 127.0.0.1:8080、192.168.155.1:8080、192.168.1.122:8080</p><h2 id="6-在项目或者桌面下新建demo-gt-data-json文件"><a href="#6-在项目或者桌面下新建demo-gt-data-json文件" class="headerlink" title="6. 在项目或者桌面下新建demo =&gt;  data.json文件"></a>6. 在<code>项目</code>或者<code>桌面</code>下新建demo =&gt;  data.json文件</h2><p><img src="8.jpg" alt><br><img src="10.jpg" alt></p><h2 id="7-打开浏览器，输入域名端口号（上面三个域名端口号都可以用）和文件名称"><a href="#7-打开浏览器，输入域名端口号（上面三个域名端口号都可以用）和文件名称" class="headerlink" title="7. 打开浏览器，输入域名端口号（上面三个域名端口号都可以用）和文件名称"></a>7. 打开浏览器，输入域名端口号（上面三个域名端口号都可以用）和文件名称</h2><p><strong><a href="http://127.0.0.1:8080/data.json" target="_blank" rel="noopener">http://127.0.0.1:8080/data.json</a></strong><br><img src="12.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE项目常用方法总结</title>
      <link href="/2019/10/17/vue-xiang-mu-chang-yong-fang-fa-zong-jie/"/>
      <url>/2019/10/17/vue-xiang-mu-chang-yong-fang-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="VUE项目常用方法总结"><a href="#VUE项目常用方法总结" class="headerlink" title="VUE项目常用方法总结"></a>VUE项目常用方法总结</h1><hr><p><strong>1.什么是Webpack?</strong></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Vue 项目中使用 Echarts</title>
      <link href="/2019/10/17/echars-zai-vue-zhong-ru-he-shi-yong/"/>
      <url>/2019/10/17/echars-zai-vue-zhong-ru-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>废话不多说，那我们就看看如何在 Vue 的项目中使用 echarts……</p><h1 id="如何在-Vue-项目中使用-Echarts"><a href="#如何在-Vue-项目中使用-Echarts" class="headerlink" title="如何在 Vue 项目中使用 Echarts"></a>如何在 Vue 项目中使用 Echarts</h1><hr><h2 id="第一种方法-直接引入-Echarts"><a href="#第一种方法-直接引入-Echarts" class="headerlink" title="第一种方法 直接引入 Echarts"></a>第一种方法 直接引入 Echarts</h2><h3 id="安装-echarts-项目依赖"><a href="#安装-echarts-项目依赖" class="headerlink" title="安装 echarts 项目依赖"></a>安装 echarts 项目依赖</h3><pre><code>    npm install echarts --save    //或者    npm install echarts -S</code></pre><p>如果没有科学上网的朋友可以使用国内的淘宝镜像。</p><pre><code>    npm install -g cnpm --registry=https://registry.npm.taobao.org    cnpm install echarts -S</code></pre><ul><li><p>首先我们需要在自己的项目 main.js 中全局引入 Echarts</p><pre><code>  import echarts from &#39;echarts&#39;;  Vue.prototype.$echarts=echarts;</code></pre></li></ul><h3 id="创建图表"><a href="#创建图表" class="headerlink" title="创建图表"></a>创建图表</h3><pre><code>    &lt;template&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;/template&gt;    export default {      name: &quot;app&quot;,      methods: {        drawChart() {          // 基于准备好的dom，初始化echarts实例          let myChart = this.$echarts.init(document.getElementById(&quot;main&quot;));          // 指定图表的配置项和数据          let option = {            title: {              text: &quot;ECharts 入门示例&quot;            },            tooltip: {},            legend: {              data: [&quot;销量&quot;]            },            xAxis: {              data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]            },            yAxis: {},            series: [              {                name: &quot;销量&quot;,                type: &quot;bar&quot;,                data: [5, 20, 36, 10, 10, 20]              }            ]          };          // 使用刚指定的配置项和数据显示图表。          myChart.setOption(option);        }      },      mounted() {        this.drawChart();      }    };    &lt;/script&gt;</code></pre><h3 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h3><p>  <img src="4.jpg" alt></p><h2 id="第二种方法-使用-Vue-ECharts-组件"><a href="#第二种方法-使用-Vue-ECharts-组件" class="headerlink" title="第二种方法 使用 Vue-ECharts 组件"></a>第二种方法 使用 Vue-ECharts 组件</h2><h3 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h3><pre><code>  npm install vue-echarts -S</code></pre><h3 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h3><pre><code>  &lt;template&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;v-chart class=&quot;my-chart&quot; :options=&quot;bar&quot;/&gt;    &lt;/div&gt;  &lt;/template&gt;  &lt;script&gt;  // 在对应组件内引用或者main.js全局引用  import ECharts from &quot;vue-echarts/components/ECharts&quot;;  import &quot;echarts/lib/chart/bar&quot;;`  export default {    name: &quot;App&quot;,    components: {      &quot;v-chart&quot;: ECharts    },    data: function() {      return {        bar: {          title: {            text: &quot;ECharts 入门示例&quot;          },          tooltip: {},          legend: {            data: [&quot;销量&quot;]          },          xAxis: {            data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]          },          yAxis: {},          series: [            {              name: &quot;销量&quot;,              type: &quot;bar&quot;,              data: [5, 20, 36, 10, 10, 20]            }          ]        }      };    }  };  &lt;/script&gt;  &lt;style&gt;  .my-chart {    width: 800px;    height: 500px;  }  &lt;/style&gt;</code></pre><h3 id="入门实例-1"><a href="#入门实例-1" class="headerlink" title="入门实例"></a>入门实例</h3><p><img src="1679c3f7aa381aa7" alt></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="问题1：父子组件传值，容易造成点开子组件后，echarts-图不出现"><a href="#问题1：父子组件传值，容易造成点开子组件后，echarts-图不出现" class="headerlink" title="问题1：父子组件传值，容易造成点开子组件后，echarts 图不出现"></a>问题1：父子组件传值，容易造成点开子组件后，echarts 图不出现</h3><pre><code>原因：因此在另一个父组件进行应用的时候，他是首屏就加载，数据不变动。但是当数据变动之后，无法自动的更新图表。由于 mounted 只会在挂载的时候执行一次，因此无法后续进行更新。**解决办法：给父组件加上一个 v-if，使子组件重新渲染**  &lt;template&gt;   &lt;div&gt;   &lt;envy-pie :voltage=&quot;voltage&quot; v-if=&quot;flag&quot;&gt;   &lt;/div&gt;  &lt;/template&gt;    //js部分    data () {          return {            voltage: [],            flag: false          }        },        components: {          envyPie        },        methods: {          getEnvyContent () {            axios.get(&#39;../../../static/mock/envy.json&#39;).then(this.getEnvyContentSucc)          },          getEnvyContentSucc (res) {            if (res) {              const data = res.data              this.voltage = res.data.capacity_by_voltage              this.flag = true            }          }        },        mounted() {          this.getEnvyContent()        }</code></pre><h3 id="问题2-自动缩放"><a href="#问题2-自动缩放" class="headerlink" title="问题2:自动缩放"></a>问题2:自动缩放</h3><p>  Echarts 本身是不支持自动缩放的，但是 Echarts 为我们提供了 resize 方法。</p><pre><code>    //在**调用方法**中加入下面这行代码    window.addEventListener(&quot;resize&quot;, this.chart.resize);</code></pre><h3 id="问题3-支持数据自动刷新"><a href="#问题3-支持数据自动刷新" class="headerlink" title="问题3:支持数据自动刷新"></a>问题3:支持数据自动刷新</h3><p><a href="https://juejin.im/post/5ab220b8f265da237c68ca11" target="_blank" rel="noopener">原文链接</a></p><pre><code>因为 Echarts 是数据驱动的，这意味着只要我们重新设置数据，那么图表就会随之重新渲染，这是实现本需求的基础。我们再设想一下，如果想要支持数据的自动刷新，必然需要一个监听器能够实时监听到数据的变化然后告知 Echarts 重新设置数据。所幸 Vue 为我们提供了==watcher==功能，通过它我们可以很方便的实现上述功能  //在Chart.vue中加入watch  watch: {        //观察option的变化     option: {             handler(newVal, oldVal) {                 if (this.chart) {                    if (newVal) {            t          his.chart.setOption(newVal);                    } else {                      this.chart.setOption(oldVal);   }                } else {                      this.init();             } },                deep: true //对象内部属性的监听，关键。            }         }</code></pre><h3 id="问题4-图表太丑怎么破，ECharts神器带你飞！"><a href="#问题4-图表太丑怎么破，ECharts神器带你飞！" class="headerlink" title="问题4:图表太丑怎么破，ECharts神器带你飞！"></a>问题4:图表太丑怎么破，ECharts神器带你飞！</h3><p><a href="https://juejin.im/post/59dcb823f265da432d270f26" target="_blank" rel="noopener">原文链接</a></p><h3 id="问题5-Echarts-x轴文本内容太长的几种解决方案"><a href="#问题5-Echarts-x轴文本内容太长的几种解决方案" class="headerlink" title="问题5:Echarts x轴文本内容太长的几种解决方案"></a>问题5:Echarts x轴文本内容太长的几种解决方案</h3><p><a href="https://juejin.im/post/5d255d69f265da1b80206db1" target="_blank" rel="noopener">原文链接</a></p><h3 id="Echars-遇到问题汇总…"><a href="#Echars-遇到问题汇总…" class="headerlink" title="Echars 遇到问题汇总…."></a>Echars 遇到问题汇总….</h3><p><a href="https://www.cnblogs.com/padding1015/p/9936533.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS+VUE项目搭建</title>
      <link href="/2019/10/16/ts-vue-xiang-mu-da-jian/"/>
      <url>/2019/10/16/ts-vue-xiang-mu-da-jian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=574919767&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="TS-VUE项目搭建"><a href="#TS-VUE项目搭建" class="headerlink" title="TS+VUE项目搭建"></a>TS+VUE项目搭建</h1><hr><p>自尤大推出vue对typescript的支持后，一直想开箱尝试，对于前端sr来说，vue的顺滑加上ts的面向对象，想着就非常美好~ 终于在两个月前，找到了个机会尝试了一把vue+ts的组合。 开文记录下vue和ts整合之旅和遇到的一些坑。</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>应该大部分人都知道vue，毕竟如今vue是与react肩并肩的存在，所以就不过多介绍啦。</p><p><a href="https://cn.vuejs.org/index.html" target="_blank" rel="noopener">vue中文官网</a> 官网上的教程就是最好的入门教程</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>我在前几篇文章就一直有在宣传typescript，简单列举下ts的优点</p><ol><li><p>始于JavaScript，归于JavaScript,typescript是JavaScript的超集，所以它可以重用JavaScriptd代码,使用JavaScript的库</p></li><li><p>JavaScript用的优点它都有，跨浏览器、跨操作系统等</p></li><li><p>面向对象的编程思想,强大的类型检查</p></li></ol><p>开源大法好</p><p>要说缺点的话，那就是不太适合太小的项目。<br>就凭这些优点，足够我们愉快的玩耍~</p><h2 id="TS安装"><a href="#TS安装" class="headerlink" title="TS安装"></a>TS安装</h2><p> 先将node安装，然后在通过npm安装ts的包</p><pre><code>  npm install -g typescript  tsc -v //查看ts的版本号</code></pre><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h3 id="执行安装命令"><a href="#执行安装命令" class="headerlink" title="执行安装命令"></a>执行安装命令</h3><pre><code>npm install -g @vue/cli</code></pre><p> 安装完成后，可以通过 vue create 快速创建一个新项目的脚手架，或者直接通过 vue serve 构建新想法的原型。</p><h3 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a>创建项目</h3><pre><code>vue create vue-ts  //vue-ts 是我们的项目名称，执行后如下![](1.jpg)</code></pre><p>可看到有这么几个选项，xiaoli这个选项是我之前创建的，稍后会介绍；default这个后面写着 babel eslint ，表示若选择这个，那么只会引入babel和 ealint；manually select features顾名思义，选择我们想要的。那么我们选择第三个</p><p><img src="2.jpg" alt></p><p>可看到列表里有很多选项，这里是多项选择，按<code>上/下键</code>切换选项，<code>空格键</code>选择该选项，<code>enter</code>键进入下一步。你可以根据项目的实际情况，选择相应的选项。我们以vue+ts为主，所以我们选择 babel typescript router vuex 这几个，选择完后，如下</p><p><img src="3.jpg" alt></p><p>接下来会有好几个yes or no 的选项，大家根据自己项目的需要来选择就可以，最后一步，<code>Save this as a preset for future projects?</code> 若选择yes，就会将我们之前的选择存储起来，作为一个预设选项，方便后续一键创建新项目。所有步骤选完，回车，便开始创建项目文件结构和拉取npm包</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p> <strong>项目结构如下</strong></p><p><img src="4.jpg" alt></p><p><strong>public:</strong> 用于存放静态文件，<code>index.html</code>入口文件就放在里面，这个文件夹下的文件不会纳入webpack的打包中；<br><strong>src：</strong>存放vue项目工程文件，其中已经帮我们关联好router和vuex，文件结构非常简洁<br>其他：webpack、babel等配置文件</p><h2 id="与TypeScript复用"><a href="#与TypeScript复用" class="headerlink" title="与TypeScript复用"></a>与TypeScript复用</h2><p>项目在构建中，已经引入 <code>vue-class-component</code> ，用于对ts的支持，或者使用 <code>vue-property-decorator</code>,这个库是在之前那个的基础上扩展。</p><p>以下列举tsvue写法的各种变化</p><h3 id="组件声明"><a href="#组件声明" class="headerlink" title="组件声明"></a>组件声明</h3><pre><code> import { Component, Prop, Vue, Watch } from &#39;vue-property-decorator&#39;;  @Component  export default class Test extends Vue {  }</code></pre><h3 id="data对象"><a href="#data对象" class="headerlink" title="data对象"></a>data对象</h3><p>通过构造函数创建data里的数据</p><pre><code>  import { Component, Prop, Vue, Watch } from &#39;vue-property-decorator&#39;;  @Component  export default class Test extends Vue {      private name: string;      constructor() {          super();          this.name = &#39;xiaoli&#39;;      }  }</code></pre><p><strong>data里的数据使用方式如下</strong><br>      public getName(){<br>          return this.name<br>      }    </p><h3 id="Prop声明"><a href="#Prop声明" class="headerlink" title="Prop声明"></a>Prop声明</h3><pre><code>  @Prop() public msg: string;  @Prop({ default: &#39;default value&#39; }) propB: string  @Prop([String, Boolean]) propC: string | boolean</code></pre><h3 id="生命周期函数使用"><a href="#生命周期函数使用" class="headerlink" title="生命周期函数使用"></a>生命周期函数使用</h3><pre><code>  public created(): void {      console.log(&#39;created&#39;);  }  public mounted():void{      console.log(&#39;mounted&#39;)  }</code></pre><h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>js下是需要在method对象中声明方法，现变成如下</p><pre><code>  public clickFunc(): void {      console.log(this.name)      console.log(this.msg)  }</code></pre><h3 id="Watch监听属性"><a href="#Watch监听属性" class="headerlink" title="Watch监听属性"></a>Watch监听属性</h3><pre><code>  @Watch(&#39;name&#39;,{ immediate: true, deep: true })  public onChildChanged(val: string, oldVal: string) {      console.log(&#39;watch new name=&#39; + val);  }</code></pre><h3 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h3><pre><code>  public get allname() {      return &#39;computed &#39; + this.name;  } </code></pre><p>allname是计算后的值，name是被监听的值</p><h3 id="emit事件"><a href="#emit事件" class="headerlink" title="emit事件"></a>emit事件</h3><pre><code>  @Emit()    addToCount(n: number) {      this.count += n    }    @Emit(&#39;reset&#39;)    resetCount() {      this.count = 0    }</code></pre><p>第一个的事件名称为 add-to-count,n为传过去的参数；第二个事件名为reset-count,参数为空</p><h3 id="指令和过滤器"><a href="#指令和过滤器" class="headerlink" title="指令和过滤器"></a>指令和过滤器</h3><blockquote><p>我尝试了下，发现之前在入口文件直接引入指令或者过滤器的方式不管用了，因为用了ts后，组件的作用域跟之前的不一样了，然后我找了官方的issue，截图如下.</p></blockquote><p><img src="5.jpg" alt></p><p><strong>一个自定义指令</strong></p><pre><code>  // ./directive/index.ts  export const focus = {      // 当被绑定的元素插入到 DOM 中时……      inserted: function (el:HTMLElement) {          // 聚焦元素          el.focus()        }  }</code></pre><p><strong>一个过滤器</strong></p><pre><code>  // ./filter/index.ts  export const capitalize = function (value:string) {      if (!value) return &#39;&#39;      value = value.toString()      return value.charAt(0).toUpperCase() + value.slice(1)  }</code></pre><p><strong>组件中使用</strong></p><pre><code>  import { capitalize }from &#39;@/filter/index&#39;  import { focus } from &#39;@/directive/index&#39;  @Component({      filters:{capitalize},      directives:{focus}  })  export default class Test extends Vue {}  复制代码&lt;div&gt;      &lt;input v-focus v-model=&quot;modelData&quot;&gt;      &lt;div&gt;{{modelData | capitalize}}&lt;/div&gt;  &lt;/div&gt;</code></pre><h2 id="Vuex与TS的糅合"><a href="#Vuex与TS的糅合" class="headerlink" title="Vuex与TS的糅合"></a>Vuex与TS的糅合</h2><p>因为vuex是个可选的，所以单独列出来。首先需要引用 <code>vuex-class</code> 库，该库有如下几个模块</p><pre><code>  import {      namespace,      Action,      Getter,      Mutation,      State  } from &#39;vuex-class&#39;;</code></pre><p>分别对应vuex中的 action、getter、mutation等，使用ts对vuex的影响主要在组件对vuex的调用上，vuex的定义还是按照之前的写法即可 </p><pre><code>  @State(&#39;foo&#39;) stateFoo  @State(state =&gt; state.bar) stateBar  @Getter(&#39;foo&#39;) getterFoo  @Action(&#39;foo&#39;) actionFoo  @Mutation(&#39;foo&#39;) mutationFoo  @someModule.Getter(&#39;foo&#39;) moduleGetterFoo  // If the argument is omitted, use the property name  // for each state/getter/action/mutation type  @State foo  @Getter bar  @Action baz  @Mutation qu</code></pre><p>若不想使用vuex定义的方法名，可以自定义属性名，因为都是定义在当前this上，所以直接使用this调用即可</p><pre><code>  this.getterFoo // -&gt; store.getters.foo  this.actionFoo({ value: true }) // -&gt; store.dispatch(&#39;foo&#39;, { value: true })</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> ……</p>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS基础总结</title>
      <link href="/2019/10/15/ts-xue-xi-zong-jie/"/>
      <url>/2019/10/15/ts-xue-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<div align="middle"><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe> --><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28854182&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="ts-基础总结"><a href="#ts-基础总结" class="headerlink" title="ts 基础总结"></a>ts 基础总结</h1><hr><p><strong>ts 有什么用</strong></p><p>类型检查, 拥抱 es6，支持部分的 esNext 草案，直接编译到原生 js、引入新的语法糖</p><p><strong>为什么用 ts</strong></p><blockquote><p>TypeScript 的设计目的应该是解决 JavaScript 的“痛点”：弱类型和没有命名空间，导致很难模块化，不适合开发大型程序。另外它还提供了一些语法糖来帮助大家更方便地实践面向对象的编程。<br>typescript 不仅可以约束我们的编码习惯，还能起到注释的作用，当我们看到一函数后我们立马就能知道这个函数的用法，需要传什么值，返回值是什么类型一目了然，对大型项目的维护性有很大的提升。</p></blockquote><p><strong>编译报错， 会生成编译结果么？</strong></p><p>答案是肯定的,当然可以在 tsconfig.json 的配置， noEmitONError</p><h1 id="基础总结"><a href="#基础总结" class="headerlink" title="基础总结"></a>基础总结</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>boolean 、number、string、null、 undefined、 Symbol</li><li>undefined 和 null 类型的数据只能被赋值 undefined 和 null， 但是这个类型是所有类型的子类型</li><li>void 空类型<br>// undefined 和 null 是所有类型子类型，都可以赋值<br>let num: Symbol = undefined;ss<br>let num: number = undefined;<br>// undefined 类型， 只能给 undefined<br>let u: undefined = undefined;<br>let n: null = null;</li><li>any 和类型推断<br>// 在 ts 中，变量在声明的时候，如果没有定义其类型，会被识成默认类型<br>let str;<br>str = ‘I am strgting’;<br>str = 1024;<br>// 未定义类型，直接赋值<br>let num= 124;<br>// 等同于 let num:number = 124, 在后面代码如果赋予 num 一个 string 会被报错</li></ul><h2 id="多个可能属性"><a href="#多个可能属性" class="headerlink" title="多个可能属性"></a>多个可能属性</h2><pre><code>  //只能访问可能属性的共有属性  function getLength(param: string| number) {      return param.length;  }  // 会报错， 因为 length不是 sting和number类型的共有属性  // 技巧--》 使用类型别名  type possibleType = string | number;  function getLength(param: possibleType) {      return param.length;  }</code></pre><h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><ul><li>在 ts 中，interface 包括对行为的抽象，由类去实现（implements）</li><li>也包括对对象轮廓的描述</li></ul><h2 id="对象-interface-》动态属性"><a href="#对象-interface-》动态属性" class="headerlink" title="对象 interface -》动态属性"></a>对象 interface -》动态属性</h2><p>必选参数和可选参数的类型是动态属性类型的子集，所有在动态属性类型设置的时候要设置上所有类型</p><p>只读属性的约束力<br>注意点： 只读属性的约束力在于第一次给对象赋值的时候，而不是给属性赋值的时候 readonly 和 const 的区别： const 是变量， readonly 是属性</p><h2 id="接口-》抽象方法的实现"><a href="#接口-》抽象方法的实现" class="headerlink" title="接口-》抽象方法的实现"></a>接口-》抽象方法的实现</h2><pre><code>  export interface ISRequest {    fetch(url: string, arg?: Object, callback?: Function): Promise&lt;Object&gt;;  }  export class SafeRequest implements ISRequest {        public async fetch(url: string, arg, callback?: Function): Promise&lt;Object&gt; {          return new Promise((resolve, reject) =&gt; {          })  }</code></pre><h2 id="用接口表示数组"><a href="#用接口表示数组" class="headerlink" title="用接口表示数组"></a>用接口表示数组</h2><pre><code>  interface NumberArray {        [index: any]: number    }    let numArr: NumberArray = [1, 2, 3]</code></pre><h2 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h2><ul><li><p>可选参数, 必须在必选参数后面</p></li><li><p>参数默认值<br>function buildName(firstName: string, lastName?: string) {</p><p> }</p></li><li><p>添加默认值的参数识别为可选参数</p></li><li><p>剩余参数</p></li></ul><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><h2 id="疑惑–》-声明文件"><a href="#疑惑–》-声明文件" class="headerlink" title="疑惑–》 声明文件"></a>疑惑–》 声明文件</h2><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。<br>声明文件在哪里？</p><ul><li>与 npm 包绑定在一起</li><li>npm 包的维护者并没有提供声明文件， 只能由其他人将声明文件发布到@types 里面</li><li>自己写个声明文件</li></ul><p>npm 包的声明文件 和全局变量的声明文件<br>在 npm 包的声明文件中，使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 export 导出，然后在使用方 import 导入后，才会应用到这些类型声明。</p><p>######declare global<br>使用 declare global 可以在 npm 包或者 UMD 库中扩展全局变量的类型</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">内置对象查询–》点击</a><br>ESMAScript 提供了 Boolean、Error、Date、RegExp</p><pre><code>   interface obj = {        param: Function        param: Promise    }</code></pre><p>枚举–》 数据的双向映射</p><pre><code>    enum companyList= {1: &#39;aaa&#39;, 2: &#39;bbb&#39;}    var companyList = {        1: &#39;aaa&#39;,        2: &#39;bbb&#39;,        aaa: 1,        bbb: 2    }</code></pre><h2 id="Vue-in-Typescript"><a href="#Vue-in-Typescript" class="headerlink" title="Vue in Typescript"></a>Vue in Typescript</h2><h3 id="三大利器"><a href="#三大利器" class="headerlink" title="三大利器"></a>三大利器</h3><ul><li>vue-component-class</li><li>方法可以直接声明为类成员方法。</li><li>可以将计算属性声明为类属性访问器。</li><li>默认 data 被当作类属性</li><li>data ， render 和 vue 的生命周期的钩子直接是类成员的方法，保留这些命名，不要冲突</li><li>对于其他的配置项，例如 prop、componets 等传递给装饰器函数</li></ul><pre><code>import Vue from &#39;vue&#39;;import Component from &#39;vue-componet-class&#39;;Component.resgisterHooks([    &#39;beforeRouteEnter&#39;])@Componnet({    props: {    },    components: {    }})export default class App extends Vue {    // aa = &#39;&#39;;    // 类型推断aa是个string， 后面aa只能赋值aa类型    // 所以最好使用先声明后    //  data   public tableModelItems: Array&lt;any&gt;;   constructor() {       super();       this.tableModelItems = [];   }   // computed  public get filterTableData() {    return this.tableData.filter((i: any) =&gt; i.refundStatus === 0).length    // 方法    // 声明周期    // 此时需要路由函数的生命周期钩子咋办    beforeRouteEnterf() {        next() // 一定要写，否则玩不下去，为什么？    }}}- vue-property-decorator(依赖vue-component-class提供了更多了装饰器，代码更加显示 )- @Emit- @Inject- @Prop- @Provide- @Watch- vuex-class（连接了vue和vuex）## 还没搞定的bug</code></pre><h3 id="错误–》-类型报错"><a href="#错误–》-类型报错" class="headerlink" title="错误–》 类型报错"></a>错误–》 类型报错</h3><ul><li>添加script的类型<pre><code>&lt;script lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;!--否则下面的类型报错--&gt;</code></pre></li></ul><h3 id="错误之–》Vue中挂载propoty出错（如果还是爆红，重启ide）"><a href="#错误之–》Vue中挂载propoty出错（如果还是爆红，重启ide）" class="headerlink" title="错误之–》Vue中挂载propoty出错（如果还是爆红，重启ide）"></a>错误之–》Vue中挂载propoty出错（如果还是爆红，重启ide）</h3><p>声明再挂载</p><pre><code>    &lt;!--inject--&gt;      import _Vue from &#39;vue&#39;      import moment from &quot;moment&quot;;      export default {        install(Vue: typeof _Vue, options: any) {          Vue.prototype.$moment = moment;          Vue.prototype.$log = () =&gt; {            console.log(new Date())          }        }      }    &lt;!--types--&gt;      import Vue from &#39;vue&#39;      declare module &#39;vue/types/vue&#39; {        interface Vue {          $moment: Function          $log: Function        }      }</code></pre><h3 id="ts中不能识别-vue文件"><a href="#ts中不能识别-vue文件" class="headerlink" title="ts中不能识别.vue文件"></a>ts中不能识别.vue文件</h3><p> <strong>TypeScript 默认只识别 .ts 文件，不识别 .vue 文件, 乖乖的写 import Component from ‘components/component.vue’</strong><br><img src="1.jpg" alt></p><h3 id="vuex-class的Emit传参数给父组件报错"><a href="#vuex-class的Emit传参数给父组件报错" class="headerlink" title="vuex-class的Emit传参数给父组件报错"></a>vuex-class的Emit传参数给父组件报错</h3><pre><code>@emit(&quot;reset&quot;)reset(role, this.formData){}&lt;!--此时报错--&gt;</code></pre><p><img src="2.jpg" alt></p><h3 id="错误–-gt-可选参数爆红"><a href="#错误–-gt-可选参数爆红" class="headerlink" title="错误–&gt; 可选参数爆红"></a>错误–&gt; 可选参数爆红</h3><p><img src="3.jpg" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener">ts的官网</a></li><li><a href="https://juejin.im/post/5ba75b355188255c5e66e4d3" target="_blank" rel="noopener">vue+ts快速上手</a></li><li><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">ts通俗易懂，比较清晰的文档</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247490464&idx=1&sn=0c75aaab12002c76198a8d6f183cd686&chksm=f951aee3ce2627f50a5ac6799964919e54a7298288f8bf881931d7c6769b05e302418bdb8051&scene=27#wechat_redirect" target="_blank" rel="noopener">尤大大对于ts+vue的看法</a></li><li><a href="https://juejin.im/post/5a9c004a6fb9a028b92c9e91#heading-7" target="_blank" rel="noopener">蚂蚁金服的ts实践</a><br>……</li></ul>]]></content>
      
      
      <categories>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>也谈面试必备问题之 JavaScript 数组去重</title>
      <link href="/2019/09/22/javascript-shu-zu-qu-chong/"/>
      <url>/2019/09/22/javascript-shu-zu-qu-chong/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28854182&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>数组去重</p><p><strong>方法一</strong><br>无需思考，我们可以得到 O(n^2) 复杂度的解法。定义一个变量数组 res 保存结果，遍历需要去重的数组，如果该元素已经存在在 res 中了，则说明是重复的元素，如果没有，则放入 res 中。</p><pre><code>  function unique(a) {  var res = [];  for (var i = 0, len = a.length; i &lt; len; i++) {  var item = a[i];      for (var j = 0, jLen = res.length; j &lt; jLen; j++) {        if (res[j] === item)          break;      }      if (j === jLen)        res.push(item);  }  return res;  }  var a = [1, 1, &#39;1&#39;, &#39;2&#39;, 1];  var ans = unique(a);  console.log(ans); // =&gt; [1, &quot;1&quot;, &quot;2&quot;]</code></pre><p>代码非常简单，那么是否能更简洁些？如果不考虑浏览器兼容，我们可以用 ES5 提供的 Array.prototype.indexOf 方法来简化代码。</p><pre><code>  function unique(a) {  var res = [];  for (var i = 0, len = a.length; i &lt; len; i++) {  var item = a[i];      (res.indexOf(item) === -1) &amp;&amp; res.push(item);  }  return res;  }  var a = [1, 1, &#39;1&#39;, &#39;2&#39;, 1];  var ans = unique(a);  console.log(ans); // =&gt; [1, &quot;1&quot;, &quot;2&quot;]  既然用了 indexOf，那么不妨再加上 filter。  function unique(a) {  var res = a.filter(function(item, index, array) {  return array.indexOf(item) === index;  });  return res;  }  var a = [1, 1, &#39;1&#39;, &#39;2&#39;, 1];  var ans = unique(a);  console.log(ans); // =&gt; [1, &quot;1&quot;, &quot;2&quot;]</code></pre><p><strong>方法二</strong><br>法一是将原数组中的元素和结果数组中的元素一一比较，我们可以换个思路，将原数组中重复元素的最后一个元素放入结果数组中。</p><pre><code>  function unique(a) {  var res = [];  for (var i = 0, len = a.length; i &lt; len; i++) {  for (var j = i + 1; j &lt; len; j++) {  // 这一步十分巧妙  // 如果发现相同元素  // 则 i 自增进入下一个循环比较  if (a[i] === a[j])  j = ++i;  }      res.push(a[i]);  }  return res;  }  var a = [1, 1, &#39;1&#39;, &#39;2&#39;, 1];  var ans = unique(a);  console.log(ans); // =&gt; [&quot;1&quot;, &quot;2&quot;, 1]</code></pre><p>虽然复杂度还是 O(n^2)，但是可以看到结果不同，1 出现在了数组最后面，因为结果数组取的是元素最后一次出现的位置。</p><p><strong>方法三（sort)</strong><br>如果笔试面试时只答出了上面这样 O(n^2) 的方案，可能还不能使面试官满意，下面就来说几种进阶方案。</p><p>将数组用 sort 排序后，理论上相同的元素会被放在相邻的位置，那么比较前后位置的元素就可以了。</p><pre><code>  function unique(a) {  return a.concat().sort().filter(function(item, pos, ary) {  return !pos || item != ary[pos - 1];  });  }  var a = [1, 1, 3, 2, 1, 2, 4];  var ans = unique(a);  console.log(ans); // =&gt; [1, 2, 3, 4]</code></pre><p>但是问题又来了，1 和 “1” 会被排在一起，不同的 Object 会被排在一起，因为它们 toString() 的结果相同，所以会出现这样的错误：</p><pre><code>  var a = [1, 1, 3, 2, 1, 2, 4, &#39;1&#39;];  var ans = unique(a);  console.log(ans); // =&gt; [1, 2, 3, 4]</code></pre><p>当然你完全可以针对数组中可能出现的不同类型，来写这个比较函数。不过这似乎有点麻烦。</p><p><strong>方法四 （object）</strong><br>用 JavaScript 中的 Object 对象来当做哈希表，这也是几年前笔试时的解法，跟 sort 一样，可以去重完全由 Number 基本类型组成的数组。</p><pre><code>  function unique(a) {  var seen = {};  return a.filter(function(item) {  return seen.hasOwnProperty(item) ? false : (seen[item] = true);  });  }  var a = [1, 1, 3, 2, 1, 2, 4];  var ans = unique(a);  console.log(ans); // =&gt; [1, 3, 2, 4]</code></pre><p>还是和方法三一样的问题，因为 Object 的 key 值都是 String 类型，所以对于 1 和 “1” 无法分别，我们可以稍微改进下，将类型也存入 key 中。</p><pre><code>  function unique(a) {  var ret = [];  var hash = {};  for (var i = 0, len = a.length; i &lt; len; i++) {  var item = a[i];      var key = typeof(item) + item;      if (hash[key] !== 1) {        ret.push(item);        hash[key] = 1;      }  }  return ret;  }  var a = [1, 1, 3, 2, &#39;4&#39;, 1, 2, 4, &#39;1&#39;];  var ans = unique(a);  console.log(ans); // =&gt; [1, 3, 2, &quot;4&quot;, 4, &quot;1&quot;]</code></pre><p>虽然解决了讨厌的 1 和 “1” 的问题，但是还有别的问题！</p><pre><code>  var a = [{name: &quot;hanzichi&quot;}, {age: 30}, new String(1), new Number(1)];  var ans = unique(a);  console.log(ans); // =&gt; [Object, String]</code></pre><p>但是如果数组元素全部是基础类型的 Number 值，键值对法应该是最高效的！</p><p><strong>方法五 （ES6）</strong><br>ES6 部署了 Set 以及 Array.from 方法，太强大了！如果浏览器支持，完全可以这样：</p><pre><code>  function unique(a) {  return Array.from(new Set(a));  }  var a = [{name: &quot;hanzichi&quot;}, {age: 30}, new String(1), new Number(1)];  var ans = unique(a);  console.log(ans); // =&gt; [Object, Object, String, Number]  _.unique</code></pre><p>最后来看看 underscore 对此的实现方式，underscore 将此封装到了 <em>.unique 方法中，调用方式为 \</em>.unique(array, [isSorted], [iteratee])。其中第一个参数是必须的，是需要去重的数组，第二个参数可选，如果数组有序，则可以传入布尔值 true，第三个参数可选，如果需要对数组迭代的结果去重，则可以传入一个迭代函数。而数组元素去重是基于 === 运算符的。</p><p>其实很简单，underscore 中的实现方式和上面的方法一相似。</p><p>我们来看它的核心代码：</p><pre><code>  for (var i = 0, length = getLength(array); i &lt; length; i++) {  var value = array[i],  // 如果指定了迭代函数  // 则对数组每一个元素进行迭代  computed = iteratee ? iteratee(value, i, array) : value;  // 如果是有序数组，则当前元素只需跟上一个元素对比即可  // 用 seen 变量保存上一个元素  if (isSorted) {  // 如果 i === 0，则直接 push  // 否则比较当前元素是否和前一个元素相等  if (!i || seen !== computed) result.push(value);  // seen 保存当前元素，供下一次对比  seen = computed;  } else if (iteratee) {  // 如果 seen[] 中没有 computed 这个元素值  if (!_.contains(seen, computed)) {  seen.push(computed);  result.push(value);  }  } else if (!_.contains(result, value)) {    // 如果不用经过迭代函数计算，也就不用 seen[] 变量了  result.push(value);  }  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26个常用易忘CSS小技巧</title>
      <link href="/2019/09/22/26-ge-chang-yong-yi-wang-css-xiao-ji-qiao/"/>
      <url>/2019/09/22/26-ge-chang-yong-yi-wang-css-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28854182&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>26个常用易忘CSS小技巧</p><p>收集于平时常用但易忘的CSS实现方法…..</p><p><strong>1.解决inline-block元素设置overflow:hidden属性导致相邻行内元素向下偏移</strong></p><pre><code>.wrap {  display: inline-block;  overflow: hidden  vertical-align: bottom}</code></pre><p><strong>2.超出部分显示省略号</strong></p><pre><code>// 单行文本.wrap {  overflow:hidden;/*超出部分隐藏*/  text-overflow:ellipsis;/*超出部分显示省略号*/  white-space:nowrap;/*规定段落中的文本不进行换行 */}// 多行文本.wrap {    width: 100%;    overflow: hidden;    display: -webkit-box;   //将对象作为弹性伸缩盒子模型显示  *必须结合的属性*    -webkit-box-orient: vertical;   //设置伸缩盒对象的子元素的排列方式  *必须结合的属性*    -webkit-line-clamp: 3;   //用来限制在一个块元素中显示的文本的行数    word-break: break-all;   //让浏览器实现在任意位置的换行 *break-all为允许在单词内换行*}</code></pre><p><strong>3.css实现不换行、自动换行、强制换行</strong></p><pre><code>//不换行.wrap {  white-space:nowrap;}//自动换行.wrap {  word-wrap: break-word;  word-break: normal;}//强制换行.wrap {  word-break:break-all;}</code></pre><p><strong>4.CSS实现文本两端对齐</strong></p><pre><code>.wrap {    text-align: justify;    text-justify: distribute-all-lines;  //ie6-8    text-align-last: justify;  //一个块或行的最后一行对齐方式    -moz-text-align-last: justify;    -webkit-text-align-last: justify;}</code></pre><p><strong>5.现文字竖向排版</strong></p><pre><code>// 单列展示时.wrap {    width: 25px;    line-height: 18px;    height: auto;    font-size: 12px;    padding: 8px 5px;    word-wrap: break-word;/*英文的时候需要加上这句，自动换行*/  }// 多列展示时.wrap {    height: 210px;    line-height: 30px;    text-align: justify;    writing-mode: vertical-lr;  //从左向右        writing-mode: tb-lr;        //IE从左向右    //writing-mode: vertical-rl;  -- 从右向左    //writing-mode: tb-rl;        -- 从右向左}</code></pre><p><strong>6.使元素鼠标事件失效</strong></p><pre><code>.wrap {    // 如果按tab能选中该元素，如button，然后按回车还是能执行对应的事件，如click。  pointer-events: none;    cursor: default;}</code></pre><p><strong>7.禁止用户选择</strong></p><pre><code>.wrap {  -webkit-touch-callout: none;  -webkit-user-select: none;  -khtml-user-select: none;  -moz-user-select: none;  -ms-user-select: none;  user-select: none;}</code></pre><p><strong>8.cursor属性</strong></p><pre><code>.wrap {  cursor：pointer; //小手指；  cursor：help; //箭头加问号；  cursor：wait; //转圈圈；  cursor：move; //移动光标；  cursor：crosshair; //十字光标}</code></pre><p><strong>9.使用硬件加速</strong></p><pre><code>.wrap {    transform: translateZ(0);}</code></pre><p><strong>10.图片宽度自适应</strong></p><pre><code>img {max-width: 100%}</code></pre><p><strong>11.Text-transform和Font Variant</strong></p><pre><code>p {text-transform: uppercase}  // 将所有字母变成大写字母p {text-transform: lowercase}  // 将所有字母变成小写字母p {text-transform: capitalize} // 首字母大写p {font-variant: small-caps}   // 将字体变成小型的大写字母</code></pre><p><strong>12.将一个容器设为透明</strong></p><pre><code>.wrap {   filter:alpha(opacity=50);   -moz-opacity:0.5;   -khtml-opacity: 0.5;   opacity: 0.5; }</code></pre><p><strong>13.消除transition闪屏</strong></p><pre><code>.wrap {    -webkit-transform-style: preserve-3d;    -webkit-backface-visibility: hidden;    -webkit-perspective: 1000;}</code></pre><p><strong>14.自定义滚动条</strong></p><pre><code>overflow-y: scroll;整个滚动条::-webkit-scrollbar {    width: 5px;}滚动条的轨道::-webkit-scrollbar-track {    background-color: #ffa336;    border-radius: 5px;}滚动条的滑块::-webkit-scorllbar-thumb {    background-color: #ffc076;    border-radius: 5px;}</code></pre><p><strong>15让 HTML 识别 string 里的 ‘\n’ 并换行</strong></p><pre><code>body {    white-space: pre-line;}</code></pre><p><strong>16.实现一个三角形</strong></p><pre><code>.wrap {   border-color: transparent transparent green transparent;   border-style: solid;   border-width: 0px 300px 300px 300px;   height: 0px;   width: 0px; }</code></pre><p><strong>17.移除被点链接的边框</strong></p><pre><code>  a {outline: none}  a {outline: 0}</code></pre><p><strong>18.使用CSS显示链接之后的URL</strong></p><pre><code>a:after{content:&quot; (&quot; attr(href) &quot;) &quot;;}</code></pre><p><strong>19.select内容居中显示、下拉内容右对齐</strong></p><pre><code>  select{      text-align: center;      text-align-last: center;  }  select option {      direction: rtl;  }</code></pre><p><strong>20.修改input输入框中光标的颜色不改变字体的颜色</strong></p><pre><code>  input{      color:  #fff;      caret-color: red;  }</code></pre><p><strong>21.修改input 输入框中 placeholder 默认字体样式</strong></p><pre><code>  //webkit内核的浏览器   input::-webkit-input-placeholder {      color: #c2c6ce;  }  //Firefox版本4-18   input:-moz-placeholder {      color: #c2c6ce;  }  //Firefox版本19+  input::-moz-placeholder {      color: #c2c6ce;  }  //IE浏览器  input:-ms-input-placeholder {      color: #c2c6ce;  }</code></pre><p><strong>22.子元素固定宽度 父元素宽度被撑开</strong></p><pre><code>// 父元素下的子元素是行内元素.wrap {  white-space: nowrap;}// 若父元素下的子元素是块级元素.wrap {  white-space: nowrap;  // 子元素不被换行  display: inline-block;}</code></pre><p><strong>23.让div里的图片和文字同时上下居中</strong></p><pre><code>  .wrap {    height: 100,    line-height: 100  }  img {    vertival-align：middle  }</code></pre><p>// vertical-align css的属性vertical-align用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。只对行内元素、表格单元格元素生效，不能用它垂直对齐块级元素<br>// vertical-align：baseline/top/middle/bottom/sub/text-top;</p><p><strong>24.实现宽高等比例自适应矩形</strong></p><pre><code>    .scale {        width: 100%;        padding-bottom: 56.25%;        height: 0;        position: relative;     }    .item {        position: absolute;         width: 100%;        height: 100%;        background-color: 499e56;    }    </code></pre>   <div class="scale">        <div class="item">            这里是所有子元素的容器        </div>    </div><p><strong>25.transfrom的rotate属性在span标签下失效</strong></p><pre><code>  span {    display: inline-block  }</code></pre><p><strong>26.边框字体同色</strong></p><pre><code>.wrap {    width: 200px;    height: 200px;    color: #000;    font-size: 30px;    border: 50px solid currentColor;    // border: 50px solid; // 实现二}</code></pre><p>  <strong>27.实现一个多边形</strong><br>     clip-path: polygon()</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0搭建自己的webpack开发环境(转)</title>
      <link href="/2019/09/22/cong-0-da-jian-zi-ji-de-webpack-kai-fa-huan-jing/"/>
      <url>/2019/09/22/cong-0-da-jian-zi-ji-de-webpack-kai-fa-huan-jing/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="从0搭建自己的webpack开发环境"><a href="#从0搭建自己的webpack开发环境" class="headerlink" title="从0搭建自己的webpack开发环境"></a><a href="https://juejin.im/post/5d7f4f14518825491b7240b7" target="_blank" rel="noopener">从0搭建自己的webpack开发环境</a></h1><hr><h1 id="webpack问题"><a href="#webpack问题" class="headerlink" title="webpack问题"></a>webpack问题</h1><ul><li><p><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack官网</a></p></li><li><p><a href="https://juejin.im/post/5db01b366fb9a0202f0c89bb" target="_blank" rel="noopener">webpack多页面内存溢出</a></p></li><li><p><a href="https://juejin.im/post/5aa3d2056fb9a028c36868aa" target="_blank" rel="noopener">webpack详解</a></p></li><li><p><a href="https://juejin.im/post/59bb37fa6fb9a00a554f89d2" target="_blank" rel="noopener">webpack：从入门到真实项目配置</a></p></li><li><p><a href="https://juejin.im/entry/5794d711128fe10056b947fe/detail" target="_blank" rel="noopener">Vue+Webpack 使用规范</a></p></li><li><p><a href="https://juejin.im/post/5bf61082f265da616a474b5c" target="_blank" rel="noopener">脑阔疼的webpack按需加载</a></p></li><li><p><a href="https://juejin.im/post/5b9116086fb9a05d05307e96" target="_blank" rel="noopener">webpack4 多页面，多环境配置</a></p></li><li><p><a href="https://juejin.im/entry/57cd199467f3560057c99607" target="_blank" rel="noopener">webpack 性能优化</a></p></li><li><p><a href="https://juejin.im/post/5af3be6d6fb9a07ab458a393" target="_blank" rel="noopener">如何让webpack打包的速度提升50%？</a></p></li><li><p><a href="https://www.cnblogs.com/sichaoyun/p/9241829.html" target="_blank" rel="noopener">vue-cli脚手架中webpack配置基础文件详解</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Native入坑之路 (一)</title>
      <link href="/2019/08/22/react-native-ru-keng-zhi-lu/"/>
      <url>/2019/08/22/react-native-ru-keng-zhi-lu/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=525454434&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="React-Native-入坑之路-一"><a href="#React-Native-入坑之路-一" class="headerlink" title="React-Native 入坑之路(一)"></a>React-Native 入坑之路(一)</h1><hr><h2 id="1-React-navigation-使用"><a href="#1-React-navigation-使用" class="headerlink" title="1. React-navigation 使用"></a>1. React-navigation 使用</h2><h3 id="1-导入依赖库"><a href="#1-导入依赖库" class="headerlink" title="1.导入依赖库"></a>1.导入依赖库</h3><pre><code>   npm install react-navigation --save</code></pre><p>  然后在 package.json 文件中就可以看到，依赖库已经导入完毕：</p><pre><code>   &quot;react-native-tab-navigator&quot;: &quot;^0.3.4&quot;,</code></pre><h3 id="2-配置Navigator"><a href="#2-配置Navigator" class="headerlink" title="2. 配置Navigator"></a>2. 配置Navigator</h3><ul><li><p>引入<br><img src="1.jpg" alt></p></li><li><p>使用<br><a href="https://www.jianshu.com/p/f39f020197ef" target="_blank" rel="noopener">React-navigation使用攻略</a></p></li></ul><h2 id="2-react-native-px2dp"><a href="#2-react-native-px2dp" class="headerlink" title="2. react-native-px2dp"></a>2. react-native-px2dp</h2><ul><li><p>安装<br>  npm install react-native-px2dp –save</p></li><li><p>使用<a href="https://www.jianshu.com/p/7836523b4d20" target="_blank" rel="noopener">React native 分辨率适配(px,dp)</a></p><pre><code>import px2dp from &#39;../../util/px2dp&#39;&#39;use strict&#39;;import {Dimensions} from &#39;react-native&#39;const deviceH = Dimensions.get(&#39;window&#39;).heightconst deviceW = Dimensions.get(&#39;window&#39;).widthconst basePx = 750export default function px2dp(px) {    return px *  deviceW / basePx}</code></pre></li></ul><h2 id="3-Dimensions-获取当前屏幕的宽高"><a href="#3-Dimensions-获取当前屏幕的宽高" class="headerlink" title="3. Dimensions 获取当前屏幕的宽高"></a>3. Dimensions 获取当前屏幕的宽高</h2><pre><code>const { deviceWidth, deviceHeight } = Dimensions.get(&#39;window&#39;);</code></pre><h2 id="4-AsyncStorage-本都存储"><a href="#4-AsyncStorage-本都存储" class="headerlink" title="4. AsyncStorage 本都存储"></a>4. AsyncStorage 本都存储</h2><p><a href="https://www.jianshu.com/p/abf4e19f245c" target="_blank" rel="noopener">ReactNative之AsyncStorage本地存储</a>:<a href="https://www.jianshu.com/p/abf4e19f245c" target="_blank" rel="noopener">https://www.jianshu.com/p/abf4e19f245c</a></p><h2 id="5-StatusBar的使用详解"><a href="#5-StatusBar的使用详解" class="headerlink" title="5. StatusBar的使用详解"></a>5. StatusBar的使用详解</h2><p><a href="https://www.jianshu.com/p/cff86e199c93" target="_blank" rel="noopener">StatusBar的使用详解</a>:<a href="https://www.jianshu.com/p/cff86e199c93" target="_blank" rel="noopener">https://www.jianshu.com/p/cff86e199c93</a></p><h2 id="6-ViewPagerAndroid"><a href="#6-ViewPagerAndroid" class="headerlink" title="6. ViewPagerAndroid"></a>6. ViewPagerAndroid</h2><p><a href="https://reactnative.cn/docs/next/viewpagerandroid.html" target="_blank" rel="noopener">官网</a><br><a href="https://www.jianshu.com/p/699a3b7da848" target="_blank" rel="noopener">React-Native ViewPagerAndroid使用</a></p><h2 id="7-React-Native-高德地图组件的使用（react-native-amap3d）"><a href="#7-React-Native-高德地图组件的使用（react-native-amap3d）" class="headerlink" title="7. React Native 高德地图组件的使用（react-native-amap3d）"></a>7. React Native 高德地图组件的使用（react-native-amap3d）</h2><p><a href="https://www.jianshu.com/p/fe90fc6a0308" target="_blank" rel="noopener">高德地图组件的使用</a>:<a href="https://www.jianshu.com/p/fe90fc6a0308" target="_blank" rel="noopener">https://www.jianshu.com/p/fe90fc6a0308</a></p><p><a href="https://blog.csdn.net/IT_luntan/article/details/78982497" target="_blank" rel="noopener">高德地图组件react-native-amap3d</a></p>]]></content>
      
      
      <categories>
          
          <category> RN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个基于vue和element-ui的树形穿梭框组件</title>
      <link href="/2019/08/20/vue-element-chuan-suo-kuang/"/>
      <url>/2019/08/20/vue-element-chuan-suo-kuang/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28854182&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>一个基于vue和element-ui的树形穿梭框组件</p><p><strong>el-tree-transfer</strong></p><blockquote><p>el-tree-fransfer是一个基于VUE和element-ui的树形穿梭框组件，使用前请确认已经引入element-ui！ 此组件功能类似于element-ui的transfer组件，但是里面的数据是树形结构！ 实际上，el-tree-transfer依赖的element-ui组件分别是Checkbox 多选框，Button 按钮，和最主要的Tree 树形控件写成！并非是在element-ui的穿梭框组件上的扩展，而仅仅是参照了其外观样式和功能。ui完全按照element-ui风格。<br>注意：使用此插件时默认你已经引入了element-ui的button，check-box，tree组件！<br>第一层数据的 pid 请设定为 0！！<br>id推荐为string，但也可以是number，请不要混用，id不能重复！</p></blockquote><p><strong>1.先npm下载插件</strong><br>     1. npm install el-tree-transfer –save<br>      或<br>     2.npm i el-tree-transfer -S</p><p>然后你可以像使用普通组件一样使用el-tree-transfer</p><pre><code>  &lt;template&gt;      &lt;div&gt;      // 你的代码      ...      // 使用树形穿梭框组件      &lt;tree-transfer :title=&quot;title&quot; :from_data=&#39;fromData&#39; :to_data=&#39;toData&#39; :defaultProps=&quot;{label:&#39;label&#39;}&quot;             @addBtn=&#39;add&#39; @removeBtn=&#39;remove&#39; :mode=&#39;mode&#39; height=&#39;540px&#39; filter openAll&gt;      &lt;/tree-transfer&gt;    &lt;/div&gt;  &lt;/template&gt;    &lt;script&gt;  import treeTransfer from &#39;el-tree-transfer&#39; // 引入    export defult {      data(){        return:{          mode: &quot;transfer&quot;, // transfer addressList          fromData:[            {              id: &quot;1&quot;,              pid: 0,              label: &quot;一级 1&quot;,              children: [                {                  id: &quot;1-1&quot;,                  pid: &quot;1&quot;,                  label: &quot;二级 1-1&quot;,                  children: []                },                {                  id: &quot;1-2&quot;,                  pid: &quot;1&quot;,                  label: &quot;二级 1-2&quot;,                  children: [                    {                      id: &quot;1-2-1&quot;,                      pid: &quot;1-2&quot;,                      children: [],                      label: &quot;二级 1-2-1&quot;                    },                    {                      id: &quot;1-2-2&quot;,                      pid: &quot;1-2&quot;,                      children: [],                      label: &quot;二级 1-2-2&quot;                    }                  ]                }              ]            },          ],          toData:[]        }      },      methods:{        // 切换模式 现有树形穿梭框模式transfer 和通讯录模式addressList        changeMode() {          if (this.mode == &quot;transfer&quot;) {            this.mode = &quot;addressList&quot;;          } else {            this.mode = &quot;transfer&quot;;          }        },        // 监听穿梭框组件添加        add(fromData,toData,obj){          // 树形穿梭框模式transfer时，返回参数为左侧树移动后数据、右侧树移动后数据、移动的        {keys,nodes,halfKeys,halfNodes}对象          // 通讯录模式addressList时，返回参数为右侧收件人列表、右侧抄送人列表、右侧密送人列表          console.log(&quot;fromData:&quot;, fromData);          console.log(&quot;toData:&quot;, toData);          console.log(&quot;obj:&quot;, obj);        },        // 监听穿梭框组件移除        remove(fromData,toData,obj){          // 树形穿梭框模式transfer时，返回参数为左侧树移动后数据、右侧树移动后数据、移动的{keys,nodes,halfKeys,halfNodes}对象          // 通讯录模式addressList时，返回参数为右侧收件人列表、右侧抄送人列表、右侧密送人列表          console.log(&quot;fromData:&quot;, fromData);          console.log(&quot;toData:&quot;, toData);          console.log(&quot;obj:&quot;, obj);        }      },      comporents:{ treeTransfer } // 注册    }  &lt;/script&gt;  &lt;style&gt;  ...  &lt;/style&gt;</code></pre><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><hr><p>参数：width 说明：宽度 类型：String 必填：false 默认：100% 补充：建议在外部盒子设定宽度和位置<br>参数：height 说明：高度 类型：String 必填：false 默认：320px<br>参数：title 说明：标题 类型：Array 必填：false 默认：[“源列表”, “目标列表”]<br>参数：button_text 说明：按钮名字 类型：Array 必填：false 默认：空<br>参数：from_data 说明：源数据 类型：Array 必填：true 补充：数据格式同element-ui tree组件，但必须有id和pid<br>参数：to_data 说明：目标数据 类型：Array 必填：true 补充：数据格式同element-ui tree组件，但必须有id和pid<br>参数：defaultProps 说明：配置项-同el-tree中props 必填： false 补充：用法和el-tree的props一样<br>参数：node_key 说明：自定义node-key的值，默认为id 必填：false 补充：必须与treedata数据内的id参数名一致，必须唯一<br>参数：pid 说明：自定义pid的参数名，默认为”pid” 必填：false 补充：有网友提出后台给的字段名不叫pid，因此增加自定义支持<br>参数：leafOnly 说明：是否只返回叶子节点 类型：Boolean 必填：false 补充：默认false，如果你只需要返回的末端子节点可使用此参数<br>参数：filter 说明：是否开启筛选功能 类型：Boolean 必填：false<br>参数：openAll 说明：是否默认展开全部 类型：Boolean 必填：false<br>参数：renderContent 说明：自定义树节点 类型：Function 必填：false 补充：用法同element-ui tree<br>参数：mode 说明：设置模式，字段可选值为transfer|addressList 类型：String 必填：false 补充：mode默认为transfer模式，即树形穿梭框模式，可配置字段为addressList改为通讯录模式，通讯录模式时按钮不可自定义名字，如要自定义标题名在title数组传入四个值即可，addressList模式时标题默认为通讯录、收件人、抄送人、密送人<br>参数：transferOpenNode 说明：穿梭后是否展开穿梭的节点 类型：Boolean 必填：false 补充：默认为true即展开穿梭的节点，便于视觉查看，增加此参数是因为数据量大时展开会有明显卡顿问题，但注意，如此参数设置为false则穿梭后不展开，毕竟无法确定第几层就会有庞大数据<br>参数：defaultCheckedKeys 说明：默认展开节点 类型：Array 必填：false 补充：只匹配初始时默认节点，不会在你操作后动态改变默认节点<br>参数：placeholder 说明：设置搜索框提示语 类型：String 必填：false 补充：默认为请输入关键词进行筛选<br>参数：defaultTransfer 说明：是否自动穿梭一次默认选中defaultCheckedKeys的节点 类型：Boolean 必填：false 补充：默认false，用来满足用户不想将数据拆分成fromData和toData的需求<br>参数：arrayToTree 说明：是否开启一维数组转化为树形结构 类型：Boolean 必填：false 补充：数据必须存在根节点，并且不会断节，数据格式详见github上app.vue，根据id、pid对应关系转化，存在一定的性能问题<br>参数：addressOptions 说明：通讯录模式配置项{num: Number, suffix: String, connector: String} 类型：Object 必填：false 补充：num-&gt; 所需右侧通讯录个数,默认3 suffix-&gt; label后想要拼接的字段（如id，即取此条数据的id拼接在后方）默认suffix connector -&gt; 连接符（字符串）默认-<br>参数：lazy 说明：是否启用懒加载 类型：Boolean 必填：false 补充：默认false，效果动el-tree懒加载，不可和openAll或默认展开同时使用<br>参数：lazyFn 说明：懒加载的回调函数 类型：Function 必填：true 补充：当适用lazy时必须传入回调函数，示例:lazyFn=’loadNode’,返回参数loadNode(node, resolve, from), node-&gt;当前展开节点node，resolve-&gt;懒加载resolve，from -&gt; left|right 表示回调来自左侧|右侧<br>事件：addBtn 说明：点击添加按钮时触发的事件 回调参数：function(fromData,toData,obj),树形穿梭框transfer模式分别为1.移动后左侧数据，2.移动后右侧数据，3.移动的节点keys、nodes、halfKeys、halfNodes对象；通讯录addressList模式时返回参数为右侧收件人列表、右侧抄送人列表、右侧密送人列表<br>事件：removeBtn 说明：点击移除按钮时触发的事件 回调参数：function(fromData,toData,obj),树形穿梭框transfer模式分别为1.移动后左侧数据，2.移动后右侧数据，3.移动的节点keys、nodes、halfKeys、halfNodes对象；通讯录addressList模式时返回参数为右侧收件人列表、右侧抄送人列表、右侧密送人列表<br>事件：left-check-change 说明：左侧源数据勾选事件 回调参数：function(nodeObj, treeObj)见el-tree组件check事件返回值<br>事件：right-check-change 说明：右侧目标数据勾选事件 回调参数：function(nodeObj, treeObj)见el-tree组件check事件返回值<br>Slot：left-footer, right-footer 说明：穿梭框左侧、右侧底部slot<br>Slot: title-left, title-right 说明：穿梭框标题区左侧、右侧自定义内容</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native 搭建小白教程</title>
      <link href="/2019/08/06/react-native-da-jian-jiao-cheng/"/>
      <url>/2019/08/06/react-native-da-jian-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1347529350&auto=1&height=66"></iframe></div><p>前言：因为电脑是 windows 系统，为了开始 React-Native 的入坑之路，只能硬着头皮上了，搭建环境的路上走了很多的坑，现在我把我成功搭建的路子记录下来，希望帮助大家少走弯路，也让我以后再搭建的时候，有个记忆，现在正式开始……</p><h1 id="windows-环境下搭建-React-Native-开发环境"><a href="#windows-环境下搭建-React-Native-开发环境" class="headerlink" title="windows 环境下搭建 React-Native 开发环境"></a>windows 环境下搭建 React-Native 开发环境</h1><hr><h1 id="RN-搭建开发环境-官网"><a href="#RN-搭建开发环境-官网" class="headerlink" title="RN-搭建开发环境-官网"></a>RN-搭建开发环境-官网</h1><ul><li><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">RN-搭建开发环境-官网</a>:<a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">https://reactnative.cn/docs/getting-started.html</a></li></ul><h1 id="详细搭建过程"><a href="#详细搭建过程" class="headerlink" title="详细搭建过程"></a>详细搭建过程</h1><h2 id="第一步：安装-Node"><a href="#第一步：安装-Node" class="headerlink" title="第一步：安装 Node"></a>第一步：安装 Node</h2><pre><code>Node  (&gt;8.3)</code></pre><p>安装完 Node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。</p><pre><code>npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global</code></pre><p>注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！</p><h2 id="第二步：-安装-yarn"><a href="#第二步：-安装-yarn" class="headerlink" title="第二步： 安装 yarn"></a>第二步： 安装 yarn</h2><p>Yarn 是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。安装 yarn 需要用 npm</p><pre><code>npm install -g yarn</code></pre><p>安装完 yarn 后同理也要设置镜像源：</p><pre><code>yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global</code></pre><p>安装完 yarn 之后就可以用 yarn 代替 npm 了，例如用 yarn 代替 npm install 命令，用 yarn add 代替 npm install.</p><h2 id="第三步-React-Native-命令行工具（react-native-cli）"><a href="#第三步-React-Native-命令行工具（react-native-cli）" class="headerlink" title="第三步: React Native 命令行工具（react-native-cli）"></a>第三步: React Native 命令行工具（react-native-cli）</h2><p>React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p><pre><code> npm install -g react-native-cli</code></pre><h2 id="第四步-Python2-x-不支持-3-x"><a href="#第四步-Python2-x-不支持-3-x" class="headerlink" title="第四步: Python2.x (不支持 3.x)"></a>第四步: Python2.x (不支持 3.x)</h2><p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python 的官网下载地址</a>:<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a></p><p><img src="python.jpg" alt></p><h2 id="第五步-JDK-1-8-不支持更高版本"><a href="#第五步-JDK-1-8-不支持更高版本" class="headerlink" title="第五步: JDK (==1.8 , 不支持更高版本)"></a>第五步: JDK (==1.8 , 不支持更高版本)</h2><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">React Native 要求 JDK 的版本为 1.8，官网的下载地址</a>:<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>选择本系统合适的版本，即可，本人是 Windows x64 版本，即：</p><p><img src="jdk.jpg" alt></p><p>安装好了之后，可以测试一下是否安装好 打开命令窗口终端（按住 windows+r ） 输入 java -version 回车 如果出现下图就安装成功了，如果不行，重启一下电脑再试<br><img src="2.jpg" alt></p><h2 id="第六步-安装-Android-环境"><a href="#第六步-安装-Android-环境" class="headerlink" title="第六步: 安装 Android 环境"></a>第六步: 安装 Android 环境</h2><p><a href="http://www.android-studio.org/index.php/download" target="_blank" rel="noopener">安装 Android 环境，首先先安装 Android Studio，下载地址</a>;<a href="http://www.android-studio.org/index.php/download" target="_blank" rel="noopener">http://www.android-studio.org/index.php/download</a></p><p><img src="1.jpg" alt></p><p>下载下来的是一个可安装程序，点击安装即可，在点击“Next”过程，有一步需要指定 Android SDK 的路径，如果之前电脑中已经存在 SDK，可以指定该路径，后续就可以不用下载 SDK；由于本地没有安装过 SDK 的场景，这里暂时可以指定一个后续将保存 SDK 的路径。</p><p>点击“Finish”后，开始自动下载 SDK，此时根据网速的快慢，决定这个步骤的时间的长短，下载完成后，则会进行 Android Studio 的欢迎画面，如图</p><p><img src="3.jpg" alt></p><h3 id="配置环境变量（特别重要）"><a href="#配置环境变量（特别重要）" class="headerlink" title="配置环境变量（特别重要）"></a>配置环境变量（特别重要）</h3><ul><li>鼠标右键点击计算机，选择属性之后再按下图操作<br><img src="5.jpg" alt></li></ul><p>然后在编辑系统变量的这个框里面的变量值中操作以下步骤</p><ol><li><p>找到 Android SDK 的目录的路径复制添加到 path<br><img src="6.jpg" alt></p></li><li><p>找到 android sdk 中 platform-tools 文件的路径地址添加到 pah，记住一定要打分号哦，跟前一个路径区分开</p><p> 例如我的路径就是 F:\android-sdk_r24.4.1-windows\android-sdk-windows\platform-tools<br> <img src="7.jpg" alt></p></li><li><p>找到<code>android sdk 中 tools</code>文件的路径地址添加到<code>pah</code> 最后点击确定 确定 确定 就完事了</p></li></ol><p>然后打开命令终端 <code>（windows + r）</code> 输入 adb，测试一下，只要没有报错，就成功了</p><p><code>我们再把java sdk配置了，按下图操作</code></p><p><img src="8.jpg" alt></p><p>我因为第一次搭建失败了，查了很久了，我添加了一个 Android sdk 的系统变量，第二次搭建就成功了，不知道是不是这个原因，最好添加一下吧，以防万一</p><p><img src="9.jpg" alt></p><p>Android SDK 默认的应该是在 C:\Users\Administrator\AppData\Local\Android\Sdk</p><p>这个地方我也有一个疑问，为什么我的 android sdk 压缩包是解压在 F 盘里的，C 盘也会有一个 sdk，这个地方的配置<code>要用c盘的sdk</code>，记住了</p><h2 id="第七步-安装一个模拟器-我选择的是夜神模拟器"><a href="#第七步-安装一个模拟器-我选择的是夜神模拟器" class="headerlink" title="第七步: 安装一个模拟器 我选择的是夜神模拟器"></a>第七步: 安装一个模拟器 我选择的是夜神模拟器</h2><ul><li>安装夜神模拟器，安装好之后，最好将分辨率调成<code>手机端</code><br><a href="https://www.yeshen.com/" target="_blank" rel="noopener">夜神官网</a>:<a href="https://www.yeshen.com/" target="_blank" rel="noopener">https://www.yeshen.com/</a></li></ul><h2 id="第八步-打开命令窗口，输入-react-native-init-firstdemo-创建项目名为firstdemo的文件夹"><a href="#第八步-打开命令窗口，输入-react-native-init-firstdemo-创建项目名为firstdemo的文件夹" class="headerlink" title="第八步: 打开命令窗口，输入 react-native init firstdemo 创建项目名为firstdemo的文件夹"></a>第八步: 打开命令窗口，输入 react-native init firstdemo 创建项目名为<code>firstdemo</code>的文件夹</h2><p>之后在 firstdemo 项目目录中找到 android 目录，创建一个文件，如下图</p><p><img src="10.jpg" alt><br>然后内容为：<code>sdk.dir=android sdk</code>目录路径，如下图，记住，一定是<code>双斜杠</code>，</p><p><img src="11.jpg" alt></p><h2 id="第九步-连接模拟器，运行项目"><a href="#第九步-连接模拟器，运行项目" class="headerlink" title="第九步: 连接模拟器，运行项目"></a>第九步: 连接模拟器，运行项目</h2><p>打开项目目录，按住 shift 键，鼠标右键点击，选择在此处打开命令窗口，输入 react-native start （启动项目服务进程），如下图</p><p><img src="12.jpg" alt></p><p>接下来，刚刚的命令窗口别关闭了，重新打开一个命令窗口，连接夜神模拟器</p><h3 id="9-1-打开夜神模拟器"><a href="#9-1-打开夜神模拟器" class="headerlink" title="9.1 打开夜神模拟器"></a>9.1 打开夜神模拟器</h3><h3 id="9-2-重新打开一个命令窗口，执行命令-adb-connect-127-0-0-1-62001以连接模拟器，（这个地方主义一下，端口号62001，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图："><a href="#9-2-重新打开一个命令窗口，执行命令-adb-connect-127-0-0-1-62001以连接模拟器，（这个地方主义一下，端口号62001，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图：" class="headerlink" title="9.2 重新打开一个命令窗口，执行命令 adb connect 127.0.0.1:62001以连接模拟器，（这个地方主义一下，端口号62001，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图："></a>9.2 重新打开一个命令窗口，执行命令 <code>adb connect 127.0.0.1:62001</code>以连接模拟器，（这个地方主义一下，端口号<code>62001</code>，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图：</h3><p><img src="13.jpg" alt></p><h3 id="9-3-再执行命令-react-native-run-android-这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有-t-z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图："><a href="#9-3-再执行命令-react-native-run-android-这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有-t-z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图：" class="headerlink" title="9.3 再执行命令 react-native run-android ,这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有 t z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图："></a>9.3 再执行命令 react-native run-android ,这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有 t z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图：</h3><p><img src="14.jpg" alt><br><img src="15.jpg" alt></p><p>成功之后，你会看到你的模拟器自动打开了一个 app，但是整个页面都是红色的，想报错一样，别慌张，还有最后一步</p><p><img src="16.jpg" alt><br><img src="17.jpg" alt></p><p>输入电脑地址(<code>ipconfig =&gt; IPv4 地址</code>)+ 端口号<code>8081</code>:如图<br><img src="21.jpg" alt></p><p><img src="18.jpg" alt></p><p>最后再运行命令 react-native run-android 模拟器会出现 app 界面，</p><p><img src="20.jpg" alt></p><p>好了，恭喜你，环境搭建好了，开始你的 RN 踩坑之路吧，</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native 搭建小白教程</title>
      <link href="/2019/07/13/react-native-da-jian-xiao-bai-jiao-cheng/"/>
      <url>/2019/07/13/react-native-da-jian-xiao-bai-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1347529350&auto=1&height=66"></iframe></div><p>前言：因为电脑是 windows 系统，为了开始 React-Native 的入坑之路，只能硬着头皮上了，搭建环境的路上走了很多的坑，现在我把我成功搭建的路子记录下来，希望帮助大家少走弯路，也让我以后再搭建的时候，有个记忆，现在正式开始……</p><h1 id="windows-环境下搭建-React-Native-开发环境"><a href="#windows-环境下搭建-React-Native-开发环境" class="headerlink" title="windows 环境下搭建 React-Native 开发环境"></a>windows 环境下搭建 React-Native 开发环境</h1><hr><h1 id="RN-搭建开发环境-官网"><a href="#RN-搭建开发环境-官网" class="headerlink" title="RN-搭建开发环境-官网"></a>RN-搭建开发环境-官网</h1><ul><li><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">RN-搭建开发环境-官网</a>:<a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">https://reactnative.cn/docs/getting-started.html</a></li></ul><h1 id="详细搭建过程"><a href="#详细搭建过程" class="headerlink" title="详细搭建过程"></a>详细搭建过程</h1><h2 id="第一步：安装-Node"><a href="#第一步：安装-Node" class="headerlink" title="第一步：安装 Node"></a>第一步：安装 Node</h2><pre><code>Node  (&gt;8.3)</code></pre><p>安装完 Node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。</p><pre><code>npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global</code></pre><p>注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！</p><h2 id="第二步：-安装-yarn"><a href="#第二步：-安装-yarn" class="headerlink" title="第二步： 安装 yarn"></a>第二步： 安装 yarn</h2><p>Yarn 是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。安装 yarn 需要用 npm</p><pre><code>npm install -g yarn</code></pre><p>安装完 yarn 后同理也要设置镜像源：</p><pre><code>yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global</code></pre><p>安装完 yarn 之后就可以用 yarn 代替 npm 了，例如用 yarn 代替 npm install 命令，用 yarn add 代替 npm install.</p><h2 id="第三步-React-Native-命令行工具（react-native-cli）"><a href="#第三步-React-Native-命令行工具（react-native-cli）" class="headerlink" title="第三步: React Native 命令行工具（react-native-cli）"></a>第三步: React Native 命令行工具（react-native-cli）</h2><p>React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p><pre><code> npm install -g react-native-cli</code></pre><h2 id="第四步-Python2-x-不支持-3-x"><a href="#第四步-Python2-x-不支持-3-x" class="headerlink" title="第四步: Python2.x (不支持 3.x)"></a>第四步: Python2.x (不支持 3.x)</h2><p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python 的官网下载地址</a>:<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a></p><p><img src="python.jpg" alt></p><h2 id="第五步-JDK-1-8-不支持更高版本"><a href="#第五步-JDK-1-8-不支持更高版本" class="headerlink" title="第五步: JDK (==1.8 , 不支持更高版本)"></a>第五步: JDK (==1.8 , 不支持更高版本)</h2><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">React Native 要求 JDK 的版本为 1.8，官网的下载地址</a>:<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>选择本系统合适的版本，即可，本人是 Windows x64 版本，即：</p><p><img src="jdk.jpg" alt></p><p>安装好了之后，可以测试一下是否安装好 打开命令窗口终端（按住 windows+r ） 输入 java -version 回车 如果出现下图就安装成功了，如果不行，重启一下电脑再试<br><img src="2.jpg" alt></p><h2 id="第六步-安装-Android-环境"><a href="#第六步-安装-Android-环境" class="headerlink" title="第六步: 安装 Android 环境"></a>第六步: 安装 Android 环境</h2><p><a href="http://www.android-studio.org/index.php/download" target="_blank" rel="noopener">安装 Android 环境，首先先安装 Android Studio，下载地址</a>;<a href="http://www.android-studio.org/index.php/download" target="_blank" rel="noopener">http://www.android-studio.org/index.php/download</a></p><p><img src="1.jpg" alt></p><p>下载下来的是一个可安装程序，点击安装即可，在点击“Next”过程，有一步需要指定 Android SDK 的路径，如果之前电脑中已经存在 SDK，可以指定该路径，后续就可以不用下载 SDK；由于本地没有安装过 SDK 的场景，这里暂时可以指定一个后续将保存 SDK 的路径。</p><p>点击“Finish”后，开始自动下载 SDK，此时根据网速的快慢，决定这个步骤的时间的长短，下载完成后，则会进行 Android Studio 的欢迎画面，如图</p><p><img src="3.jpg" alt></p><h3 id="配置环境变量（特别重要）"><a href="#配置环境变量（特别重要）" class="headerlink" title="配置环境变量（特别重要）"></a>配置环境变量（特别重要）</h3><ul><li>鼠标右键点击计算机，选择属性之后再按下图操作<br><img src="5.jpg" alt></li></ul><p>然后在编辑系统变量的这个框里面的变量值中操作以下步骤</p><ol><li><p>找到 Android SDK 的目录的路径复制添加到 path<br><img src="6.jpg" alt></p></li><li><p>找到 android sdk 中 platform-tools 文件的路径地址添加到 pah，记住一定要打分号哦，跟前一个路径区分开</p><p> 例如我的路径就是 F:\android-sdk_r24.4.1-windows\android-sdk-windows\platform-tools<br> <img src="7.jpg" alt></p></li><li><p>找到<code>android sdk 中 tools</code>文件的路径地址添加到<code>pah</code> 最后点击确定 确定 确定 就完事了</p></li></ol><p>然后打开命令终端 <code>（windows + r）</code> 输入 adb，测试一下，只要没有报错，就成功了</p><p><code>我们再把java sdk配置了，按下图操作</code></p><p><img src="8.jpg" alt></p><p>我因为第一次搭建失败了，查了很久了，我添加了一个 Android sdk 的系统变量，第二次搭建就成功了，不知道是不是这个原因，最好添加一下吧，以防万一</p><p><img src="9.jpg" alt></p><p>Android SDK 默认的应该是在 C:\Users\Administrator\AppData\Local\Android\Sdk</p><p>这个地方我也有一个疑问，为什么我的 android sdk 压缩包是解压在 F 盘里的，C 盘也会有一个 sdk，这个地方的配置<code>要用c盘的sdk</code>，记住了</p><h2 id="第七步-安装一个模拟器-我选择的是夜神模拟器"><a href="#第七步-安装一个模拟器-我选择的是夜神模拟器" class="headerlink" title="第七步: 安装一个模拟器 我选择的是夜神模拟器"></a>第七步: 安装一个模拟器 我选择的是夜神模拟器</h2><ul><li>安装夜神模拟器，安装好之后，最好将分辨率调成<code>手机端</code><br><a href="https://www.yeshen.com/" target="_blank" rel="noopener">夜神官网</a>:<a href="https://www.yeshen.com/" target="_blank" rel="noopener">https://www.yeshen.com/</a></li></ul><h2 id="第八步-打开命令窗口，输入-react-native-init-firstdemo-创建项目名为firstdemo的文件夹"><a href="#第八步-打开命令窗口，输入-react-native-init-firstdemo-创建项目名为firstdemo的文件夹" class="headerlink" title="第八步: 打开命令窗口，输入 react-native init firstdemo 创建项目名为firstdemo的文件夹"></a>第八步: 打开命令窗口，输入 react-native init firstdemo 创建项目名为<code>firstdemo</code>的文件夹</h2><p>之后在 firstdemo 项目目录中找到 android 目录，创建一个文件，如下图</p><p><img src="10.jpg" alt><br>然后内容为：<code>sdk.dir=android sdk</code>目录路径，如下图，记住，一定是<code>双斜杠</code>，</p><p><img src="11.jpg" alt></p><h2 id="第九步-连接模拟器，运行项目"><a href="#第九步-连接模拟器，运行项目" class="headerlink" title="第九步: 连接模拟器，运行项目"></a>第九步: 连接模拟器，运行项目</h2><p>打开项目目录，按住 shift 键，鼠标右键点击，选择在此处打开命令窗口，输入 react-native start （启动项目服务进程），如下图</p><p><img src="12.jpg" alt></p><p>接下来，刚刚的命令窗口别关闭了，重新打开一个命令窗口，连接夜神模拟器</p><h3 id="9-1-打开夜神模拟器"><a href="#9-1-打开夜神模拟器" class="headerlink" title="9.1 打开夜神模拟器"></a>9.1 打开夜神模拟器</h3><h3 id="9-2-重新打开一个命令窗口，执行命令-adb-connect-127-0-0-1-62001以连接模拟器，（这个地方主义一下，端口号62001，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图："><a href="#9-2-重新打开一个命令窗口，执行命令-adb-connect-127-0-0-1-62001以连接模拟器，（这个地方主义一下，端口号62001，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图：" class="headerlink" title="9.2 重新打开一个命令窗口，执行命令 adb connect 127.0.0.1:62001以连接模拟器，（这个地方主义一下，端口号62001，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图："></a>9.2 重新打开一个命令窗口，执行命令 <code>adb connect 127.0.0.1:62001</code>以连接模拟器，（这个地方主义一下，端口号<code>62001</code>，是夜神模拟器默认的，如果你是其他的模拟器，记得查阅一下，默认端口号是多少）如下图：</h3><p><img src="13.jpg" alt></p><h3 id="9-3-再执行命令-react-native-run-android-这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有-t-z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图："><a href="#9-3-再执行命令-react-native-run-android-这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有-t-z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图：" class="headerlink" title="9.3 再执行命令 react-native run-android ,这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有 t z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图："></a>9.3 再执行命令 react-native run-android ,这里需要说明一下，第一次启动这个命令的话，他要下载一些依赖的东西，最好是要有 t z，不然会很慢，也可能会失败，这直接关系到最后能不能成功搭建环境，我这里是已经执行过一次这个命令了，如下图：</h3><p><img src="14.jpg" alt><br><img src="15.jpg" alt></p><p>成功之后，你会看到你的模拟器自动打开了一个 app，但是整个页面都是红色的，想报错一样，别慌张，还有最后一步</p><p><img src="16.jpg" alt><br><img src="17.jpg" alt></p><p>输入电脑地址(<code>ipconfig =&gt; IPv4 地址</code>)+ 端口号<code>8081</code>:如图<br><img src="21.jpg" alt></p><p><img src="18.jpg" alt></p><p>最后再运行命令 react-native run-android 模拟器会出现 app 界面，</p><p><img src="20.jpg" alt></p><p>好了，恭喜你，环境搭建好了，开始你的 RN 踩坑之路吧，</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常用数组操作方法</title>
      <link href="/2019/01/22/js-chang-yong-shu-zu-cao-zuo-fang-fa/"/>
      <url>/2019/01/22/js-chang-yong-shu-zu-cao-zuo-fang-fa/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>你真的了解JS数组的那些方法吗？</p><blockquote><p>寄语：<br>JS数组的方法非常的丰富和琐碎，学习和使用过程中总是需要反复的记忆、查看文档，但作为JS基础这样真的不应该，我们应该把它记得滚瓜烂熟，深入理解才对。<br>但是要怎样才能做到呢？这正是我也本文的初衷，根据个人的经验总结了一下，希望能够帮助和我一样困惑的人，搞定这个头疼的问题。</p></blockquote><p><strong>数组的方法</strong><br>JavaScript的数组方法包括数组原型的方法、构造函数的方法（ES6新增部分）<br>针对每一个方法我们主要了解四个方面：<strong>作用、参数、返回值、原数组是否改变</strong></p><p><strong>（一）. 原型上的方法</strong></p><p><strong>1. push()</strong><br>作用：向数组的末尾添加一项或多项<br>参数：ele1[, ele2[, …[, elen]]]<br>返回值：添加元素后数组的长度<br>原数组是否改变：是</p><p>let arr = [1, 2, 3];<br>let temp = arr.push(‘a’, ‘b’);<br>console.log(arr, temp); // [1, 2, 3, ‘a’, ‘b’] 5</p><p><strong>2. pop()</strong><br>作用：删除数组最后一项<br>参数：无<br>返回值：删除的那一项<br>原数组是否改变：是</p><p>let arr = [1, 2, 3];<br>let temp = arr.pop();<br>console.log(arr, temp); // [1, 2] 3</p><p><strong>3. unshift()</strong><br>作用：向数组开头添加一项或多项<br>参数：ele1[, ele2[, …[, elen]]]<br>返回值：添加元素后数组的长度<br>原数组是否改变：是<br>let arr = [1, 2, 3];<br>let temp = arr.unshift(‘a’, ‘b’);<br>console.log(arr, temp); // [‘a’, ‘b’, 1, 2, 3] 5</p><p><strong>4. splice()</strong><br>作用：删除、插入、替换数组项<br>参数：startIndex[, deleteCount[, item1[, …[, itemN]]]]<br>返回值：删除项组成的数组<br>原数组是否改变：是<br>let arr = [1, 2, 3];</p><p>// 插入元素<br>let temp = arr.splice(1, 0, ‘a’, ‘b’); // 在索引1的位置插入元素’a’和’b’<br>console.log(arr, temp); // [1, ‘a’, ‘b’, 2, 3] []</p><p>// 删除元素<br>let temp1 = arr.splice(1, 2); // 删除从索引1的位置开始的2项<br>console.log(arr, temp1); // [1, 2, 3] [‘a’, ‘b’]</p><p>// 替换一个元素<br>let temp2 = arr.splice(1, 1, ‘a’); // 将索引1的位置的元素替换为’a’<br>console.log(arr, temp2); // [1, ‘a’, 3 ] [2]</p><p>// 替换多个元素<br>let temp3 = arr.splice(0, 2, ‘b’, ‘c’); // 将索引0的位置开始的两项，替换成’b‘和’c‘<br>console.log(arr, temp3); // [’b‘, ‘c’, 3] [1, ‘a’]</p><p>// 只传第一个参数，则删除从第一个参数指定的位置到数组结尾的所有项<br>let temp4 = arr.splice(0); //从索引0的位置开始，删除后面的所有项<br>console.log(arr, temp4); // [] [’b‘, ‘c’, 3]</p><p><strong>6. copyWithin()</strong></p><p>作用：将数组指定位置（start到end）的元素复制到当前数组的其他位置（target开始），这种复制会替换原位置的元素（ES6新增）<br>参数说明：target[,start[,end]]<br>参数说明：</p><p>target: 复制的目标位置（包括），即要被替换的元素开始的位置<br>start: 要copy的元素的开始位置，默认0<br>end: 要copy的元素的结束位置，默认为数组最后一个元素</p><p>返回值：复制替换之后的数组<br>原数组是否改变：是<br>let arr = [1, 2, 3, 4, 5];<br>// 用索引0<del>4范围内的元素，替换索引3</del>4范围内的元素，因为要替换的位置只有两个，所以只将4，5替换为了1，2<br>let temp = arr.copyWithin(3);<br>console.log(arr, temp); //  [1, 2, 3, 1, 2] [1, 2, 3, 1, 2]</p><p>let arr1 = [1, 2, 3, 4, 5];<br>// 用索引2<del>4范围内的元素，替换索引3</del>4范围内的元素，因为要替换的位置只有两个，所以只将4，5替换为了3，4<br>let temp1 = arr1.copyWithin(3, 2);<br>console.log(arr1, temp1); // [1, 2, 3, 3, 4] [1, 2, 3, 3, 4]</p><blockquote><p>小结：<br>总结上述的描述，copyWithin的作用就是在数组长度的范围内，复制start(包括)到end(不包括)范围内的元素，然后用上述的元替换掉从target（包括）开始到数组结尾的元素，能替换多少就替换多少</p></blockquote><p><strong>7. reverse</strong><br>作用：翻转原数组<br>参数：无<br>返回值：翻转后的数组<br>原数组是否改变：是<br>let arr = [1, 2, 3];<br>let temp = arr.reverse();<br>console.log(arr, temp); // [ 3, 2, 1 ] [ 3, 2, 1 ]</p><p><strong>8. sort()</strong><br>作用：数组排序<br>参数：compareFunction<br>参数说明：</p><p>compareFunction返回值大于0时调换当前比对项的顺序，否则顺序不 变;<br>参数可以不传，不传默认按照Unicode编码的顺序排列<br>返回值：排序后的数组<br>原数组是否改变：是<br>// 数组从小到大排序<br>let arr = [1, 4, 6, 7, 8, 3, 2];<br>let temp = arr.sort((a, b) =&gt; {<br>    return a - b;<br>})<br>console.log(arr, temp); // [ 1, 2, 3, 4, 6, 7, 8 ] [ 1, 2, 3, 4, 6, 7, 8 ]</p><p>// 一个实用的数组排序的例子，根据对象元素的排序，排序对象在数组中的位置<br>let objArr = [{id: 3, name: “lilei”},{id: 1, name: “hanmeimei”},{id: 2, name: “yimi”}];<br>let tempArr = objArr.sort((a, b) =&gt; {<br>    // 按照id从小到大的顺序，对数组中的对象进行排序<br>    // 这个示例说明回调函数的形参a,b实际就是数组中当前进行比对的两个元素<br>    return a.id - b.id;<br>});<br>console.log(objArr); //  [{id: 1, name: ‘hanmeimei’}, {id: 2, name: ‘yimi’}, { id: 3, name: ‘lilei’ }]<br>console.log(tempArr); // [{id: 1, name: ‘hanmeimei’}, {id: 2, name: ‘yimi’}, { id: 3, name: ‘lilei’}]</p><p><strong>9. concat</strong><br>作用：基于当前的数组拼接数组<br>参数：value1[, value2[, …[, valueN]]<br>参数说明：</p><p>参数的类型可以是任意类型。<br>不是数组类型直接按顺序拼接到数组末尾，数组类型的则将数组元素逐一取出拼接到数组末尾<br>不传则相当于复制数组</p><p>返回值：拼接后的数组<br>原数组是否改变：否</p><p>let arr = [1,2];<br>let temp = arr.concat(‘a’, {id:1}, [‘lilei’, ‘hanmeimei’]);<br>console.log(arr, temp); // [ 1, 2 ] [ 1, 2, ‘a’, { id: 1 }, ‘lilei’, ‘hanmeimei’]</p><p>// 用于复制数组<br>let arr = [1, 2];<br>let temp = arr.concat();<br>console.log(arr, temp);  // [ 1, 2 ] [ 1, 2 ]</p><p><strong>10. slice()</strong><br>作用：基于当前数组的一项或多项创建一个新的数组<br>参数：startIndex[,endIndex]<br>参数说明：返回的元素包含startIndex位置的元素，但不包括endIndex位置的元素<br>返回值：返回截取的元素组成的数组<br>原数组是否改变：否</p><p>let arr = [0, 1, 2, 3, 4];<br>let temp = arr.slice(1,3); // 返回从索引1（包括）位置到索引3（不包括）位置之前的元素<br>console.log(arr, temp); // [0, 1, 2, 3, 4] [1, 2]</p><p>// 用于复制数组<br>let arr = [0, 1, 2, 3, 4];<br>let temp = arr.slice(0); // 返回从索引0（包括）位置到数组结尾的所有元素<br>console.log(arr, temp); // [0, 1, 2, 3, 4] [0, 1, 2, 3, 4]</p><p><strong>11.indexOf()</strong>:<br>作用：从数组开头查找元素在数组中的索引位置（ES5的方法）<br>参数：searchElement[, fromIndex]<br>返回值：searchElement在数组中的索引，没找到searchElement则返回-1<br>原数组是否改变：否<br>let arr = [1, 2, 3, 4, 5, 6, 2];<br>// 从数组开头开始查找<br>let temp = arr.indexOf(2);<br>console.log(arr, temp); // [ 1, 2, 3, 4, 5, 6, 2 ] 1<br>// 从指定的位置开始查找<br>let temp1 = arr.indexOf(2,3); // 从索引3(包括)的位置向后查找元素2<br>console.log(arr, temp1); // [ 1, 2, 3, 4, 5, 6, 2 ] 6<br>复制代码</p><p><strong>12.lastIndexOf():</strong><br>作用：从数组结尾查找元素在数组中的索引位置（ES5的方法）<br>参数：searchElement[, fromIndex]<br>返回值：searchElement在数组中的索引，没找到searchElement则返回-1<br>原数组是否改变：否<br>let arr = [1, 2, 3, 4, 5, 6, 2];<br>// 从数组末尾开始查找<br>let temp = arr.lastIndexOf(2);<br>console.log(arr, temp); // [ 1, 2, 3, 4, 5, 6, 2 ] 6<br>// 从指定的位置开始查找<br>let temp1 = arr.lastIndexOf(2,3); // 从索引3(包括)的位置向前查找元素2<br>console.log(arr, temp1); // [ 1, 2, 3, 4, 5, 6, 2 ] 1<br>复制代码</p><p><strong>13.every():</strong><br>作用：对数组中的每一项运行给定函数，如果该函数对每一项都返回true,则返回true（ES5方法）<br>参数：callback[, thisArg]<br>参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)<br>返回值：true 或 false<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4];<br>let temp = arr.every((item, index, array) =&gt; {<br>    return item &gt; 2;<br>});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] false</p><p>// 方法的第二个参数可选，作用是设定第一个参数中的this指向，如果使用第二个参数，注意callback不能是箭头函数<br>// 后面的迭代方法涉及此参数的，用法相同，不在赘述<br>let arr = [1, 2, 3, 4];<br>let temp = arr.every(function(item, index, array) {<br>    return item &gt; this.id;<br>}, {id: 2});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] false<br>复制代码</p><p><strong>14.some():</strong><br>作用：对数组中的每一项运行给定函数，如果该函数对任意一项返回true,则返回true（ES5方法）<br>参数：callback[, thisArg]<br>参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)<br>返回值：true 或 false<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4];<br>let temp = arr.some((item, index, array) =&gt; {<br>    return item &gt; 2;<br>});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] true<br>复制代码</p><p><strong>15.filter():</strong><br>作用：对数组中的每一项运行给定函数，返回该函数返回true的项组成的数组（ES5方法）<br>参数：callback[, thisArg]<br>参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)<br>返回值：函数返回true的项组成的数组<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4];<br>let temp = arr.filter((item, index, array) =&gt; {<br>    return item &gt; 2;<br>});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] [3, 4]<br>复制代码</p><p><strong>16.map():</strong><br>作用：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组（ES5方法）<br>参数：callback[, thisArg]<br>参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)<br>返回值：函数每次调用结果组成的数组<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4];<br>let temp = arr.map((item, index, array) =&gt; {<br>    return item * item;<br>});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] [ 1, 4, 9, 16]<br>复制代码</p><p><strong>17.forEach():</strong><br>作用：对数组中的每一项运行给定函数。无返回值（ES5方法）<br>参数：callback[, thisArg]<br>参数说明：callback有三个参数item(当前项),index(当前项索引)，array(数组对象本身)<br>返回值：无<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4];<br>let temp = arr.forEach((item, index, array) =&gt; {<br>    // 不会有返回值，但可在这里执行某些操作<br>    return item * item;<br>});<br>console.log(arr, temp); // [ 1, 2, 3, 4 ] undefined<br>复制代码<br>注意：<br>forEach在所有项都遍历完成之前，无法像for循环一样提前终止循环</p><p><strong>18.reduce():</strong><br>作用：从数组的第一项开始，逐步遍历到最后，迭代数组的所有项（ES5方法）<br>参数：callback[, initialValue]<br>参数说明：</p><p>callback迭代函数，有四个参数（prev, cur, index, array）</p><p>prev 前一个值，（initialValue || 数组第一项 || 上一次迭代的结果）<br>cur 当前迭代项<br>index 当前迭代项索引<br>array 迭代的原数组</p><p>initialValue 迭代的基础值，不传基础值是数组第一项</p><p>返回值：数组迭代后，整体的迭代结果<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>// 数组求和<br>let arr = [1, 2, 3];<br>let sum = arr.reduce((prev, cur, index, array) =&gt; {<br>    return prev + cur;<br>});<br>console.log(arr, sum); // [ 1, 2, 3 ] 6</p><p>// 传initialValue 基础值的示例<br>let sum1 = arr.reduce((prev, cur, index, array) =&gt; {<br>    return prev + cur;<br>}, 10);<br>// 返回的值是：10+1+2+3<br>console.log(arr, sum1); // [ 1, 2, 3 ] 16<br>复制代码<br>reduce源码的实现：<br>Array.prototype.myReduce = function(callback, initialVal){<br>   let prev = initialVal || this[0];<br>    for(var i = pre ? 0 : 1; i &lt; this.length; i++){<br>        prev = callback(prev, this[i], i, this);<br>   }<br>   return prev<br>}<br>复制代码</p><p><strong>19.reduceRight():</strong><br>作用：从数组的最后一项开始，逐步遍历到第一项，迭代数组的所有项（ES5方法）<br>参数：callback[, initialValue]<br>参数说明：</p><p>callback迭代函数，有四个参数（prev, cur, index, array）</p><p>prev 前一个值，（initialValue || 数组第一项 || 上一次迭代的结果）<br>cur 当前迭代项<br>index 当前迭代项索引<br>array 迭代的原数组</p><p>initialValue 迭代的基础值，不传基础值是数组第一项</p><p>返回值：数组迭代后，整体的迭代结果<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>// 拼接字符串,从后向前迭代数组进行拼接<br>let arr = [‘h’, ‘e’, ‘l’, ‘l’, ‘o’];<br>let str = arr.reduceRight((prev, cur, index, array) =&gt; {<br>    return prev + cur;<br>});<br>console.log(arr, str); // [ ‘h’, ‘e’, ‘l’, ‘l’, ‘o’ ] ‘olleh’<br>复制代码</p><p><strong>20.find():</strong><br>作用：查找数组中第一个符合条件的元素，返回该元素 (ES6新增)<br>参数：callback[, thisArg]<br>参数说明：参数的使用同上述的forEach、every、map、some、filter方法一致<br>返回值：查找到则返回该元素，没找到返回undefined<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4, 5];<br>let temp = arr.find((item, index, array) =&gt; {<br>    return item &gt; 2;<br>})<br>console.log(arr, temp); // [1, 2, 3, 4, 5] 3<br>复制代码</p><p><strong>21.findIndex():</strong><br>作用：查找数组中第一个符合条件的元素所在位置的索引，并返回该索引值<br>参数：callback[, thisArg]<br>参数说明：参数的使用同上述的forEach、every、map、some、filter方法一致<br>返回值：查找到则返回该索引值，没找到返回-1<br>原数组是否改变：涉及callback，因此不确定，具体详情见下文中的原型方法的小结部分。<br>let arr = [1, 2, 3, 4, 5];<br>let temp = arr.findIndex((item, index, array) =&gt; {<br>    return item &gt; 2;<br>})<br>console.log(arr, temp); // [1, 2, 3, 4, 5] 2<br>复制代码</p><p><strong>22.fill():</strong><br>作用：用指定元素，填充数组从start(包括)到end（不包括）之间的元素，如果该区间内已经有元素，直接替换掉（ES6新增）<br>参数：value[, start[, end]]<br>返回值：填充后的数组<br>原数组是否改变：是<br>let arr = [1, 2, 3, 4, 5];<br>let temp = arr.fill(‘a’, 2, 4);<br>console.log(arr, temp); // [1, 2, ‘a’, ‘a’, 5] [1, 2, ‘a’, ‘a’, 5]<br>复制代码</p><p><strong>23.includes():</strong><br>作用：判断数组中是否包含指定的元素（ES7新增）<br>参数：searchElement[, fromIndex]<br>返回值：true或false<br>原数组是否改变：否<br>let arr = [1, 2, 3, 4, 5];<br>let temp = arr.includes(5);<br>console.log(arr, temp); // [1, 2, 3, 4, 5] true</p><p>// 这个方法弥补了indexOf查看元素时的一个不足，即查找NaN的误差<br>let arr1 = [NaN, ‘a’];<br>let temp1 = arr1.includes(NaN);<br>let temp2 = arr1.indexOf(NaN);<br>console.log(temp1, temp2); // true -1<br>复制代码</p><p><strong>24.toString()、toLocalString():</strong><br>作用：调用数组每一项的toString()方法，返回的是以逗号分隔的字符串<br>参数：无<br>返回值：转化后的字符串<br>原字数组是否改变：否<br>let arr = [1, [1, 2, [4]], {name: “zhangsan”}, 3];<br>let temp = arr.toString();<br>console.log(arr); [ 1, [ 1, 2, [ 4 ] ], { name: ‘zhangsan’ }, 3 ]<br>console.log(temp); // ‘1,1,2,4,[object Object],3’<br>复制代码</p><p><strong>25.join():</strong><br>作用：将数组元素转化为字符串(调用每个元素的toString方法)，并使用指定的分隔符（默认为逗号）进行拼接，返回拼接后的字符串<br>参数：分隔符，默认为逗号（，）<br>返回值：拼接后的字符串<br>原数组是否改变：否<br>let arr = [1, [1, 2, [4]], {name: “zhangsan”}, 3];<br>let temp = arr.join();<br>console.log(arr); [ 1, [ 1, 2, [ 4 ] ], { name: ‘zhangsan’ }, 3 ]<br>console.log(temp); // ‘1,1,2,4,[object Object],3’</p><p>// 数组求和<br>let arr1 = [1, 2, 3];<br>console.log(eval(arr1.join(‘+’))); // 6</p><p><strong>数组扩展运算符（ES6新增）</strong></p><p>数组的扩展运算符可以将数组转化为以逗号分割的参数序列。<br>几个简单使用的应用场景：</p><p>1.将数组通过扩展运算符转化为参数序列直接传参，无需使用apply转化了let arr = [1, 2, 3];</p><p>// apply写法<br>Math.min.apply(null, arr)</p><p>// 扩展运算符写法<br>Math.min(…arr)<br>复制代码<br>2.可以用于复制和拼接数组let arr1 = [2, 3, 4];<br>let arr2 = [‘a’, ‘b’, ‘c’];</p><p>// 拼接数组arr1和arr2<br>console.log([…arr1, …arr2]); // [2, 3, 4, ‘a’, ‘b’, ‘c’]<br>复制代码<br>3.可用于将字符串分解为真正的数组，[…’hello’]  // [ ‘h’, ‘e’, ‘l’, ‘l’, ‘o’ ]</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIS基本使用</title>
      <link href="/2018/04/22/gis-ji-ben-shi-yong/"/>
      <url>/2018/04/22/gis-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411214279&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="从0搭建自己的webpack开发环境"><a href="#从0搭建自己的webpack开发环境" class="headerlink" title="从0搭建自己的webpack开发环境"></a>从0搭建自己的webpack开发环境</h1><hr><p><strong>1.什么是Webpack?</strong><br><strong>webpack</strong>是一个现代 <strong>JavaScript</strong> 应用程序的<strong>静态模块打包器</strong>(module bundler)，当 webpack 处理应用程序时，它会递归地构建一个<strong>依赖关系图</strong>(dependency graph)，其中包含应用程序需要的每个<strong>模块</strong>，然后将所有这些模块打包成一个或多个 <strong>bundle</strong><br><img src="node.jpg" alt></p><p>使用Webpack作为前端构建工具：</p><p>· 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等；<br>· 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等；<br>· 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载；<br>· 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件；<br>· 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器；<br>· 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过；<br>· 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</p><p>在<strong>webpack</strong>应用中有两个核心:</p><p>模块转换器，用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块；</p><p>扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</p><p><strong>2.初始化项目</strong></p>]]></content>
      
      
      <categories>
          
          <category> gis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一名【合格】前端工程师的自检清单</title>
      <link href="/2018/01/22/self-checking/"/>
      <url>/2018/01/22/self-checking/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><hr><p>前端开发是一个非常特殊的行业，它的历史实际上不是很长，但是知识之繁杂，技术迭代速度之快是其他技术所不能比拟的。</p><p><strong>winter</strong>在他的《重学前端》课程中提到：</p><!-- ![](749826.jpg) --><!-- 最后引用《我的少女时代》里的一句话吧。 --><blockquote><p>到现在为止，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，我发现极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。</p></blockquote><p>这样是一个非常真实的现状，实际上很多前端开发者都是自学甚至转行过来的，前端入门简单，学习了几个API以后上手做项目也很简单，但是这往往成为了限制自身发展的瓶颈。<br>只是停留在会用阶段是远远不够的，我们还需要不断探索和深入。现在市面上并不缺少学习教程，技术文章，如果盲目的学习你会发现看过以后的知识留存率会很低，而且发现没有了解到的知识越来越多，这会让人产生焦虑。<br>实际上，除了坚持学习的强大的自驱力，你还需要一个很简单的学习方法。那就是：建立自己的知识体系。它能帮助你更系统性的学习，同时你也时刻能知道自己哪些地方是不足的。<br>我会把我工作和学习中接触到的知识全部归纳到我的知识体系中，其中不仅仅包括我已经学过的，还有很多我没有来得及学习的。</p><p>下面我会把我的自检清单分享给大家，你可以按照清单上的知识检测自己还有哪些不足和提升，我也建议大家建自己的知识体系，这样工作或者学习甚至面试时，你能快速定位到知识清单中的点，如果你有哪些我没归纳到的点，欢迎在评论区告诉我。</p><p><img src="01.jpg" alt> </p><h1 id="一、JavaScript基础"><a href="#一、JavaScript基础" class="headerlink" title="一、JavaScript基础"></a>一、JavaScript基础</h1><blockquote><p>前端工程师吃饭的家伙，深度、广度一样都不能差。</p></blockquote><p><strong>变量和类型</strong><br>· 1.JavaScript规定了几种语言类型</p><p>· 2.JavaScript对象的底层数据结构是什么</p><p>· 3.Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</p><p>· 4.JavaScript中的变量在内存中的具体存储形式</p><p>· 5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作</p><p>· 6.理解值类型和引用类型</p><p>· 7.null和undefined的区别</p><p>. 8至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高工作效率的常用js函数汇总</title>
      <link href="/2018/01/22/ti-gao-gong-zuo-xiao-lu-de-chang-yong-js-han-shu-hui-zong/"/>
      <url>/2018/01/22/ti-gao-gong-zuo-xiao-lu-de-chang-yong-js-han-shu-hui-zong/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>闲来无事，随便写写……</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文总结了项目开发过程中常用的js函数和正则，意在提高大家平时的开发效率，具体内容如下：</p><ol><li>常用的正则校验</li><li>常用的设备检测方式</li><li>常用的日期时间函数</li><li>跨端事件处理</li><li>js移动端适配方案</li><li>xss预防方式</li><li>常用的js算法(防抖，截流，去重，排序，模板渲染，观察者…)</li><li>……</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-正则"><a href="#1-正则" class="headerlink" title="1. 正则"></a>1. 正则</h3><pre><code>  // 匹配邮箱  let reg = /^([a-zA-Z]|[0-9])(\w|\-)+@[a-zA-Z0-9]+\.([a-zA-Z]{2,4})$  // (新)匹配手机号  let reg = /^1[0-9]{10}$/;  // (旧)匹配手机号  let reg = /^1(3|4|5|7|8)[0-9]{9}$/;  // 匹配8-16位数字和字母密码的正则表达式  let reg = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{8,16}$/;  // 匹配国内电话号码 0510-4305211  let reg = /\d{3}-\d{8}|\d{4}-\d{7}/;  // 匹配身份证号码  let reg=/(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;  // 匹配腾讯QQ号  let reg = /[1-9][0-9]{4,}/;  // 匹配ip地址  let reg = /\d+\.\d+\.\d+\.\d+/;  // 匹配中文  let reg = /^[\u4e00-\u9fa5]*$/;</code></pre><h3 id="2-检测平台（设备）类型"><a href="#2-检测平台（设备）类型" class="headerlink" title="2.检测平台（设备）类型"></a>2.检测平台（设备）类型</h3><pre><code>  let isWechat = /micromessenger/i.test(navigator.userAgent),  isWeibo = /weibo/i.test(navigator.userAgent),  isQQ = /qq\//i.test(navigator.userAgent),  isIOS = /(iphone|ipod|ipad|ios)/i.test(navigator.userAgent),  isAndroid = /android/i.test(navigator.userAgent);</code></pre><h3 id="3-常用的日期时间函数"><a href="#3-常用的日期时间函数" class="headerlink" title="3. 常用的日期时间函数"></a>3. 常用的日期时间函数</h3><pre><code>  // 时间格式化  function format_date(timeStamp) {      let date = new Date(timeStamp);      return date.getFullYear() + &quot;年&quot;          + prefix_zero(date.getMonth() + 1) + &quot;月&quot;          + prefix_zero(date.getDate()) + &quot;日 &quot;          + prefix_zero(date.getHours()) + &quot;:&quot;          + prefix_zero(date.getMinutes());  }  // moment.js方法  //require 方式  var moment=require(&#39;moment&#39;);  //import 方式  import moment from &#39;moment&#39;;  格式化时间类型  1.取当天时间，以YYYY年MM月DD日形式显示  var now=moment().format(&quot;YYYY年MM月DD日&quot;);  2.任意时间戳格式化，以YYYY-MM-DD HH:mm:ss形式显示  var t1=moment(1411641720000).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);  获取前一天日期，格式以YYYY-MM-DD形式显示  var t11=moment().day(0).format(&#39;YYYY-MM-DD&#39;);  获取本周五日期，格式以YYYY-MM-DD形式显示  var t12=moment().weekday(5).format(&#39;YYYY-MM-DD&#39;);  获取上周五日期，格式以YYYY-MM-DD形式显示  var t13=moment().weekday(-3).format(&#39;YYYY-MM-DD&#39;);  可以简单理解为上周倒数第几天，上周倒数第三天就是上周五了，和当天日期无关  获取当前年份、月份、日期  var t14=moment().year()  var t15=moment().month()//此处月份从0开始，当前月要+1  var t16=moment().date();  // 数字格式化  function prefix_zero(num) {      return num &gt;= 10 ? num : &quot;0&quot; + num;  }  // 倒计时时间格式化  function format_time(timeStamp) {      let day = Math.floor(timeStamp / (24 * 3600 * 1000));      let leave1 = timeStamp % (24 * 3600 * 1000);      let hours = Math.floor(leave1 / (3600 * 1000));      let leave2 = leave1 % (3600 * 1000);      let minutes = Math.floor(leave2 / (60 * 1000));      let leave3 = leave2 % (60 * 1000);      let seconds = Math.floor(leave3 / 1000);      if (day) return day + &quot;天&quot; + hours + &quot;小时&quot; + minutes + &quot;分&quot;;      if (hours) return hours + &quot;小时&quot; + minutes + &quot;分&quot; + seconds + &quot;秒&quot;;      if (minutes) return minutes + &quot;分&quot; + seconds + &quot;秒&quot;;      if (seconds) return seconds + &quot;秒&quot;;      return &quot;时间到！&quot;;  }</code></pre><h3 id="4-跨端事件处理"><a href="#4-跨端事件处理" class="headerlink" title="4.跨端事件处理"></a>4.跨端事件处理</h3><pre><code>  // 是否支持触摸事件  let isSupportTouch = (&quot;ontouchstart&quot; in document.documentElement) ? true : false;  //禁用Enter键表单自动提交  document.onkeydown = function(event) {      let target, code, tag;      if (!event) {          event = window.event; //针对ie浏览器          target = event.srcElement;          code = event.keyCode;          if (code == 13) {              tag = target.tagName;              if (tag == &quot;TEXTAREA&quot;) { return true; }              else { return false; }          }      }      else {          target = event.target; //针对遵循w3c标准的浏览器，如Firefox          code = event.keyCode;          if (code == 13) {              tag = target.tagName;              if (tag == &quot;INPUT&quot;) { return false; }              else { return true; }          }      }  };</code></pre><h3 id="5-移动端适配方案"><a href="#5-移动端适配方案" class="headerlink" title="5. 移动端适配方案"></a>5. 移动端适配方案</h3><pre><code>  (function (doc, win) {      var docEl = doc.documentElement,          resizeEvt = &#39;orientationchange&#39; in window ? &#39;orientationchange&#39; : &#39;resize&#39;,          recalc = function () {              var clientWidth = docEl.clientWidth;              var fontSize = 20;              docEl.style.fontSize = fontSize + &#39;px&#39;;              var docStyles = getComputedStyle(docEl);              var realFontSize = parseFloat(docStyles.fontSize);              var scale = realFontSize / fontSize;              console.log(&quot;realFontSize: &quot; + realFontSize + &quot;, scale: &quot; + scale);              fontSize = clientWidth / 667 * 20;              if(isIphoneX()) fontSize = 19;              fontSize = fontSize / scale;              docEl.style.fontSize = fontSize + &#39;px&#39;;          };      // Abort if browser does not support addEventListener      if (!doc.addEventListener) return;      win.addEventListener(resizeEvt, recalc, false);      doc.addEventListener(&#39;DOMContentLoaded&#39;, recalc, false);      // iphoneX判断      function isIphoneX(){          return /iphone/gi.test(navigator.userAgent) &amp;&amp; (screen.height == 812 &amp;&amp; screen.width == 375)      }  })(document, window);</code></pre><h3 id="6-xss预防方式"><a href="#6-xss预防方式" class="headerlink" title="6.xss预防方式"></a>6.xss预防方式</h3><pre><code>  // 敏感符号转义  function entities(s) {      let e = {          &#39;&quot;&#39;: &#39;&amp;quot;&#39;,          &#39;&amp;&#39;: &#39;&amp;amp;&#39;,          &#39;&lt;&#39;: &#39;&amp;lt;&#39;,          &#39;&gt;&#39;: &#39;&amp;gt;&#39;      }      return s.replace(/[&quot;&lt;&gt;&amp;]/g, m =&gt; {          return e[m]      })  }</code></pre><h3 id="7-JS方法"><a href="#7-JS方法" class="headerlink" title="7. JS方法"></a>7. JS方法</h3><pre><code>  // 数组去重方法   1. 过滤+indexof  function distinct(arr = testArr) {      return arr.filter((v, i, array) =&gt; array.indexOf(v) === i)  }  2. 双重for循环  var array = [1, 1, &#39;1&#39;, &#39;1&#39;];  function unique(array) {      // res用来存储结果      var res = [];      for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) {          for (var j = 0, resLen = res.length; j &lt; resLen; j++ ) {              if (array[i] === res[j]) {                  break;              }          }          // 如果array[i]是唯一的，那么执行完循环，j等于resLen          if (j === resLen) {              res.push(array[i])          }      }      return res;  }  console.log(unique(array)); // [1, &quot;1&quot;]  3.排序后相邻去除法   var array = [1, 1, &#39;1&#39;];  function unique(array) {      var res = [];      var sortedArray = array.concat().sort();      var seen;      for (var i = 0, len = sortedArray.length; i &lt; len; i++) {          // 如果是第一个元素或者相邻的元素不相同          if (!i || seen !== sortedArray[i]) {              res.push(sortedArray[i])          }          seen = sortedArray[i];      }      return res;  }  console.log(unique(array));  4.Object 键值对  var array = [1, 2, 1, 1, &#39;1&#39;];  function unique(array) {      var obj = {};      return array.filter(function(item, index, array){          return obj.hasOwnProperty(item) ? false : (obj[item] = true)      })  }  console.log(unique(array)); // [1, 2]  //-----------------------------------------  var array = [{value: 1}, {value: 1}, {value: 2}];  function unique(array) {      var obj = {};      return array.filter(function(item, index, array){          console.log(typeof item + JSON.stringify(item))          return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true)      })  }  console.log(unique(array)); // [{value: 1}, {value: 2}]  5.ES6  var array = [1, 2, 1, 1, &#39;1&#39;];  function unique(array) {    return Array.from(new Set(array));  }  console.log(unique(array)); // [1, 2, &quot;1&quot;]  // 置换函数  function swap(arr, indexA, indexB) {      [arr[indexA], arr[indexB]] = [arr[indexB], arr[indexA]];  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
